<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>软件设计模式期末复习 | bshtj_blog</title><meta name="author" content="bshtj"><meta name="copyright" content="bshtj"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1 软件工程设计原则1.1 对象间关系  Dependency（依赖）：表示⼀个对象在某种程度上依赖于另⼀个对象。在⽂件中，它被⽤来描述“Professor（教授）” 和“Course（课程）”之间的关系，意味着教授依赖于课程来完成教学任务。&amp;#x20;  Association（关联）：表示两个对象之间有某种联系，但这种联系不像依赖那样强烈。在这⾥，它被⽤来描述 “Professor（教授）”和">
<meta property="og:type" content="article">
<meta property="og:title" content="软件设计模式期末复习">
<meta property="og:url" content="https://bshtj.github.io/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="bshtj_blog">
<meta property="og:description" content="1 软件工程设计原则1.1 对象间关系  Dependency（依赖）：表示⼀个对象在某种程度上依赖于另⼀个对象。在⽂件中，它被⽤来描述“Professor（教授）” 和“Course（课程）”之间的关系，意味着教授依赖于课程来完成教学任务。&amp;#x20;  Association（关联）：表示两个对象之间有某种联系，但这种联系不像依赖那样强烈。在这⾥，它被⽤来描述 “Professor（教授）”和">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bshtj.github.io/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/guru.png">
<meta property="article:published_time" content="2024-12-26T05:11:34.000Z">
<meta property="article:modified_time" content="2025-03-02T01:58:50.989Z">
<meta property="article:author" content="bshtj">
<meta property="article:tag" content="软件设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bshtj.github.io/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/guru.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "软件设计模式期末复习",
  "url": "https://bshtj.github.io/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/",
  "image": "https://bshtj.github.io/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/guru.png",
  "datePublished": "2024-12-26T05:11:34.000Z",
  "dateModified": "2025-03-02T01:58:50.989Z",
  "author": [
    {
      "@type": "Person",
      "name": "bshtj",
      "url": "https://bshtj.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/wuliannan.png"><link rel="canonical" href="https://bshtj.github.io/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"Z9MP5121BD","apiKey":"10b5fa00d61ba271dd1619df1cc5263e","indexName":"butterfly","hitsPerPage":6,"languages":{"input_placeholder":"Search...","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '软件设计模式期末复习',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/wuliannan.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">60</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://www.helloimg.com/i/2025/03/02/67c3b864134af.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">bshtj_blog</span></a><a class="nav-page-title" href="/"><span class="site-name">软件设计模式期末复习</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">软件设计模式期末复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-26T05:11:34.000Z" title="发表于 2024-12-26 13:11:34">2024-12-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-02T01:58:50.989Z" title="更新于 2025-03-02 09:58:50">2025-03-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/">大学课程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="1-软件工程设计原则"><a href="#1-软件工程设计原则" class="headerlink" title="1 软件工程设计原则"></a>1 软件工程设计原则</h1><h2 id="1-1-对象间关系"><a href="#1-1-对象间关系" class="headerlink" title="1.1 对象间关系"></a>1.1 对象间关系</h2><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-14.png"></p>
<ol>
<li><p><strong>Dependency（依赖）</strong>：表示⼀个对象在某种程度上依赖于另⼀个对象。在⽂件中，它被⽤来描述“Professor（教授）” 和“Course（课程）”之间的关系，意味着教授依赖于课程来完成教学任务。&#x20;</p>
</li>
<li><p><strong>Association（关联）</strong>：表示两个对象之间有某种联系，但这种<strong>联系不像依赖那样强烈</strong>。在这⾥，它被⽤来描述 “Professor（教授）”和“Student（学⽣）”之间的关系，表示教授和学⽣之间存在教学或指导的联系。&#x20;</p>
</li>
<li><p><strong>Aggregation（聚合）</strong>：表示⼀种整体与部分的关系，但部分可以独⽴于整体存在。⽂件中⽤“Professor（教授）”和 “Department（系）”来说明这种关系，意味着教授是系的⼀部分，但教授不依赖于系⽽存在。&#x20;</p>
</li>
<li><p><strong>Composition（组合）</strong>：也是⼀种整体与部分的关系，但与聚合不同的是，部分不能独⽴于整体存在。⽂件中⽤ “University（⼤学）”和“Department（系）”来说明这种关系，表示系是⼤学的⼀部分，并且系的存在依赖于⼤学。&#x20;</p>
</li>
<li><p><strong>Inheritance（继承）</strong>：这是⼀种类与类之间的关系，⼦类继承⽗类的属性和⽅法。⽂件中⽤“A→B”来表示这种关系， 意味着B类继承了A类的某些特性。</p>
</li>
</ol>
<h2 id="1-2-设计原则"><a href="#1-2-设计原则" class="headerlink" title="1.2 设计原则"></a>1.2 设计原则</h2><ol>
<li><p><strong>封装变化（Encapsulate what varies）</strong>:</p>
<ul>
<li><p>识别应用程序中变化的部分，并将它们与不变的部分分离。</p>
</li>
<li><p>目标是最小化变化带来的影响，通过将变化的部分隔离在独立的模块中，保护其他部分不受变化影响。</p>
</li>
<li><p>可以在方法级别和类级别上进行封装。</p>
</li>
</ul>
</li>
<li><p><strong>面向接口编程（Program to an interface, not an implementation）</strong>:</p>
<ul>
<li><p>依赖于抽象而不是具体类。</p>
</li>
<li><p>设计应足够灵活，能够轻松扩展而不影响现有代码。</p>
</li>
<li><p>通过定义接口或抽象类来描述一个对象需要从另一个对象中获取的内容，然后让依赖类实现这个接口，而不是依赖于具体类。</p>
</li>
</ul>
</li>
<li><p><strong>组合优于继承（Favor composition over inheritance）</strong>:</p>
<ul>
<li><p>继承带来的挑战包括子类不能减少父类的接口，重写方法时需要确保新行为与基类兼容，继承破坏了父类的封装，子类与父类紧密耦合。</p>
</li>
<li><p>通过组合（”has-a”关系）而不是继承（”is-a”关系）来重用代码。</p>
</li>
</ul>
</li>
<li><p><strong>SOLID原则</strong>:</p>
<ul>
<li><p><strong>单一职责原则（Single Responsibility Principle）</strong>: 一个类应该只有一个引起它变化的原因，即每个类应该只负责一个功能部分，并且该功能完全封装。</p>
</li>
<li><p><strong>开闭原则（Open&#x2F;Closed Principle）</strong>: 类应该对扩展开放，对修改封闭。这意味着可以在不修改现有代码的情况下扩展类的行为。</p>
</li>
<li><p><strong>里氏替换原则（Liskov Substitution Principle）</strong>: 子类对象应该能够替换其父类对象被使用，而不影响程序的正确性。子类应该保持与父类相同的行为。</p>
</li>
<li><p><strong>接口隔离原则（Interface Segregation Principle）</strong>: 客户端不应该依赖于它们不使用的方法。应该将“胖”接口拆分成更小、更具体的接口。</p>
</li>
<li><p><strong>依赖倒置原则（Dependency Inversion Principle）</strong>: 高层模块不应该依赖于低层模块，两者都应该依赖于抽象。改变依赖的方向，让高层模块和低层模块都依赖于抽象。</p>
</li>
</ul>
</li>
</ol>
<h1 id="2-创建型模式"><a href="#2-创建型模式" class="headerlink" title="2 创建型模式"></a>2 创建型模式</h1><h2 id="2-1-工厂方法模式"><a href="#2-1-工厂方法模式" class="headerlink" title="2.1 工厂方法模式"></a>2.1 工厂方法模式</h2><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-11.png"></p>
<p>调用工厂方法的代码 （通常被称为<em>客户端</em>代码） 无需了解不同子类返回实际对象之间的差别。 客户端将所有产品视为抽象的<code>运输</code> 。 客户端知道所有运输对象都提供<code>交付</code>方法，但是并不关心其具体实现方式。</p>
<p><strong>工厂方法模式结构</strong></p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-13.png"></p>
<ol>
<li><p><strong>产品</strong> （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。</p>
</li>
<li><p><strong>具体产品</strong> （Concrete Products） 是产品接口的不同实现。</p>
</li>
<li><p><strong>创建者</strong> （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与<strong>产品接口相匹配</strong>。</p>
</li>
<li><p><strong>具体创建者</strong> （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。</p>
</li>
</ol>
<p><strong>使用场景</strong></p>
<ul>
<li><p>当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。</p>
</li>
<li><p>如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。</p>
</li>
</ul>
<p><strong>实现方式</strong></p>
<ol>
<li><p>让所有产品都遵循同一接口。 该接口必须声明对所有产品都有意义的方法。</p>
</li>
<li><p>在创建类中添加一个空的工厂方法。 该方法的返回类型必须遵循通用的产品接口。</p>
</li>
<li><p>在创建者代码中找到对于产品构造函数的所有引用。 将它们依次替换为对于工厂方法的调用， 同时将创建产品的代码移入工厂方法。</p>
</li>
</ol>
<p><strong>优点</strong></p>
<ul>
<li><p>&#x20;你可以避免创建者和具体产品之间的紧密耦合。</p>
</li>
<li><p>&#x20;<em>单一职责原则</em>。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。</p>
</li>
<li><p>&#x20;<em>开闭原则</em>。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。</li>
</ul>
<h2 id="2-2-抽象工厂模式"><a href="#2-2-抽象工厂模式" class="headerlink" title="2.2 抽象工厂模式"></a>2.2 抽象工厂模式</h2><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-9.png"></p>
<p><strong>抽象工厂模式</strong>是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-8.png"></p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-7.png"></p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-4.png"></p>
<ol>
<li><p><strong>抽象产品</strong> （Abstract Product） 为构成系列产品的一组不同但相关的产品声明接口。</p>
</li>
<li><p><strong>具体产品</strong> （Concrete Product） 是抽象产品的多种不同类型实现。 所有变体 （维多利亚&#x2F;现代） 都必须实现相应的抽象产品 （椅子&#x2F;沙发）。</p>
</li>
<li><p><strong>抽象工厂</strong> （Abstract Factory） 接口声明了一组创建各种抽象产品的方法。</p>
</li>
<li><p><strong>具体工厂</strong> （Concrete Factory） 实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体。</p>
</li>
<li><p>尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的<em>抽象</em>产品。如下，返回的Button是抽象产品(接口)。</p>
</li>
</ol>
<p>&#x20;     这样， 使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。 <strong>客户端</strong> （Client） 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂&#x2F;产品变体交互。</p>
<p><strong>适用场景</strong></p>
<ul>
<li><p>如果代码需要与多个不同系列的相关产品交互， 但是由于<strong>无法提前获取相关信息</strong>， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。</p>
</li>
<li><p>如果你有一个基于一组<a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/factory-method">抽象方法</a>的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。</p>
</li>
</ul>
<p><strong>实现方式</strong></p>
<ol>
<li><p>以不同的产品类型与产品变体为维度绘制矩阵。</p>
</li>
<li><p>为所有产品声明抽象产品接口。 然后让所有具体产品类实现这些接口。</p>
</li>
<li><p>声明抽象工厂接口， 并且在接口中为所有抽象产品提供一组构建方法。</p>
</li>
<li><p>为每种产品变体实现一个具体工厂类。</p>
</li>
<li><p>在应用程序中开发初始化代码。 该代码根据应用程序配置或当前环境， 对特定具体工厂类进行初始化。 然后将该工厂对象传递给所有需要创建产品的类。</p>
</li>
<li><p>找出代码中所有对产品构造函数的直接调用， 将其替换为对工厂对象中相应构建方法的调用。</p>
</li>
</ol>
<p><strong>优点</strong></p>
<ul>
<li><p>你可以确保同一工厂生成的产品相互匹配。</p>
</li>
<li><p>你可以避免客户端和具体产品代码的耦合。</p>
</li>
<li><p><em>单一职责原则</em>。 你可以将产品生成代码抽取到同一位置，使得代码易于维护。</p>
</li>
<li><p>&#x20;<em>开闭原则</em>。 向应用程序中引入新产品变体时， 你无需修改客户端代码。</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。</li>
</ul>
<h2 id="2-3-生成器模式"><a href="#2-3-生成器模式" class="headerlink" title="2.3 生成器模式"></a>2.3 生成器模式</h2><p><strong>生成器模式</strong>是一种创建型设计模式， 使你能够分<strong>步骤创建</strong>复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。</p>
<p>生成器模式建议将对象构造代码从产品类中抽取出来， 并将其放在一个名为<em>生成器</em>的独立对象中。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-6.png"></p>
<p>生成器模式让你能够分步骤创建复杂对象。 生成器不允许其他对象访问正在创建中的产品。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-12.png"></p>
<ol>
<li><p><strong>生成器</strong> （Builder） 接口声明在所有类型生成器中通用的产品构造步骤。</p>
</li>
<li><p><strong>具体生成器</strong> （Concrete Builders） 提供构造过程的<strong>不同实现</strong>。 具体生成器也可以构造不遵循通用接口的产品。</p>
</li>
<li><p><strong>产品</strong> （Products） 是最终生成的对象。 由不同生成器构造的产品无需属于同一类层次结构或接口。</p>
</li>
<li><p><strong>主管</strong> （Director） 类定义调用构造步骤的顺序， 这样你就可以创建和复用特定的产品配置。</p>
</li>
<li><p><strong>客户端</strong> （Client） 必须将某个<strong>生成器对象</strong>与<strong>主管类</strong>关联。 一般情况下， 你只需通过<strong>主管类构造函数</strong>的参数进行一次性关联即可。 此后主管类就能使用生成器对象完成后续所有的构造任务。 但在客户端将生成器对象<strong>传递</strong>给主管类制造方法时还有另一种方式。 在这种情况下， 你在使用主管类生产产品时每次都可以使用不同的生成器。</p>
</li>
</ol>
<p><strong>使用场景</strong></p>
<ol>
<li><p>使用生成器模式可避免 “重叠构造函（telescoping constructor）” 的出现。例如</p>
</li>
<li><p>&#x20;当你希望使用代码创建不同形式的产品 （例如石头或木头房屋） 时， 可使用生成器模式。</p>
</li>
<li><p>使用生成器构造<a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/composite">组合</a>树或其他复杂对象。</p>
</li>
</ol>
<p><strong>优点</strong></p>
<ul>
<li><p>你可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。</p>
</li>
<li><p>&#x20;生成不同形式的产品时， 你可以复用相同的制造代码。</p>
</li>
<li><p>&#x20;<em>单一职责原则</em>。 你可以将复杂构造代码从产品的业务逻辑中分离出来。</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/builder"><strong>生成器</strong></a>重点关注如何分步生成复杂对象。 <a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/abstract-factory"><strong>抽象工厂</strong></a>专门用于生产一系列相关对象。 <em>抽象工厂</em>会马上返回产品， <em>生成器</em>则允许你在获取产品前执行一些额外构造步骤。</li>
</ul>
<h2 id="2-4-原型模式"><a href="#2-4-原型模式" class="headerlink" title="2.4 原型模式"></a>2.4 原型模式</h2><p><strong>原型模式</strong>是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-10.png"></p>
<ol>
<li><p><strong>原型</strong> （Prototype） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 <code>clone</code>克隆的方法。</p>
</li>
<li><p><strong>具体原型</strong> （Concrete Prototype） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。</p>
</li>
<li><p><strong>客户端</strong> （Client） 可以复制实现了原型接口的任何对象。</p>
</li>
</ol>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-3.png"></p>
<p><strong>使用场景</strong></p>
<ol>
<li><p>如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。</p>
</li>
<li><p>如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。</p>
</li>
</ol>
<p><strong>实现步骤</strong></p>
<ol>
<li><p>创建原型接口， 并在其中声明 <code>克隆</code>方法。 如果你已有类层次结构， 则只需在其所有类中添加该方法即可。</p>
</li>
<li><p>原型类必须另行定义一个以该类对象为参数的构造函数。 构造函数必须复制参数对象中的所有成员变量值到新建实体中。 如果你需要修改子类， 则必须调用父类构造函数， 让父类复制其私有成员变量值。</p>
</li>
<li><p>克隆方法通常只有一行代码： 使用 <code>new</code>运算符调用原型版本的构造函数。</p>
</li>
<li><p>你还可以创建一个中心化原型注册表， 用于存储常用原型。</p>
</li>
</ol>
<p><strong>优点</strong></p>
<ul>
<li><p>你可以克隆对象， 而无需与它们所属的具体类相耦合。</p>
</li>
<li><p>你可以克隆预生成原型， 避免反复运行初始化代码。</p>
</li>
<li><p>你可以更方便地生成复杂对象。</p>
</li>
<li><p>你可以用继承以外的方式来处理复杂对象的不同配置。</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>克隆包含循环引用的复杂对象可能会非常麻烦。</li>
</ul>
<h2 id="2-5-单例模式"><a href="#2-5-单例模式" class="headerlink" title="2.5 单例模式"></a>2.5 单例模式</h2><p><strong>单例模式</strong>是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p>
<p>单例模式同时解决了两个问题， 所以违反了<em>单一职责原则</em>：</p>
<ol>
<li><p><strong>保证一个类只有一个实例</strong>。 它的运作方式是这样的： 如果你创建了一个对象， 同时过一会儿后你决定再创建一个新对象， 此时你会获得之前已创建的对象， 而不是一个新对象。注意， 普通构造函数无法实现上述行为， 因为构造函数的设计决定了它<strong>必须</strong>总是返回一个新对象。</p>
</li>
<li><p><strong>为该实例提供一个全局访问节点</strong>。&#x20;</p>
</li>
</ol>
<p>&#x20;    和全局变量一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-5.png"></p>
<ol>
<li><p><strong>单例</strong> （Singleton） 类声明了一个名为 <code>get­Instance</code>获取实例的静态方法来返回其所属类的一个相同实例。</p>
</li>
<li><p>单例的构造函数必须对客户端 （Client） 代码隐藏。 调用 <code>获取实例</code>方法必须是获取单例对象的唯一方式。</p>
</li>
</ol>
<p><strong>使用场景</strong></p>
<ul>
<li><p>如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。</p>
</li>
<li><p>如果你需要更加严格地控制全局变量， 可以使用单例模式。</p>
</li>
</ul>
<p><strong>实现方式</strong></p>
<ol>
<li><p>在类中添加一个私有静态成员变量用于保存单例实例。</p>
</li>
<li><p>声明一个公有静态构建方法用于获取单例实例。</p>
</li>
<li><p>在静态方法中实现”延迟初始化”。 该方法会在首次被调用时创建一个新对象， 并将其存储在静态成员变量中。 此后该方法每次被调用时都返回该实例。</p>
</li>
<li><p>将类的构造函数<strong>设为私有</strong>。 类的静态方法仍能调用构造函数， 但是其他对象不能调用。</p>
</li>
<li><p>检查客户端代码， 将对单例的构造函数的调用替换为<strong>对其静态构建方法的调用</strong>。</p>
</li>
</ol>
<p>总结一下，就是构造静态方法创建并访问，阻止所有其他可以new一个实例的方法。</p>
<p><strong>优点</strong></p>
<ul>
<li><p>你可以保证一个类只有一个实例。</p>
</li>
<li><p>&#x20;你获得了一个指向该实例的全局访问节点。</p>
</li>
<li><p>&#x20;仅在首次请求单例对象时对其进行初始化。</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><p>违反了<em>单一职责原则</em>。 该模式同时解决了两个问题。</p>
</li>
<li><p>单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。</p>
</li>
<li><p>该模式在多线程环境下需要进行特殊处理， <strong>避免多个线程多次创建单例对象</strong>。</p>
</li>
<li><p>单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。</p>
</li>
</ul>
<h1 id="3-结构型模式"><a href="#3-结构型模式" class="headerlink" title="3 结构型模式"></a>3 结构型模式</h1><h2 id="3-1-适配器模式"><a href="#3-1-适配器模式" class="headerlink" title="3.1 适配器模式"></a>3.1 适配器模式</h2><p><strong>适配器模式</strong>是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-1.png"></p>
<ol>
<li><p><strong>客户端</strong> （Client） 是包含当前程序业务逻辑的类。</p>
</li>
<li><p><strong>客户端接口</strong> （Client Interface） 描述了其他类与客户端代码合作时必须遵循的<strong>协议</strong>。</p>
</li>
<li><p><strong>服务</strong> （Service） 中有一些功能类 （通常来自第三方或遗留系统）。 客户端<strong>与其接口不兼容</strong>， 因此无法直接调用其功能。</p>
</li>
<li><p><strong>适配器</strong> （Adapter） 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时封装了服务对象。 适配器接受客户端通过适配器接口发起的调用， 并将其转换为适用于被封装服务对象的调用。</p>
</li>
<li><p>客户端代码只需<strong>通过接口</strong>与适配器交互即可， <strong>无需与具体</strong>的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。</p>
</li>
</ol>
<p><strong>适用场景</strong></p>
<ul>
<li><p>当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。</p>
</li>
<li><p>如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。</p>
</li>
</ul>
<p><strong>实现方式</strong></p>
<ol>
<li><p>确保至少有两个类的接口不兼容：</p>
<ul>
<li><p>一个无法修改 （通常是第三方、 遗留系统或者存在众多已有依赖的类） 的功能性<em>服务</em>类。</p>
</li>
<li><p>一个或多个将受益于使用服务类的<em>客户端</em>类。</p>
</li>
</ul>
</li>
<li><p>声明客户端接口， 描述客户端如何与服务交互。</p>
</li>
<li><p>创建遵循客户端接口的适配器类。 所有方法暂时都为空。</p>
</li>
<li><p>在适配器类中添加一个成员变量用于保存对于服务对象的引用。 通常情况下会通过构造函数对该成员变量进行初始化， 但有时在调用其方法时将该变量传递给适配器会更方便。</p>
</li>
<li><p>依次实现适配器类客户端接口的所有方法。 适配器会将实际工作委派给服务对象， <strong>自身只负责接口或数据格式的转换</strong>。</p>
</li>
<li><p>客户端必须通过客户端接口使用适配器。 这样一来， 你就可以在不影响客户端代码的情况下修改或扩展适配器。</p>
</li>
</ol>
<p><strong>优点</strong></p>
<ul>
<li><p><em>单一职责原则</em>你可以将接口或数据转换代码从程序主要业务逻辑中分离。</p>
</li>
<li><p>&#x20;<em>开闭原则</em>。 只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>代码整体复杂度增加， 因为你需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。</li>
</ul>
<h2 id="3-2-桥接模式"><a href="#3-2-桥接模式" class="headerlink" title="3.2 桥接模式"></a>3.2 桥接模式</h2><p><strong>桥接模式</strong>是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为<strong>抽象</strong>和<strong>实现</strong>两个独立的层次结构， 从而能在开发时分别使用。</p>
<p><em>抽象部分</em> （也被称为<em>接口</em>） 是一些实体的高阶控制层。 该层自身不完成任何具体的工作， 它需要将工作委派给<em>实现部分</em>层 （也被称为<em>平台</em>）。</p>
<p>注意， 这里提到的内容与编程语言中的<em>接口</em>或<em>抽象类</em>无关。 它们并不是一回事。</p>
<p>在实际的程序中， 抽象部分是图形用户界面 （GUI）， 而实现部分则是底层操作系统代码 （API）， GUI 层调用 API 层来对用户的各种操作做出响应。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image.png"></p>
<p>将一个类层次转化为多个相关的类层次， 避免单个类层次的失控。</p>
<p>根据该方法， 我们可以将颜色相关的代码抽取到拥有 <code>红色</code>和 <code>蓝色</code>两个子类的颜色类中， 然后在 <code>形状</code>类中添加一个指向某一颜色对象的引用成员变量。 现在， 形状类可以将所有与颜色相关的工作委派给连入的颜色对象。 这样的引用就成为了 <code>形状</code>和 <code>颜色</code>之间的桥梁。 此后， 新增颜色将不再需要修改形状的类层次， 反之亦然。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-2.png"></p>
<ol>
<li><p><strong>抽象部分</strong> （Abstraction） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。</p>
</li>
<li><p><strong>实现部分</strong> （Implementation） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。</p>
</li>
</ol>
<p>&#x20;     抽象部分可以列出和实现部分一样的方法， 但是抽象       部分通常声明一些复杂行为， 这些行为依赖于多种由       实现部分声明的原语操作。</p>
<ul>
<li><p><strong>具体实现</strong> （Concrete Implementations） 中包括特定于平台的代码。</p>
</li>
<li><p><strong>精确抽象</strong> （Refined Abstraction） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。</p>
</li>
<li><p>通常情况下， <strong>客户端</strong> （Client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。</p>
</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li><p>如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。</p>
</li>
<li><p>如果你希望在几个独立维度上扩展一个类， 可使用该模式。</p>
</li>
<li><p>&#x20;如果你需要在运行时切换不同实现方法， 可使用桥接模式。</p>
</li>
</ul>
<p><strong>实现方式</strong></p>
<ol>
<li><p>明确类中独立的维度。 独立的概念可能是： 抽象&#x2F;平台， 域&#x2F;基础设施， 前端&#x2F;后端或接口&#x2F;实现。</p>
</li>
<li><p>了解客户端的业务需求， 并在抽象基类中定义它们。</p>
</li>
<li><p>确定在所有平台上都可执行的业务。 并在通用实现接口中声明抽象部分所需的业务。</p>
</li>
<li><p>为你域内的所有平台创建实现类， 但需确保它们遵循实现部分的接口。</p>
</li>
<li><p>在抽象类中添加指向实现类型的引用成员变量。 抽象部分会<strong>将大部分工作委派给该成员变量所指向的实现对象。</strong></p>
</li>
<li><p>如果你的高层逻辑有多个变体， 则可通过<strong>扩展抽象基类</strong>为每个变体创建一个精确抽象。</p>
</li>
<li><p>客户端代码必须将实现对象传递给抽象部分的构造函数才能使其能够相互关联。 此后， 客户端只需与抽象对象进行交互， 无需和实现对象打交道。</p>
</li>
</ol>
<p><strong>优点</strong></p>
<ul>
<li><p>你可以创建与平台无关的类和程序。</p>
</li>
<li><p>客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。</p>
</li>
<li><p><em>开闭原则</em>。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响。</p>
</li>
<li><p><em>单一职责原则</em>。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节。</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>对高内聚的类使用该模式可能会让代码更加复杂。</li>
</ul>
<h2 id="3-3-组合模式"><a href="#3-3-组合模式" class="headerlink" title="3.3 组合模式"></a>3.3 组合模式</h2><p><strong>组合模式</strong>是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-29.png"></p>
<ol>
<li><p><strong>组件</strong> （Component） 接口描述了树中简单项目和复杂项目所共有的操作。</p>
</li>
<li><p><strong>叶节点</strong> （Leaf） 是树的基本结构， 它不包含子项目。一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。</p>
</li>
<li><p><strong>容器</strong> （Container）——又名 “组合（Composite）”——是包含叶节点或其他容器等子项目的单位。 容器<strong>不知道其子项目所属的具体类</strong>， 它只通过通用的组件接口与其子项目交互。</p>
</li>
</ol>
<p>&#x20;    容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。</p>
<ul>
<li><strong>客户端</strong> （Client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li><p>&#x20;如果你需要实现树状对象结构， 可以使用组合模式。</p>
</li>
<li><p>&#x20;如果你希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。</p>
</li>
</ul>
<p><strong>实现方式</strong></p>
<ol>
<li><p>确保应用的核心模型能够以树状结构表示。 尝试将其分解为简单元素和容器。 记住， 容器必须能够同时包含简单元素和其他容器。</p>
</li>
<li><p>声明组件接口及其一系列方法， 这些方法对简单和复杂元素都有意义。</p>
</li>
<li><p>创建一个叶节点类表示简单元素。 程序中可以有多个不同的叶节点类。</p>
</li>
<li><p>创建一个容器类表示复杂元素。 在该类中， 创建一个数组成员变量来存储对于其子元素的引用。 该数组必须能够同时保存叶节点和容器， 因此请确保将其声明为组合接口类型。</p>
</li>
</ol>
<p>&#x20;     实现组件接口方法时， 记住容器应该将大部分工作交给其子元素来完成。</p>
<ul>
<li>最后，在容器中定义<strong>添加和删除</strong>子元素的方法。</li>
</ul>
<p>&#x20;     记住，这些操作可在组件接口中声明。 这将会违反<em>接口隔离原则</em>， 因为叶节点类中的这些方法为空。 但是， 这可以让客户端无差别地访问所有元素， 即使是组成树状结构的元素。</p>
<p><strong>优点</strong></p>
<ul>
<li><p>你可以利用多态和递归机制更方便地使用复杂树结构。</p>
</li>
<li><p><em>开闭原则</em>。 无需更改现有代码， 你就可以在应用中添加新元素， 使其成为对象树的一部分。</p>
</li>
</ul>
<p><strong>缺点&#x20;</strong></p>
<ul>
<li>对于功能差异较大的类， 提供公共接口或许会有困难。 在特定情况下， 你需要过度一般化组件接口， 使其变得令人难以理解。</li>
</ul>
<h2 id="3-4-装饰模式"><a href="#3-4-装饰模式" class="headerlink" title="3.4 装饰模式"></a>3.4 装饰模式</h2><p><strong>装饰模式</strong>是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-25.png"></p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-28.png"></p>
<p>客户端代码必须将基础通知器放入一系列自己所需的装饰中。 因此最后的对象将形成一个栈结构。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-26.png"></p>
<p><strong>装饰器模式结构</strong></p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-27.png"></p>
<ol>
<li><p><strong>部件</strong>（Component）声明封装器和被封装对象的公用接口。</p>
</li>
<li><p><strong>具体部件</strong>（Concrete Component）类是被封装对象所属的类。 它定义了基础行为， 但装饰类可以改变这些行为。</p>
</li>
<li><p><strong>基础装饰</strong> （Base Decorator）类拥有一个指向<strong>被封装对象的引用成员变量</strong>。 该变量的类型应当被声明为通用部件接口， 这样它就可以引用具体的部件和装饰。 装饰基类会将所有操作委派给被封装的对象。</p>
</li>
<li><p><strong>具体装饰类</strong> （Concrete Decorators） 定义了可动态添加到部件的<strong>额外行为</strong>。 具体装饰类会重写装饰基类的方法， 并在调用父类方法之前或之后进行额外的行为。</p>
</li>
<li><p><strong>客户端</strong> （Client）可以使用多层装饰来封装部件， 只要它能使用通用接口与所有对象互动即可。</p>
</li>
</ol>
<p><strong>适用场景</strong></p>
<ul>
<li><p>如果你希望在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式。</p>
</li>
<li><p>如果用继承来扩展对象行为的方案难以实现或者根本不可行，你可以使用该模式。</p>
</li>
</ul>
<p><strong>实现方式</strong></p>
<ol>
<li><p>确保业务逻辑可用一个基本组件及多个额外可选层次表示。</p>
</li>
<li><p>找出基本组件和可选层次的通用方法。 创建一个组件接口并在其中声明这些方法。</p>
</li>
<li><p>创建一个具体组件类， 并定义其基础行为。</p>
</li>
<li><p>创建装饰基类， 使用一个成员变量存储指向被封装对象的引用。 该成员变量必须被声明为组件接口类型， 从而能在运行时连接具体组件和装饰。 装饰基类必须将所有工作委派给被封装的对象。</p>
</li>
<li><p>确保所有类实现组件接口。</p>
</li>
<li><p>将装饰基类扩展为具体装饰。 具体装饰必须在调用父类方法 （总是委派给被封装对象） 之前或之后执行自身的行为。</p>
</li>
<li><p>客户端代码负责创建装饰并将其组合成客户端所需的形式。</p>
</li>
</ol>
<p><strong>优点</strong></p>
<ul>
<li><p>&#x20;你无需创建新子类即可扩展对象的行为。</p>
</li>
<li><p>&#x20;你可以在运行时添加或删除对象的功能。</p>
</li>
<li><p>&#x20;你可以用多个装饰封装对象来组合几种行为。</p>
</li>
<li><p>&#x20;<em>单一职责原则</em>。 你可以将实现了许多不同行为的一个大类拆分为多个较小的类。</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><p>&#x20;在封装器栈中删除特定封装器比较困难。</p>
</li>
<li><p>&#x20;实现行为不受装饰栈顺序影响的装饰比较困难。</p>
</li>
<li><p>&#x20;各层的初始化配置代码看上去可能会很糟糕。</p>
</li>
</ul>
<h2 id="3-5-外观模式"><a href="#3-5-外观模式" class="headerlink" title="3.5 外观模式"></a>3.5 外观模式</h2><p><strong>外观模式</strong>是一种结构型设计模式，能为程序库、框架或其他复杂类提供一个简单的接口。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-24.png"></p>
<ol>
<li><p><strong>外观</strong> （Facade） 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。</p>
</li>
<li><p><strong>创建附加外观</strong> （Additional Facade） 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。</p>
</li>
<li><p><strong>复杂子系统</strong> （Complex Subsystem） 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。</p>
</li>
</ol>
<p>&#x20;     子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。</p>
<ul>
<li><strong>客户端</strong> （Client） 使用外观代替对子系统对象的直接调用。</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li><p>如果你需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。</p>
</li>
<li><p>如果需要将子系统组织为多层结构， 可以使用外观。</p>
</li>
</ul>
<p><strong>实现方式</strong></p>
<ol>
<li><p>考虑能否在现有子系统的基础上提供一个更简单的接口。如果该接口能让客户端代码独立于众多子系统类，那么你的方向就是正确的。</p>
</li>
<li><p>在一个新的外观类中声明并实现该接口。 外观应将客户端代码的调用重定向到子系统中的相应对象处。 如果客户端代码没有对子系统进行初始化，也没有对其后续生命周期进行管理，那么外观必须完成此类工作。</p>
</li>
<li><p>如果要充分发挥这一模式的优势，你必须确保所有客户端代码仅通过外观来与子系统进行交互。此后客户端代码将不会受到任何由子系统代码修改而造成的影响，比如子系统升级后，你只需修改外观中的代码即可。</p>
</li>
<li><p>如果外观变得<a target="_blank" rel="noopener" href="https://refactoringguru.cn/smells/large-class">过于臃肿</a>，你可以考虑将其部分行为抽取为一个新的专用外观类。</p>
</li>
</ol>
<p><strong>优点</strong></p>
<ul>
<li>你可以让自己的代码独立于复杂子系统。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>外观可能成为与程序中所有类都耦合的<a target="_blank" rel="noopener" href="https://refactoringguru.cn/antipatterns/god-object"><strong>上帝对象</strong></a>。</li>
</ul>
<h2 id="3-6-享元模式"><a href="#3-6-享元模式" class="headerlink" title="3.6 享元模式"></a>3.6 享元模式</h2><p><strong>享元模式</strong>是一种结构型设计模式，它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。</p>
<p>对象的<strong>常量数据</strong>通常被称&#x4E3A;<em><strong>内在状态</strong></em>， 其位于对象中， 其他对象只能读取但不能修改其数值。 而对象的其他状态常常能被其他对象 <strong>“从外部” 改变</strong>， 因此被称&#x4E3A;<strong><em>外在状态</em>。</strong></p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-23.png"></p>
<ol>
<li><p>享元模式只是一种<strong>优化。</strong> 在应用该模式之前， 你要确定程序中存在与<strong>大量类似对象</strong>同时占用内存相关的内存消耗问题， 并且确保该问题无法使用其他更好的方式来解决。</p>
</li>
<li><p><strong>享元</strong> （Flyweight） 类包含原始对象中部分能在多个对象中共享的状态。 同一享元对象可在许多不同情景中使用。 享元中存储的状态被称为 “内在状态”。 传递给享元方法的状态被称为 “外在状态”。</p>
</li>
<li><p><strong>情景</strong> （Context） 类包含原始对象中各不相同的外在状态。 情景与享元对象组合在一起就能表示原始对象的全部状态。</p>
</li>
<li><p>通常情况下， 原始对象的行为会保留在享元类中。 因此调用享元方法必须提供部分外在状态作为参数。 但你也可将行为移动到情景类中， 然后将连入的享元作为单纯的数据对象。</p>
</li>
<li><p><strong>客户端</strong> （Client） 负责计算或存储享元的外在状态。 在客户端看来， 享元是一种可在运行时进行配置的模板对象， 具体的配置方式为向其方法中传入一些情景数据参数。</p>
</li>
<li><p><strong>享元工厂</strong> （Flyweight Factory） 会对已有享元的缓存池进行管理。 有了工厂后， 客户端就无需直接创建享元， 它们只需调用工厂并向其传递目标享元的一些内在状态即可。 工厂会根据参数在之前已创建的享元中进行查找， 如果找到满足条件的享元就将其返回； 如果没有找到就根据参数新建享元。</p>
</li>
</ol>
<p><strong>适用场景</strong></p>
<ul>
<li>&#x20;仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。</li>
</ul>
<p><strong>实现方式</strong></p>
<ol>
<li><p>将需要改写为享元的类成员变量拆分为两个部分：</p>
<ul>
<li><p><strong>内在状态</strong>： 包含不变的、 可在许多对象中重复使用的数据的成员变量。</p>
</li>
<li><p><strong>外在状态</strong>： 包含每个对象各自不同的情景数据的成员变量</p>
</li>
</ul>
</li>
<li><p>保留类中表示内在状态的成员变量， 并将其属性设置为不可修改。 这些变量仅可在构造函数中获得初始数值。</p>
</li>
<li><p>找到所有使用外在状态成员变量的方法， 为在方法中所用的每个成员变量新建一个参数， 并使用该参数代替成员变量。</p>
</li>
<li><p>你可以有选择地创建工厂类来管理享元缓存池， 它负责在新建享元时检查已有的享元。 如果选择使用工厂， 客户端就只能通过工厂来请求享元， 它们需要将享元的内在状态作为参数传递给工厂。</p>
</li>
<li><p>客户端必须存储和计算外在状态 （情景） 的数值， 因为只有这样才能调用享元对象的方法。 为了使用方便， 外在状态和引用享元的成员变量可以移动到单独的情景类中。</p>
</li>
</ol>
<p><strong>优点</strong></p>
<ul>
<li>&#x20;如果程序中有很多相似对象， 那么你将可以节省大量内存。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><p>&#x20;你可能需要牺牲执行速度来换取内存， 因为他人每次调用享元方法时都需要重新计算部分情景数据。</p>
</li>
<li><p>&#x20;代码会变得更加复杂。 团队中的新成员总是会问：  “为什么要像这样拆分一个实体的状态？”。</p>
</li>
</ul>
<h2 id="3-7-代理模式"><a href="#3-7-代理模式" class="headerlink" title="3.7 代理模式"></a>3.7 代理模式</h2><p><strong>代理模式</strong>是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-22.png"></p>
<ol>
<li><p><strong>服务接口</strong> （Service Interface） 声明了服务接口。 代理必须<strong>遵循该接口才能伪装成服务对象</strong>。</p>
</li>
<li><p><strong>服务</strong> （Service） 类提供了一些实用的业务逻辑。</p>
</li>
<li><p><strong>代理</strong> （Proxy） 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。</p>
</li>
</ol>
<p>&#x20;    通常情况下， 代理会对其服务对象的整个生命周期进行管理。</p>
<ul>
<li><strong>客户端</strong> （Client） 能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。</li>
</ul>
<p><strong>实现方式：</strong></p>
<ol>
<li><p>如果没有现成的服务接口， 你就需要创建一个接口来实现代理和服务对象的可交换性。 从服务类中抽取接口并非总是可行的， 因为你需要对服务的所有客户端进行修改， 让它们使用接口。 备选计划是将代理作为服务类的子类， 这样代理就能继承服务的所有接口了。</p>
</li>
<li><p>创建代理类， 其中必须包含一个存储<strong>指向服务的引用</strong>的成员变量。 通常情况下， 代理负责创建服务并对其整个生命周期进行管理。 在一些特殊情况下， 客户端会通过构造函数将服务传递给代理。</p>
</li>
<li><p>根据需求实现代理方法。 在大部分情况下，代理在完成一些任务后应将工作委派给服务对象。</p>
</li>
<li><p>可以考虑新建一个构建方法来判断客户端可获取的是代理还是实际服务。 你可以在代理类中创建一个简单的静态方法， 也可以创建一个完整的工厂方法。</p>
</li>
<li><p>可以考虑为服务对象实现延迟初始化。</p>
</li>
</ol>
<p><strong>优点：</strong></p>
<ul>
<li><p>&#x20;你可以在客户端毫无察觉的情况下控制服务对象。</p>
</li>
<li><p>&#x20;如果客户端对服务对象的生命周期没有特殊要求， 你可以对生命周期进行管理。</p>
</li>
<li><p>&#x20;即使服务对象还未准备好或不存在， 代理也可以正常工作。</p>
</li>
<li><p>&#x20;<em>开闭原则</em>。 你可以在不对服务或客户端做出修改的情况下创建新代理。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>代码可能会变得复杂， 因为需要新建许多类。</p>
</li>
<li><p>&#x20;服务响应可能会延迟。</p>
</li>
</ul>
<h1 id="4-行为模式"><a href="#4-行为模式" class="headerlink" title="4 行为模式"></a>4 行为模式</h1><h2 id="4-1-责任链模式"><a href="#4-1-责任链模式" class="headerlink" title="4.1 责任链模式"></a>4.1 责任链模式</h2><p><strong>责任链模式</strong>是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个<strong>处理者均可对请求进行处理</strong>， 或将其传递给链上的下个处理者。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-21.png"></p>
<ol>
<li><p><strong>处理者</strong> （Handler） 声明了<strong>所有具体处理者</strong>的通用接口。 该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法。</p>
</li>
<li><p><strong>基础处理者</strong> （Base Handler） 是一个<strong>可选</strong>的类， 你可以将所有处理者<strong>共用的</strong>样本代码放置在其中。</p>
</li>
</ol>
<p>&#x20;    通常情况下， 该类中定义了一个保存<strong>对于下个处理者引用的成员变量</strong>。 客户端可通过将处理者传递给上个处理者的构造函数或设定方法来创建链。 该类还可以实现默认的处理行为：确定下个处理者存在后再将请求传递给它。</p>
<ul>
<li><strong>具体处理者</strong> （Concrete Handlers） 包含处理请求的实际代码。 每个处理者接收到请求后， 都必须决定是否进行处理， 以及是否沿着链传递请求。</li>
</ul>
<p>&#x20;    处理者通常是独立且不可变的， 需要通过构造函数<strong>一次性地获得所有必要地数据。</strong></p>
<ul>
<li><strong>客户端</strong> （Client） 可根据程序逻辑一次性或者动态地生成链。 值得注意的是， 请求可发送给链上的<strong>任意一个处理者， 而非必须是第一个处理者。</strong></li>
</ul>
<h2 id="4-2-命令模式"><a href="#4-2-命令模式" class="headerlink" title="4.2 命令模式"></a>4.2 命令模式</h2><p><strong>命令模式</strong>是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-19.png"></p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-18.png"></p>
<ol>
<li><p><strong>发送者</strong> （Sender）——亦称 “触发者 （Invoker）”——类负责对请求进行初始化， 其中必须包含一个成员变量来存储对于命令对象的引用。 发送者触发命令， 而不向接收者直接发送请求。 注意，发送者并不负责创建命令对象： 它通常会通过构造函数从客户端处获得预先生成的命令。</p>
</li>
<li><p><strong>命令</strong> （Command） 接口通常仅声明一个执行命令的方法。</p>
</li>
<li><p><strong>具体命令</strong> （Concrete Commands） 会实现各种类型的请求。 具体命令自身并不完成工作， 而是会将调用委派给一个业务逻辑对象。 但为了简化代码， 这些类可以进行合并。</p>
</li>
</ol>
<p>&#x20;    接收对象执行方法所需的参数可以声明为具体命令的成员变量。 你可以将命令对象设为不可变， 仅允许通过构造函数对这些成员变量进行初始化。</p>
<ul>
<li><p><strong>接收者</strong> （Receiver） 类包含<strong>部分业务</strong>逻辑。 几乎任何对象都可以作为接收者。 绝大部分命令只处理如何将请求传递到接收者的细节， 接收者自己会完成实际的工作。</p>
</li>
<li><p><strong>客户端</strong> （Client） 会创建并配置具体命令对象。 客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。 此后， 生成的命令就可以与一个或多个发送者相关联了。</p>
</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li><p>如果你需要通过操作来参数化对象， 可使用命令模式。</p>
</li>
<li><p>如果你想要将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式。</p>
</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li><p>&#x20;<em>单一职责原则</em>。 你可以解耦触发和执行操作的类。</p>
</li>
<li><p>&#x20;<em>开闭原则</em>。 你可以在不修改已有客户端代码的情况下在程序中创建新的命令。</p>
</li>
<li><p>&#x20;你可以实现撤销和恢复功能。</p>
</li>
<li><p>&#x20;你可以实现操作的延迟执行。</p>
</li>
<li><p>&#x20;你可以将一组简单命令组合成一个复杂命令。</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>&#x20;代码可能会变得更加复杂， 因为你在发送者和接收者之间增加了一个全新的层次。</li>
</ul>
<h2 id="4-3-迭代器模式"><a href="#4-3-迭代器模式" class="headerlink" title="4.3 迭代器模式"></a>4.3 迭代器模式</h2><p><strong>迭代器模式</strong>是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-17.png"></p>
<ol>
<li><p><strong>迭代器</strong> （Iterator） 接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。</p>
</li>
<li><p><strong>具体迭代器</strong> （Concrete Iterators） 实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。</p>
</li>
<li><p><strong>集合</strong> （Collection） 接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意，返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。</p>
</li>
<li><p><strong>具体集合</strong> （Concrete Collections） 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 你可能会琢磨， 剩下的集合代码在什么地方呢？ 不用担心， 它也会在同一个类中。 只是这些细节对于实际模式来说并不重要， 所以我们将其省略了而已。</p>
</li>
<li><p><strong>客户端</strong> （Client） 通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。</p>
</li>
</ol>
<p>&#x20;    客户端通常不会自行创建迭代器， 而是会从集合中获取。 但在特定情况下， 客户端可以直接创建一个迭代器 （例如当客户端需要自定义特殊迭代器时）。</p>
<h2 id="4-4-中介者模式"><a href="#4-4-中介者模式" class="headerlink" title="4.4 中介者模式"></a>4.4 中介者模式</h2><p><strong>中介者模式</strong>是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。</p>
<p>如果直接在表单元素代码中实现业务逻辑， 你将很难在程序其他表单中<strong>复用</strong>这些元素类。 例如， 由于复选框类与狗狗的文本框相耦合， 所以将无法在其他表单中使用它。 你要么使用渲染资料表单时用到的所有类， 要么一个都不用。</p>
<p>解决方案</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-16.png"></p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20.png"></p>
<ol>
<li><p><strong>组件</strong> （Component） 是各种包含业务逻辑的类。 每个组件都有一个指向中介者的引用， 该引用被声明为中介者接口类型。 组件不知道中介者实际所属的类， 因此你可通过将其连接到不同的中介者以使其能在其他程序中复用。</p>
</li>
<li><p><strong>中介者</strong> （Mediator） 接口声明了与组件交流的方法， 但通常仅包括一个通知方法。 组件可将任意上下文 （包括自己的对象） 作为该方法的参数， 只有这样接收组件和发送者类之间才不会耦合。</p>
</li>
<li><p><strong>具体中介者</strong> （Concrete Mediator） 封装了多种组件间的关系。 具体中介者通常会保存所有组件的引用并对其进行管理， 甚至有时会对其生命周期进行管理。</p>
</li>
<li><p>组件并不知道其他组件的情况。 如果组件内发生了重要事件， 它只能通知中介者。 中介者收到通知后能轻易地确定发送者， 这或许已足以判断接下来需要触发的组件了。</p>
</li>
</ol>
<p>&#x20;    对于组件来说， 中介者看上去完全就是一个<strong>黑箱</strong>。 发送者不知道最终会由谁来处理自己的请求， 接收者也不知道最初是谁发出了请求。</p>
<p><strong>优点：</strong></p>
<ul>
<li><p>&#x20;<em>单一职责原则</em>。 你可以将多个组件间的交流抽取到同一位置， 使其更易于理解和维护。</p>
</li>
<li><p>&#x20;<em>开闭原则</em>。 你无需修改实际组件就能增加新的中介者。</p>
</li>
<li><p>&#x20;你可以减轻应用中多个组件间的耦合情况。</p>
</li>
<li><p>&#x20;你可以更方便地复用各个组件。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>一段时间后， 中介者可能会演化成为<a target="_blank" rel="noopener" href="https://refactoringguru.cn/antipatterns/god-object"><strong>上帝对象</strong></a>。</li>
</ul>
<h2 id="4-5-备忘录模式"><a href="#4-5-备忘录模式" class="headerlink" title="4.5 备忘录模式"></a>4.5 备忘录模式</h2><p><strong>备忘录模式</strong>是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-15.png"></p>
<ol>
<li><p>这种实现方式允许存在多种不同类型的原发器和备忘录。 每种原发器都和其相应的备忘录类进行交互。 原发器和备忘录都不会将其状态暴露给其他类。</p>
</li>
<li><p>负责人此时被明确禁止修改存储在备忘录中的状态。 但负责人类将独立于原发器， 因为此时恢复方法被定义在了备忘录类中。</p>
</li>
<li><p>每个备忘录将与创建了自身的原发器连接。 原发器会将自己及状态传递给备忘录的构造函数。 由于这些类之间的紧密联系， 只要原发器定义了合适的设置器 （setter）， 备忘录就能恢复其状态。</p>
</li>
</ol>
<h2 id="4-6-观察者模式"><a href="#4-6-观察者模式" class="headerlink" title="4.6 观察者模式"></a>4.6 观察者模式</h2><p><strong>观察者模式</strong>是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-36.png"></p>
<ol>
<li><p><strong>发布者</strong> （Publisher）会向其他对象发送值得关注的事件。 事件会在发布者自身状态改变或执行特定行为后发生。 发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。</p>
</li>
<li><p>当新事件发生时， 发送者会<strong>遍历订阅列表</strong>并调用每个订阅者对象的通知方法。 该方法是在订阅者接口中声明的。</p>
</li>
<li><p><strong>订阅者</strong> （Subscriber）接口声明了通知接口。 在绝大多数情况下， 该接口仅包含一个 <code>update</code>更新方法。 该方法可以拥有多个参数， 使发布者能在更新时传递事件的详细信息。</p>
</li>
<li><p><strong>具体订阅者</strong>（Concrete Subscribers）可以执行一些操作来回应发布者的通知。所有具体订阅者类都实现了同样的接口， 因此发布者不需要与具体类相耦合。</p>
</li>
<li><p>订阅者通常需要一些上下文信息来正确地处理更新。 因此，发布者通常会将一些上下文数据作为通知方法的参数进行传递。发布者也可将自身作为参数进行传递， 使订阅者直接获取所需的数据。</p>
</li>
<li><p><strong>客户端</strong>（Client）会分别创建发布者和订阅者对象，然后为订阅者注册发布者更新。</p>
</li>
</ol>
<h2 id="4-7-状态模式"><a href="#4-7-状态模式" class="headerlink" title="4.7 状态模式"></a>4.7 状态模式</h2><p><strong>状态模式</strong>是一种行为设计模式， 让你能在一个对象的<strong>内部状态变化时改变其行为</strong>， 使其看上去就像改变了自身所属的类一样。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-34.png"></p>
<ol>
<li><p><strong>上下文</strong> （Context） 保存了对于一个具体状态对象的引用，并会将所有与该状态相关的工作委派给它。上下文通过状态接口与状态对象交互，且会提供一个设置器用于传递新的状态对象。</p>
</li>
<li><p><strong>状态</strong> （State） 接口会声明特定于状态的方法。 这些方法应能被其他所有具体状态所理解，因为你不希望某些状态所拥有的方法永远不会被调用。</p>
</li>
<li><p><strong>具体状态</strong> （Concrete States） 会自行实现特定于状态的方法。 为了避免多个状态中包含相似代码，你可以提供一个封装有部分通用行为的中间抽象类。</p>
</li>
</ol>
<p>&#x20;    状态对象可存储对于上下文对象的<strong>反向引用</strong>。状态可以通过该引用从上下文处获取所需信息，并且能触发状态转移。</p>
<ul>
<li>上下文和具体状态都可以设置上下文的下个状态，并可通过替换连接到上下文的状态对象来完成实际的状态转换。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li><p><em>单一职责原则</em>。 将与特定状态相关的代码放在单独的类中。</p>
</li>
<li><p><em>开闭原则</em>。 无需修改已有状态类和上下文就能引入新状态。</p>
</li>
<li><p>通过消除臃肿的状态机条件语句简化上下文代码。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>如果状态机只有很少的几个状态， 或者很少发生改变， 那么应用该模式可能会显得小题大作。</li>
</ul>
<p><strong>比较：</strong></p>
<ul>
<li>在<strong>状态模式</strong>中， 特定状态知道其他所有状态的存在， 且能触发从一个状态到另一个状态的转换； <strong>策略</strong>则几乎完全不知道其他策略的存在。</li>
</ul>
<h2 id="4-8-策略模式"><a href="#4-8-策略模式" class="headerlink" title="4.8 策略模式"></a>4.8 策略模式</h2><p><strong>策略模式</strong>是一种行为设计模式， 它能让你定义一系列算法， 并将<strong>每种算法分别放入独立的类</strong>中， 以使<strong>算法的对象</strong>能够<strong>相互替换</strong>。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-33.png"></p>
<p>&#x20;      在导游应用中， 每个路线规划算法都可被抽取到只有一个 <code>build­Route</code>生成路线方法的独立类中。该方法接收起点和终点作为参数， 并返回路线中途点的集合。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-32.png"></p>
<ol>
<li><p><strong>上下文</strong> （Context） 维护指向具体策略的引用， 且仅通过策略接口与该对象进行交流。</p>
</li>
<li><p><strong>策略</strong> （Strategy） 接口是所有具体策略的通用接口， 它声明了一个上下文用于执行策略的方法。</p>
</li>
<li><p><strong>具体策略</strong> （Concrete Strategies） 实现了上下文所用算法的各种不同变体。</p>
</li>
<li><p>当上下文需要运行算法时， 它会在其已连接的策略对象上调用执行方法。 上下文不清楚其所涉及的策略类型与算法的执行方式。</p>
</li>
<li><p><strong>客户端</strong> （Client） 会创建一个特定策略对象并将其传递给上下文。 上下文则会提供一个设置器以便客户端在运行时替换相关联的策略。</p>
</li>
</ol>
<h2 id="4-9-模版方法模式"><a href="#4-9-模版方法模式" class="headerlink" title="4.9 模版方法模式"></a>4.9 模版方法模式</h2><p><strong>模板方法模式</strong>是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许<strong>子类</strong>在<strong>不修改结构的情况下</strong>重写算法的特定步骤。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-35.png"></p>
<ol>
<li><p><strong>抽象类</strong> （Abstract­Class） 会声明作为<strong>算法步骤</strong>的方法， 以及<strong>依次调用</strong>它们的实际模板方法。 算法步骤可以被声明为 <code>抽象</code>类型， 也可以提供一些默认实现。</p>
</li>
<li><p><strong>具体类</strong> （Concrete­Class） 可以重写所有步骤， 但不能重写模板方法自身。</p>
</li>
</ol>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-31.png"></p>
<p><strong>适用场景：</strong></p>
<ul>
<li><p>当你只希望客户端扩展某个特定算法步骤， 而不是整个算法或其结构时， 可使用模板方法模式。</p>
</li>
<li><p>当多个类的算法除一些细微不同之外几乎完全一样时， 你可使用该模式。 但其后果就是， 只要算法发生变化， 你就可能需要修改所有的类。</p>
</li>
</ul>
<h2 id="4-10-访问者模式"><a href="#4-10-访问者模式" class="headerlink" title="4.10 访问者模式"></a>4.10 访问者模式</h2><p><strong>访问者模式</strong>是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。</p>
<p>访问者模式建议将新行为放入一个名为<em>访问者</em>的独立类中， 而不是试图将其整合到已有类中。 <strong>需要执行操作的原始对象</strong>将<strong>作为参数</strong>被传递给访问者中的方法， 让方法能访问对象所包含的一切必要数据。</p>
<p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-30.png"></p>
<ol>
<li><p><strong>访问者</strong> （Visitor） 接口声明了一系列以对象结构的具体元素为参数的访问者方法。 如果编程语言支持重载， 这些方法的名称可以是相同的， 但是其参数一定是不同的。</p>
</li>
<li><p><strong>具体访问者</strong> （Concrete Visitor） 会为不同的具体元素类实现相同行为的几个不同版本。</p>
</li>
<li><p><strong>元素</strong> （Element） 接口声明了一个方法来 “接收” 访问者。 该方法必须有一个参数被声明为访问者接口类型。</p>
</li>
<li><p><strong>具体元素</strong> （Concrete Element） 必须实现接收方法。 该方法的目的是根据当前元素类将其调用重定向到相应访问者的方法。 请注意， 即使元素基类实现了该方法， 所有子类都必须对其进行重写并调用访问者对象中的合适方法。</p>
</li>
<li><p><strong>客户端</strong> （Client） 通常会作为集合或其他复杂对象 （例如一个<a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/composite"><strong>组合</strong></a>树） 的代表。 客户端通常不知晓所有的具体元素类， 因为它们会通过抽象接口与集合中的对象进行交互。</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://bshtj.github.io">bshtj</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://bshtj.github.io/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">https://bshtj.github.io/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://bshtj.github.io" target="_blank">bshtj_blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">软件设计模式</a></div><div class="post-share"><div class="social-share" data-image="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/guru.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/" title="R语言期中复习"><img class="cover" src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/r.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">R语言期中复习</div></div><div class="info-2"><div class="info-item-1">2 R基础语法 2.1 vector 2.1.1 排除元素使用负索引 暂时无法在飞书文档外展示此内容 2.1.2 提取满足条件的元素可以使用逻辑条件（如 ==、&lt;、&gt; 等）来筛选元素。 暂时无法在飞书文档外展示此内容 2.1.3**which()** 函数which() 函数用于返回满足条件的元素的下标索引。它返回的是逻辑条件为 TRUE 的元素的索引位置。 示例：找到大于30的元素的下标 暂时无法在飞书文档外展示此内容 输出： 暂时无法在飞书文档外展示此内容 which(vec &gt; 30) 返回的是大于30的元素的下标位置，即第4个和第5个元素。 2.1.4 which.min() 和 which.max() 函数 which.min()：返回向量中最小值的下标。 which.max()：返回向量中最大值的下标。  示例：找到最小值和最大值的下标 暂时无法在飞书文档外展示此内容 输出： 暂时无法在飞书文档外展示此内容 在这个例子中，which.min(vec) 返回最小值 10 的下标 1，而 which.max(vec) 返回最大值 50 的下标...</div></div></div></a><a class="pagination-related" href="/2025/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="软件工程期末复习"><img class="cover" src="/2025/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/baike.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">软件工程期末复习</div></div><div class="info-2"><div class="info-item-1"> 一共6个题 &#x20; 十个选择 每个3分 单选+多选，错一个扣0.5 第二题 和敏捷开发有关，分析题 10 第三题，看图分析题，和需求分析建模有关 12 第四题，应用分析题 15 第五题，图形题，和分析设计（需求分析+概要设计）有关 第六题，概要设计 &#x20; 第一章 1.1 中的 1.1.1，1.1.2，1.1.3 1.2 中 1.2.2，1.2.3 &#x20; 第二章 2.1，2.2（2.2.1,2.2.2,2.2.3） 2.3(2.3.1,2.3.2) 2.4 &#x20; 第三章 3.1,3.2,3.3,3.4 &#x20; 第四章 4.1（4.1.1，4.1.2，4.1.3（prototype model，spiral...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/wuliannan.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">bshtj</div><div class="author-info-description">学术辣鸡，不定时更新</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">60</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.</span> <span class="toc-text">1 软件工程设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%AF%B9%E8%B1%A1%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 对象间关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 设计原则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">2 创建型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 工厂方法模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 抽象工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 生成器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 原型模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 单例模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">3 结构型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 适配器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 桥接模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 组合模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 装饰模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 外观模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 享元模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 代理模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">4 行为模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 责任链模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 命令模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 迭代器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 中介者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 备忘录模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 观察者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.7.</span> <span class="toc-text">4.7 状态模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.8.</span> <span class="toc-text">4.8 策略模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.9.</span> <span class="toc-text">4.9 模版方法模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.10.</span> <span class="toc-text">4.10 访问者模式</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" title="正则表达式基本使用"><img src="/2025/06/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/home.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="正则表达式基本使用"/></a><div class="content"><a class="title" href="/2025/06/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" title="正则表达式基本使用">正则表达式基本使用</a><time datetime="2025-06-19T08:12:24.000Z" title="发表于 2025-06-19 16:12:24">2025-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/14/%E5%A6%82%E4%BD%95%E5%AE%8C%E6%95%B4%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%EF%BC%9F/" title="如何完整部署一个项目上线？"><img src="/2025/06/14/%E5%A6%82%E4%BD%95%E5%AE%8C%E6%95%B4%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%EF%BC%9F/image.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何完整部署一个项目上线？"/></a><div class="content"><a class="title" href="/2025/06/14/%E5%A6%82%E4%BD%95%E5%AE%8C%E6%95%B4%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%EF%BC%9F/" title="如何完整部署一个项目上线？">如何完整部署一个项目上线？</a><time datetime="2025-06-14T09:33:52.000Z" title="发表于 2025-06-14 17:33:52">2025-06-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%88%E5%AD%97%E5%85%B8%E5%BA%8F%EF%BC%89/" title="每日一题（字典序）">每日一题（字典序）</a><time datetime="2025-06-09T13:53:03.000Z" title="发表于 2025-06-09 21:53:03">2025-06-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/08/3-5cache/" title="3.5 cache"><img src="/2025/06/08/3-5cache/image-10.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="3.5 cache"/></a><div class="content"><a class="title" href="/2025/06/08/3-5cache/" title="3.5 cache">3.5 cache</a><time datetime="2025-06-08T14:29:00.000Z" title="发表于 2025-06-08 22:29:00">2025-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/08/3-4%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8E%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98SSD/" title="3.4 磁盘存储器与固态硬盘SSD"><img src="/2025/06/08/3-4%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8E%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98SSD/image-14.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="3.4 磁盘存储器与固态硬盘SSD"/></a><div class="content"><a class="title" href="/2025/06/08/3-4%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8E%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98SSD/" title="3.4 磁盘存储器与固态硬盘SSD">3.4 磁盘存储器与固态硬盘SSD</a><time datetime="2025-06-08T14:28:30.000Z" title="发表于 2025-06-08 22:28:30">2025-06-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By bshtj</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>