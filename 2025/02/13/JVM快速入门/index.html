<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM快速入门 | bshtj_blog</title><meta name="author" content="bshtj"><meta name="copyright" content="bshtj"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本笔记基于视频 https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1yE411Z7AP，旨在快速入门JVM。 笔记借 https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq\_45966440&#x2F;article&#x2F;details&#x2F;120824295?spm&#x3D;1001.2014.3001.5502    ClassLoader：Java 代码编译成二进制后，会经过类加载器，这样才能加载到 JV">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM快速入门">
<meta property="og:url" content="https://bshtj.github.io/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="bshtj_blog">
<meta property="og:description" content="本笔记基于视频 https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1yE411Z7AP，旨在快速入门JVM。 笔记借 https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq\_45966440&#x2F;article&#x2F;details&#x2F;120824295?spm&#x3D;1001.2014.3001.5502    ClassLoader：Java 代码编译成二进制后，会经过类加载器，这样才能加载到 JV">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bshtj.github.io/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-12.png">
<meta property="article:published_time" content="2025-02-13T14:10:51.000Z">
<meta property="article:modified_time" content="2025-03-02T01:55:54.621Z">
<meta property="article:author" content="bshtj">
<meta property="article:tag" content="java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bshtj.github.io/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-12.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JVM快速入门",
  "url": "https://bshtj.github.io/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/",
  "image": "https://bshtj.github.io/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-12.png",
  "datePublished": "2025-02-13T14:10:51.000Z",
  "dateModified": "2025-03-02T01:55:54.621Z",
  "author": [
    {
      "@type": "Person",
      "name": "bshtj",
      "url": "https://bshtj.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/wuliannan.png"><link rel="canonical" href="https://bshtj.github.io/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM快速入门',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/wuliannan.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://www.helloimg.com/i/2025/03/02/67c3b864134af.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">bshtj_blog</span></a><a class="nav-page-title" href="/"><span class="site-name">JVM快速入门</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">JVM快速入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-13T14:10:51.000Z" title="发表于 2025-02-13 22:10:51">2025-02-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-02T01:55:54.621Z" title="更新于 2025-03-02 09:55:54">2025-03-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>本笔记基于视频 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yE411Z7AP%EF%BC%8C%E6%97%A8%E5%9C%A8%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8JVM%E3%80%82">https://www.bilibili.com/video/BV1yE411Z7AP，旨在快速入门JVM。</a></p>
<p>笔记借 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq/_45966440/article/details/120824295?spm=1001.2014.3001.5502">https://blog.csdn.net/qq\_45966440/article/details/120824295?spm=1001.2014.3001.5502</a></p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-12.png"></p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-14.png"></p>
<ul>
<li><p>ClassLoader：Java 代码编译成二进制后，会经过类加载器，这样才能加载到 JVM 中运行。</p>
</li>
<li><p>Method Area：类是放在方法区中。</p>
</li>
<li><p>Heap：类的实例对象。</p>
</li>
</ul>
<p>当类调用方法时，会用到 JVM Stack、PC Register、本地方法栈。</p>
<p>方法执行时的每行代码是有执行引擎中的解释器逐行执行，方法中的热点代码频繁调用的方法，由 JIT 编译器优化后执行，GC 会对堆中不用的对象进行回收。需要和操作系统打交道就需要使用到本地方法接口。</p>
<h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h1><h2 id="程序计数器PC-Register"><a href="#程序计数器PC-Register" class="headerlink" title="程序计数器PC Register"></a>程序计数器PC Register</h2><p>和操作系统中的程序计数器类似，作用是记录吓一跳jvm指令的执行地址<strong>行号</strong>。</p>
<p>特点：</p>
<ul>
<li><p><strong>线程私有(每一个线程有一个程序计数器)</strong></p>
</li>
<li><p><strong>不存在内存溢出(jvm规范规定的，程序计数器是 JVM 内存区域中唯一一个不会抛出 <code>OutOfMemoryError</code> 的区域。)</strong></p>
</li>
</ul>
<p>如下图所示，以下是java代码以及对应编译成的二进制字节码(jvm指令)。这些指令在不同操作系统下依旧一样，这些字节码还要通过解释器将其转换为机器码才能够被CPU执行。</p>
<p>多线程的环境下，如果两个线程发生了上下文切换(比如说CPU的时间轮转算法结束之后换线程)，那么程序计数器会记录线程下一行指令的地址行号，以便于接着往下执行(每个线程对应一个程序计数器)。</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol>
<li><p><strong>每个线程运行需要的内存空间，称为虚拟机栈</strong></p>
</li>
<li><p><strong>每个栈由多个栈帧（Frame）组成，对应着每次调用方法时所占用的内存。</strong></p>
</li>
</ol>
<p>&#x20;     可以想一下，一个frame对应一个方法的调用，每个方法运行时所需要的内存就称为一个frame(如方法中的参数、局部变量、返回值等都需要内存，划分一个frame)，frame出栈就代表frame被释放。</p>
<p>&#x20;      一个栈可以有多个frame组成，因为一个方法可以调用其他方法。</p>
<ul>
<li><strong>每个线程只能有一个活动栈帧，对应着当前正在执行的方法</strong></li>
</ul>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-11.png"></p>
<p>问题辨析：</p>
<ol>
<li>垃圾回收是否涉及栈内存？</li>
</ol>
<p>不会。栈内存是方法调用产生的，方法调用结束后会弹出栈。</p>
<ul>
<li>栈内存分配越大越好吗？</li>
</ul>
<p>不是。因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</p>
<p>如何手动定义栈的大小呢？</p>
<p>可以设置-Xss参数，例如-Xss1m</p>
<ul>
<li>方法的局部变量是否保证线程安全？</li>
</ul>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-10.png"></p>
<p>对于以上代码如果多个线程同时调用这个方法，会造成冲突吗？</p>
<ul>
<li><strong>如果方法内部的变量没有逃离方法的作用访问，它是线程安全的。</strong></li>
</ul>
<p>如上图所示，不同的线程会创建不同的局部变量存到各自的frame中，他们是隔离的</p>
<ul>
<li><strong>如果是局部变量引用了对象，并逃离了方法的访问，那就要考虑线程安全问题。&#x20;</strong></li>
</ul>
<p>比如我定一个static，那他就是共享的了，就不安全了。</p>
<h3 id="分析以下代码是否会是线程安全的？"><a href="#分析以下代码是否会是线程安全的？" class="headerlink" title="分析以下代码是否会是线程安全的？"></a>分析以下代码是否会是线程安全的？</h3><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-9.png"></p>
<p>第一个不会，他是局部变量。</p>
<p>第二个会，因为他是作为参数存进来的，可能有两个线程同时使用同一个对象作为参数调用该函数。</p>
<p>第三个也不行，他讲局部变量作为返回值返回来了，可能被不同的线程修改。</p>
<h3 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h3><p>栈内存溢出的情况：</p>
<ol>
<li><p>栈帧frame过多</p>
</li>
<li><p>栈帧过大</p>
</li>
</ol>
<p>注意，只要调用了一个方法，不管他是不是static，是不是自己调用自己都是会新建一个栈帧的。</p>
<h3 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h3><ol>
<li>CPU占用过多</li>
</ol>
<ul>
<li><p>在linux中，先用top定位那个进程对cpu的占用过高</p>
</li>
<li><p>再用ps H -eo pid,tid,%cpu | grep 进程id进一步定位那个线程引起的CPU占用过高。</p>
</li>
<li><p>jstack 进程 id 通过查看进程中的线程的 nid ，刚才通过 ps 命令看到的 tid 来对比定位，注意 jstack 查找出的线程 id 是 16 进制的，需要转换。</p>
</li>
<li><p>程序运行很长时间没有结果</p>
</li>
</ul>
<p>使用jstack查看是否存在死锁</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-13.png"></p>
<p>一些带有 native 关键字的方法就是需要 JAVA 去调用本地的C或者C++方法，因为 JAVA 有时候没法直接和操作系统底层交互，所以需要用到本地方法栈，服务于带 native 关键字的方法。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>Heap 堆</p>
<p>通过new关键字创建的对象都会被放在堆内存</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>它是线程共享，堆内存中的对象都需要考虑线程安全问题</p>
<p>有垃圾回收机制</p>
<p>2）堆内存溢出</p>
<p>java.lang.OutofMemoryError ：java heap space. 堆内存溢出</p>
<p>可以使用 -Xmx8m 来指定堆内存大小。</p>
<p>3）堆内存诊断</p>
<p>jps 工具</p>
<p>查看当前系统中有哪些 java 进程</p>
<p>jmap 工具</p>
<p>查看堆内存占用情况 jmap - heap 进程id</p>
<p>jconsole 工具</p>
<p>图形界面的，多功能的监测工具，可以连续监测</p>
<p>jvisualvm 工具</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区是各个<strong>线程共享</strong>的内存区域，它用于存储已被<strong>虚拟机加载的类信息(比如class文件)、常量、静态变量</strong>、即时编译器编译后的代码等数据。（什么是类信息：<strong>类版本号、方法、接口</strong>。）</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-8.png"></p>
<ul>
<li><p><strong>永久代</strong>用的<strong>堆内存</strong></p>
</li>
<li><p><strong>元空间</strong>用的<strong>本地内存</strong></p>
</li>
</ul>
<h4 id="方法区内存溢出"><a href="#方法区内存溢出" class="headerlink" title="方法区内存溢出"></a>方法区内存溢出</h4><ul>
<li><p>1.8以前会导致<strong>永久代</strong>内存溢出<code>java.lang.OutOfMemoryError: PermGen space</code></p>
</li>
<li><p>1.8以后会导致<strong>元空间</strong>内存溢出<code>java.lang.OutOfMemoryError: Metaspace</code></p>
</li>
</ul>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul>
<li><p>属于操作系统，常见于NIO操作时，用于数据缓冲区(如Bytebuffer)</p>
</li>
<li><p>分配回收成本较高，但读写性能高</p>
</li>
<li><p><strong>不受JVM内存回收管理</strong></p>
</li>
</ul>
<h4 id="分配和回收原理"><a href="#分配和回收原理" class="headerlink" title="分配和回收原理"></a>分配和回收原理</h4><p>读写过程</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-6.png"></p>
<p>系统缓冲区在内核态，可以简单理解为page cache。</p>
<p>使用了directbuffer</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-7.png"></p>
<p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p>
<p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<code>unsafe.freeMemory</code>来<strong>手动释放</strong></p>
<p>通过申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p>
<p>基于以上代码，过程如下：</p>
<p><strong>allocateDirect的实现</strong>：</p>
<p><strong>DirectByteBuffer类</strong></p>
<p>这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存</p>
<h3 id="使用-XX-DisableExplicitGC禁用显示GC"><a href="#使用-XX-DisableExplicitGC禁用显示GC" class="headerlink" title="使用-XX:+DisableExplicitGC禁用显示GC"></a>使用-XX:+DisableExplicitGC禁用显示GC</h3><p>如图</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-2.png"></p>
<p>显式的垃圾回收涉及到Full GC，会挥手新生代和老年代。</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-5.png"></p>
<ul>
<li><p>新生代（Young Generation）:新生代分为Eden Space和Survivor Space。在Eden Space中， 大多数新创建的对象首先存放在这里。Eden区相对较小，当Eden区满时，会触发一次Minor GC（新生代垃圾回收）。在Survivor Spaces中，通常分为两个相等大小的区域，称为S0（Survivor 0）和S1（Survivor 1）。在每次Minor GC后，存活下来的对象会被移动到其中一个Survivor空间，以继续它们的生命周期。这两个区域轮流充当对象的中转站，帮助区分短暂存活的对象和长期存活的对象。</p>
</li>
<li><p>老年代（Old Generation&#x2F;Tenured Generation）:存放过一次或多次Minor GC仍存活的对象会被移动到老年代。老年代中的对象生命周期较长，因此Major GC（也称为Full GC，涉及老年代的垃圾回收）发生的频率相对较低，但其执行时间通常比Minor GC长。老年代的空间通常比新生代大，以存储更多的长期存活对象。</p>
</li>
</ul>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="判断对象是否可以回收"><a href="#判断对象是否可以回收" class="headerlink" title="判断对象是否可以回收"></a>判断对象是否可以回收</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><ul>
<li><p>当一个对象被其他变量引用，该对象计数加一，当某个变量不再引用该对象，其计数减一</p>
</li>
<li><p>当一个对象引用没有被其他变量引用时，即计数变为0时，该对象就可以被回收</p>
</li>
</ul>
<p><strong>缺点</strong>：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-4.png"></p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</p>
<p>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果找不到，则表示可以回收</p>
<p>可以作为GC Root的对象</p>
<p>大致分为下图，加锁的对象有：</p>
<ul>
<li><p>系统的类对象，如hashmap这些</p>
</li>
<li><p>Native stack</p>
</li>
<li><p>活动的线程对象</p>
</li>
<li><p>加同步锁的对象</p>
</li>
</ul>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-1.png"></p>
<p>将上面来拆分，可分成这些常用的：</p>
<ul>
<li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象。</p>
</li>
<li><p>方法区中类静态属性引用的对象</p>
</li>
<li><p>方法区中常量引用的对象</p>
</li>
<li><p>本地方法栈中JNI（即一般说的Native方法）引用的对象</p>
</li>
<li><p>所有被同步锁（synchronized关键字）持有的对象。</p>
</li>
</ul>
<h3 id="java中的五种引用"><a href="#java中的五种引用" class="headerlink" title="java中的五种引用"></a>java中的五种引用</h3><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-3.png"></p>
<ol>
<li>强引用</li>
</ol>
<p>只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</p>
<ul>
<li>软引用</li>
</ul>
<p>仅有【软引用】引用该对象时，在垃圾回收后，内存仍不足时会再次出现垃圾回收，回收软引用对象</p>
<p>可以配合【引用队列】来释放软引用自身</p>
<ul>
<li>弱引用</li>
</ul>
<p>仅有【弱引用】引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</p>
<p>可以配合【引用队列】来释放弱引用自身</p>
<ul>
<li>虚引用</li>
</ul>
<p><strong>必须配合【引用队列】使用</strong>，主要配合 ByteBuffer 使用，被引用对象回收时，会将【虚引用】入队， 由 Reference Handler 线程调用虚引用相关方法释放【直接内存】</p>
<p>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</p>
<ul>
<li>终结器引用</li>
</ul>
<p>无需手动编码，但其内部配合【引用队列】使用，在垃圾回收时，【终结器引用】入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过【终结器引用】找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象</p>
<p>如上图，B对象不再引用A4对象。这时终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p>
<p>之前说ByteBuffer的时候说过他会创建一个Cleaner的虚引用对象，并将直接内存地址传递给虚引用对象。将来如果butebuffer被回收的时候，虚引用对象进入引用队列，后台的referencehandler的定时线程找是否有新入队列的这个cleaner，然后执行unsafe.freememory删除直接内存</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image.png"></p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-29.png"></p>
<h4 id="软引用实例"><a href="#软引用实例" class="headerlink" title="软引用实例"></a>软引用实例</h4><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-28.png"></p>
<p>如果我不想因为软引用被释放后，软引用队列中有null，可以使用引用队列。</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-25.png"></p>
<h4 id="弱引用实例"><a href="#弱引用实例" class="headerlink" title="弱引用实例"></a>弱引用实例</h4><p>弱引用只要没有强引用，每次垃圾回收都会尝试回收，但可能不会全部对象都被回收，而软引用是只有内存不足时并且不被强引用才会尝试回收。</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-27.png"></p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-26.png"></p>
<p><strong>这里之所以没有前面的所有都被回收是因为被放进了老年代（空间分配担保），老年代只有Full GC才会回收垃圾。</strong></p>
<p>可以看这篇文章</p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1134938">https://developer.aliyun.com/article/1134938</a></p>
<p>写到进入老年代的一种方式是：<strong>动态对象年龄判定</strong>（按照空间区计算迁移条件）</p>
<ul>
<li>虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升到老年代，<strong>如果在Survivor区中相同年龄（设年龄为age）的对象的所有大小之和超过Survivor空间的一半，年龄大于或等于该年龄（age）的对象就可以直接进入老年代</strong>，无需等到<strong>MaxTenuringThreshold中要求的年龄</strong>。</li>
</ul>
<h4 id="弱引用作缓存"><a href="#弱引用作缓存" class="headerlink" title="弱引用作缓存"></a>弱引用作缓存</h4><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="1-标记清除算法"><a href="#1-标记清除算法" class="headerlink" title="1.标记清除算法"></a>1.标记清除算法</h3><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-24.png"></p>
<p><strong>定义</strong>：在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p>
<p>注意：这里的清除并不是将内存空间字节清零，而是记录这段内存的起始地址，下次分配内存的时候，会直接覆盖这段内存。</p>
<p><strong>优点</strong>：速度快</p>
<p><strong>缺点</strong>：容易产生内存碎片。一旦分配较大内存的对象，由于内存不连续，导致无法分配，最后就会造成内存溢出问题</p>
<h3 id="2-标记整理算法"><a href="#2-标记整理算法" class="headerlink" title="2.标记整理算法"></a>2.标记整理算法</h3><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-23.png"></p>
<p><strong>定义</strong>：在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后整理剩余的对象，将可用的对象移动到一起，使内存更加紧凑，连续的空间就更多。</p>
<p><strong>优点</strong>：不会有内存碎片</p>
<p><strong>缺点</strong>：速度慢</p>
<h3 id="3-复制算法"><a href="#3-复制算法" class="headerlink" title="3.复制算法"></a>3.复制算法</h3><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-22.png"></p>
<p>定义：将内存分为等大小的两个区域，FROM和TO（TO中为空）。将被GC Root引用的对象从FROM放入TO中，<strong>再回收不被GC Root引用的对象</strong>。然后<strong>交换FROM和TO</strong>。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p>
<p>优点：不会有内存碎片</p>
<p>缺点：会占用双倍的内存空间。</p>
<h2 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h2><h3 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h3><p>将堆内存分为<strong>新生代</strong>和<strong>老年代</strong>，新生代有划分为<strong>伊甸园</strong>，<strong>幸存区To</strong>，<strong>幸存区From</strong>。</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-21.png"></p>
<p>对象首先分配在伊甸园区域</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20.png"></p>
<p>伊甸园空间不足时，触发 <strong>Minor GC</strong>，伊甸园和 from 存活的对象使用 copy 复制到<strong>幸存区To</strong> 中，存活的对象<strong>年龄加 1</strong>并且交换 from to</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-19.png"></p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-18.png"></p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-16.png"></p>
<p>再次创建对象，若新生代的伊甸园又满了，则会再次触发 Minor GC（minor gc 会引发 <strong>stop the world</strong>，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行，因为回收的时候涉及到对象的地址发生改变），这时<strong>不仅会回收伊甸园中的垃圾，还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象寿命加1</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-17.png"></p>
<p>当对象寿命超过阈值时，会晋升至老年代，最大寿命是<strong>15</strong>（4bit）</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-15.png"></p>
<p>当老年代空间不足，会先尝试触发<strong>Minor GC</strong>，如果之后空间仍不足，那么触发 <strong>Full GC</strong>，<strong>stop the world</strong>的时间更长</p>
<h3 id="相关VM参数"><a href="#相关VM参数" class="headerlink" title="相关VM参数"></a>相关VM参数</h3><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-43.png"></p>
<h3 id="GC分析——大对象"><a href="#GC分析——大对象" class="headerlink" title="GC分析——大对象"></a>GC分析——大对象</h3><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-44.png"></p>
<p>如图，大对象在老年代空间足够但是新生代空间不够的时候会直接进入老年代，而不会在超过阈值之后再进入老年代。</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-41.png"></p>
<p>如果新生代+老年代都装不下，就会oom</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-42.png"></p>
<p>如果线程内存oom发生异常，进程不会崩溃（一个线程中的oom）。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>相关概念：</p>
<p><strong>并行收集</strong>：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态</p>
<p><strong>并发收集</strong>：指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。用户程序在继续运行，而垃圾收集程序运行在另一个CPU上</p>
<p><strong>吞吐量</strong>：即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量 &#x3D; 运行用户代码时间 &#x2F; ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p>
<ol>
<li>串行</li>
</ol>
<ul>
<li><p>单线程</p>
</li>
<li><p>堆内存较小，适合个人电脑</p>
</li>
</ul>
<ul>
<li>吞吐量优先</li>
</ul>
<ul>
<li><p>多线程</p>
</li>
<li><p>堆内存较大，多核cpu</p>
</li>
<li><p>让单位时间内，STW（stop the world）的时间最短</p>
</li>
</ul>
<ul>
<li>响应时间优先</li>
</ul>
<ul>
<li><p>多线程</p>
</li>
<li><p>堆内存较大，多核cpu</p>
</li>
<li><p>尽可能让单次STW的时间最短</p>
</li>
</ul>
<h3 id="串行的垃圾回收器"><a href="#串行的垃圾回收器" class="headerlink" title="串行的垃圾回收器"></a>串行的垃圾回收器</h3><p>-XX: +UserSerialGC &#x3D; Serial + SerialOld</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-40.png"></p>
<p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象。</p>
<p><strong>阻塞</strong>：因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p>
<p><strong>Serial 收集器</strong>：</p>
<ul>
<li><p>定义：Serial收集器是最基本的、发展历史最悠久的收集器</p>
</li>
<li><p>特点：<strong>单线程</strong>收集器。采用<strong>复制</strong>算法。工作在<strong>新生代</strong></p>
</li>
</ul>
<p><strong>Serial Old收集器</strong>：</p>
<ul>
<li><p>定义：Serial Old是Serial收集器的老年代版本</p>
</li>
<li><p>特点：<strong>单线程</strong>收集器。采用<strong>标记-整理</strong>算法。工作在<strong>老年代</strong></p>
</li>
</ul>
<h3 id="吞吐量优先的垃圾回收器"><a href="#吞吐量优先的垃圾回收器" class="headerlink" title="吞吐量优先的垃圾回收器"></a>吞吐量优先的垃圾回收器</h3><ul>
<li><p>多线程</p>
</li>
<li><p>堆内存较大，多核cpu</p>
</li>
<li><p>让<strong>单位时间内</strong>暂停时间（STW）最短</p>
</li>
<li><p><strong>JDK1.8默认使用</strong>的垃圾回收器</p>
</li>
</ul>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-39.png"></p>
<p>注意jdk1.8之后第一行的垃圾回收器是默认开启的</p>
<p><strong>Parallel 收集器</strong>：</p>
<ul>
<li><p>定义：与吞吐量关系密切，故也称为吞吐量优先收集器</p>
</li>
<li><p>特点：<strong>并行的</strong>，工作于<strong>新生代</strong>，采用<strong>复制</strong>算法</p>
</li>
</ul>
<p><strong>Parallel Old 收集器</strong>：</p>
<ul>
<li><p>定义：是Parallel 收集器的老年代版本</p>
</li>
<li><p>特点：<strong>并行的</strong>，工作与<strong>老年代</strong>，采用<strong>标记-整理算法</strong></p>
</li>
</ul>
<p>GCTimeRatio的计算公式如下，ratio是除去垃圾回收的时间，如果时间不够，系统会调大堆的大小。</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-38.png"></p>
<h3 id="响应时间优先的垃圾回收器"><a href="#响应时间优先的垃圾回收器" class="headerlink" title="响应时间优先的垃圾回收器"></a>响应时间优先的垃圾回收器</h3><ul>
<li><p>多线程</p>
</li>
<li><p>堆内存较大，多核cpu</p>
</li>
<li><p>尽可能让<strong>单次的</strong>暂停时间（STW）最短</p>
</li>
</ul>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-30.png"></p>
<p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快，存在Stop The World</p>
<p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p>
<p><strong>重新标记</strong>：为了<strong>修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录</strong>。存在Stop The World</p>
<p><strong>并发清理</strong>：对标记的对象进行清除回收</p>
<p><strong>CMS收集器：</strong></p>
<p>定义：Concurrent Mark Sweep（并发，标记，清除）</p>
<p>特点：基于标记-清除算法的垃圾回收器。是并发的。工作在<strong>老年代</strong>。</p>
<p><strong>ParNew 收集器：</strong></p>
<p>定义：ParNew收集器其实就是<strong>Serial收集器的多线程版本</strong></p>
<p>特点：工作在新生代，基于复制算法的垃圾回收器。</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-31.png"></p>
<p>这个是设置当老年代中垃圾到达某一个比例时触发垃圾回收，留空间给最后的浮动垃圾。</p>
<p>CMS有一个特点就是会有内存碎片（注意他名字里的是sweep），可能导致之后的并发失败，退化到serialold进行整理。</p>
<h2 id="G1垃圾回收器"><a href="#G1垃圾回收器" class="headerlink" title="G1垃圾回收器"></a>G1垃圾回收器</h2><p><strong>定义</strong>：Garbage First</p>
<ul>
<li>JDK 9<strong>以后默认使用，而且替代了CMS 收集器</strong></li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li><p>同时注重<strong>吞吐量</strong>（Throughput）和<strong>低延迟</strong>（Low latency），<strong>默认的暂停目标是 200 ms</strong></p>
</li>
<li><p>超大堆内存，会将<strong>堆划分为多个大小相等的 Region</strong></p>
</li>
<li><p>整体上是 <strong>标记+整理</strong> 算法（和CMS不一样，不会有内存碎片），两个区域（region）之间&#x662F;<strong>&#x20;复制</strong> 算法</p>
</li>
</ul>
<p><strong>相关参数</strong>：JDK8 并不是默认开启的，所需要参数开启</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-32.png"></p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-33.png"></p>
<p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;混合收集，回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收（重新开始）</p>
<ol>
<li><strong>Young Collection：存在Stop The World</strong></li>
</ol>
<p>分区算法region：分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p>
<p>E：伊甸园 S：幸存区 O：老年代</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-37.png"></p>
<ul>
<li><strong>Young Collection + CM</strong>：</li>
</ul>
<ul>
<li><p>CM：并发标记</p>
</li>
<li><p>在 Young GC 时会<strong>对 GC Root 进行初始标记</strong></p>
</li>
<li><p>在<strong>老年代占用堆内存的比例达到阈值时</strong>，对进行并发标记（不会STW），阈值可以根据用户来进行设定</p>
</li>
</ul>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-34.png"></p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-35.png"></p>
<ul>
<li><strong>Mixed Collection</strong>：</li>
</ul>
<p>会对E S O 进行<strong>全面的回收</strong></p>
<ul>
<li><p>最终标记（Remark）会STW</p>
</li>
<li><p>拷贝存活（Evacuation）会STW</p>
</li>
<li><p><code>-XX:MaxGCPauseMills:xxx</code> ：用于<strong>指定最长的停顿时间</strong></p>
</li>
</ul>
<p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p>
<p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-36.png"></p>
<h3 id="不同垃圾回收器何时触发Full-GC："><a href="#不同垃圾回收器何时触发Full-GC：" class="headerlink" title="不同垃圾回收器何时触发Full GC："></a><strong>不同垃圾回收器何时触发Full GC：</strong></h3><p>SerialGC</p>
<p>新生代内存不足发生的垃圾收集 - minor gc</p>
<p>老年代内存不足发生的垃圾收集 - full gc</p>
<p>ParallelGC</p>
<p>新生代内存不足发生的垃圾收集 - minor gc</p>
<p>老年代内存不足发生的垃圾收集 - full gc</p>
<p>CMS</p>
<p>新生代内存不足发生的垃圾收集 - minor gc</p>
<p>老年代内存不足</p>
<p>G1</p>
<p>新生代内存不足发生的垃圾收集 - minor gc</p>
<p>老年代内存不足（老年代所占内存超过阈值）</p>
<p>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</p>
<p>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</p>
<h3 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h3><p>重新标记阶段</p>
<p>黑色：已被处理，需要保留的</p>
<p>灰色：正在处理中的</p>
<p>白色：还未处理的</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-45.png"></p>
<p>但是在并发标记过程中，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p>
<p>之前C未被引用，这时A引用了C，就会给C加一个<strong>写屏障</strong>，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 处理中 状态</p>
<p>在并发标记阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-46.png"></p>
<p><strong>JDK 8u20 字符串去重：</strong></p>
<p>优点：节省大量内存</p>
<p>缺点：略微多占用了 cpu 时间，新生代回收时间略微增加</p>
<p>例如：</p>
<p>将所有新分配的字符串（底层是char[]）放入一个队列</p>
<p>当新生代回收时，G1并发检查是否有重复的字符串</p>
<p>如果字符串的值一样，就让他们引用同一个字符串对象</p>
<p>注意，其与String.intern的区别</p>
<p>intern关注的是字符串对象</p>
<p>字符串去重关注的是char[]</p>
<p>在JVM内部，使用了不同的字符串表</p>
<p><strong>JDK 8u40 并发标记类卸载：</strong></p>
<p>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类 -XX:+ClassUnloadingWithConcurrentMark 默认启用</p>
<p><strong>JDK 8u60 回收巨型对象：</strong></p>
<p>JDK 8u60 回收巨型对象一个对象大于 region 的一半时，称之为巨型对象</p>
<p>G1 不会对巨型对象进行拷贝</p>
<p>回收时被优先考虑回收巨型对象</p>
<p>G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0的巨型对象就可以在新生代垃圾回收时处理掉</p>
<p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-47.png"></p>
<p><strong>JDK 9 并发标记起始时间的调整：</strong></p>
<p>并发标记必须在堆空间占满前完成，否则退化为 FullGC</p>
<p>JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent(默认45%)</p>
<p>JDK 9 可以<strong>动态调整</strong></p>
<p>-XX:InitiatingHeapOccupancyPercent 用来设置初始值</p>
<p>进行数据采样并动态调整</p>
<p>总会添加一个安全的空档空间</p>
<h2 id="gc调优"><a href="#gc调优" class="headerlink" title="gc调优"></a>gc调优</h2><p><strong>5-1 调优领域</strong></p>
<p>内存</p>
<p>锁竞争</p>
<p>CPU占用</p>
<p>IO</p>
<p>GC</p>
<p><strong>5-2 确定目标</strong></p>
<p>【低延迟】还是【高吞吐量】，选择合适的回收器</p>
<p>CMS，G1，ZGC （低延迟，响应时间优先）</p>
<p>ParallelGC</p>
<p>Zing</p>
<p><strong>5-3 最快的 GC</strong></p>
<p>最快的GC是不发生GC</p>
<p>查看Full GC前后的内存占用，考虑以下几个问题：</p>
<p>数据是不是太多？</p>
<p>resultSet &#x3D; statement.executeQuery(“select * from 大表”)</p>
<p>数据表示是否太臃肿？</p>
<p>对象图</p>
<p>对象大小</p>
<p>是否存在内存泄漏？</p>
<p><strong>5-4 新生代调优</strong></p>
<p>新生代的特点</p>
<p>所有的new操作分配内存都是非常廉价的</p>
<p>TLAB thread-local allocation buffer（可防止多个线程创建对象时的干扰）</p>
<p>死亡对象回收零代价</p>
<p>大部分对象用过即死（朝生夕死）</p>
<p>MInor GC 所用时间远小于Full GC</p>
<p>新生代内存越大越好么？</p>
<p>不是</p>
<p>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</p>
<p>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</p>
<p>新生代内存设置为能容&#x7EB3;<strong>[并发量*(请求-响应)]</strong>&#x7684;数据为宜</p>
<p>幸存区大到能保留【当前活跃对象+需要晋升对象】</p>
<p>晋升阈值配置得当，让长时间存活对象尽快晋升</p>
<p><strong>5-5 老年代调优</strong></p>
<p>以 CMS 为例 ：</p>
<p>CMS 的老年代内存越大越好</p>
<p>先尝试不做调优，如果没有 Full GC 那么已经…，否则先尝试调优新生代</p>
<p>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1&#x2F;4 ~ 1&#x2F;3</p>
<p>-XX:CMSInitiatingOccupancyFraction&#x3D;percent</p>
<h1 id="字节码与类加载"><a href="#字节码与类加载" class="headerlink" title="字节码与类加载"></a>字节码与类加载</h1><p>当你执行代码：</p>
<p>并使用 <code>javap</code> 反编译查看它的字节码时，你会看到类似下面的内容。为了说明，我们先假设类名是 <code>Demo3</code>。</p>
<h2 id="A-new-String-“kkk”-在方法区和运行时常量池如何存储？"><a href="#A-new-String-“kkk”-在方法区和运行时常量池如何存储？" class="headerlink" title="A &#x3D; new String(“kkk”)在方法区和运行时常量池如何存储？"></a>A &#x3D; new String(“kkk”)在方法区和运行时常量池如何存储？</h2><p>解释</p>
<p>1. <strong><code>ldc</code> 指令</strong></p>
<ul>
<li><p><code>ldc #2</code> 表示将字符串常量 <code>&quot;kkk&quot;</code> 推送到操作数栈中。这里的常量 <code>&quot;kkk&quot;</code> 是一个常量池中的字符串，在编译时已经确定，因此会存储在类的常量池中。</p>
</li>
<li><p><code>#2</code> 是常量池的索引，指向 <code>&quot;kkk&quot;</code> 字符串常量。</p>
</li>
</ul>
<p>2. <strong><code>new</code></strong> 和 <strong><code>invokespecial</code></strong></p>
<ul>
<li><p><code>new #3</code>：这行代码表示要创建一个新的 <code>String</code> 对象，<code>#3</code> 是常量池中 <code>String</code> 类的索引，表示创建 <code>String</code> 对象。</p>
</li>
<li><p><code>dup</code>：这条指令是复制栈顶的对象引用。它用于确保在创建对象时，我们能够继续使用这个对象引用进行初始化。</p>
</li>
<li><p><code>aload_1</code>：从局部变量表加载变量 <code>a</code>（即 <code>kkk</code> 字符串）到操作数栈。</p>
</li>
<li><p><code>invokespecial #4</code>：调用 <code>String</code> 类的构造方法 <code>String(String)</code>，将之前从栈上加载的字符串传递给构造方法。这个方法会创建一个新的 <code>String</code> 对象。</p>
</li>
</ul>
<p>3. <strong><code>astore_2</code></strong></p>
<ul>
<li>最终，使用 <code>astore_2</code> 把创建出来的新 <code>String</code> 对象保存到变量 <code>a</code> 中。</li>
</ul>
<p>常见的关键点：</p>
<ul>
<li><p><code>&quot;kkk&quot;</code> 字符串常量首先会通过 <code>ldc</code> 指令加载到操作数栈中，它是一个常量池中的常量。</p>
</li>
<li><p><code>new String(&quot;kkk&quot;)</code> 创建了一个新的 <code>String</code> 对象，调用了 <code>String</code> 的构造函数。</p>
</li>
<li><p>这个过程中，字符串 <code>&quot;kkk&quot;</code> 是常量池中的一个对象，但通过 <code>new</code> 创建的 <code>String</code> 对象是堆上的一个新对象。</p>
</li>
</ul>
<p>总结</p>
<p>在 <code>javap</code> 反编译的字节码中，你会看到：</p>
<ul>
<li><p>字符串 <code>&quot;kkk&quot;</code> 被加载到栈上（通过 <code>ldc</code>）。</p>
</li>
<li><p>通过 <code>new String(&quot;kkk&quot;)</code> 创建了一个新的 <code>String</code> 对象。</p>
</li>
<li><p><code>new String(&quot;kkk&quot;)</code> 实际上是在堆内存中创建了一个新的 <code>String</code> 对象，而 <code>&quot;kkk&quot;</code> 字符串本身是常量池中的一个字符串。</p>
</li>
</ul>
<h2 id="invokevirtual为什么实现的是多态调用？"><a href="#invokevirtual为什么实现的是多态调用？" class="headerlink" title="invokevirtual为什么实现的是多态调用？"></a>invokevirtual为什么实现的是多态调用？</h2><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-48.png"></p>
<p>invokevirtual作用的是类中的public方法，在编译的时候不知道他要继承的是父类还是子类（这是要通过字节码调用构造函数之后才知道的），所以是动态绑定。</p>
<p>不同方法在调用时，对应的虚拟机指令有所区别：</p>
<ul>
<li><p>私有、构造、被final修饰的方法，在调用时都使用invokespecial指令，属于静态绑定</p>
</li>
<li><p>普通成员方法在调用时，使用invokevirtual指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定，属于动态绑定，即支持多态</p>
</li>
<li><p>静态方法在调用时使用invokestatic指令</p>
</li>
</ul>
<h2 id="多态的原理"><a href="#多态的原理" class="headerlink" title="多态的原理"></a>多态的原理</h2><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用invokevirtual指令</p>
<p>在执行invokevirtual指令时，经历了以下几个步骤</p>
<ul>
<li><p>先通过栈帧中对象的引用找到对象</p>
</li>
<li><p>分析对象头，找到对象实际的Class</p>
</li>
<li><p>Class结构中有vtable，它在类加载的链接阶段就已经根据方法的重写规则生成好了</p>
</li>
<li><p>查询vtable找到方法的具体地址</p>
</li>
<li><p>执行方法的字节码</p>
</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="Try-catch"><a href="#Try-catch" class="headerlink" title="Try-catch"></a>Try-catch</h3><p>对应的字节码文件（为了抓住重点，下面的字节码省略了局部变量表等一些不重要的部分）：</p>
<ul>
<li><p>可以看到多出来一个 Exception table 的结构，[from, to) 是前闭后开（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</p>
</li>
<li><p>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</p>
</li>
</ul>
<h3 id="多个single-catch"><a href="#多个single-catch" class="headerlink" title="多个single-catch"></a>多个single-catch</h3><ul>
<li>因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong></li>
</ul>
<h3 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h3><p>可以看到 finally 中的代码被复制了 3 份，分别放入 try 流程，catch 流程以及 catch 剩余的异常类型流程</p>
<blockquote>
<p>注意：</p>
<p>虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码<strong>只会被执行一次</strong></p>
</blockquote>
<h3 id="finally中的return"><a href="#finally中的return" class="headerlink" title="finally中的return"></a>finally中的return</h3><ul>
<li><p>由于 finally 中的 ireturn 被插入了所有可能的流程，因此返回结果肯定以 finally 的为准</p>
</li>
<li><p>跟前一个中的 finally 相比，发现没有 athrow 了，这告诉我们：如果在 finally 中出现了 return，会吞掉异常</p>
</li>
</ul>
<p>运行下面的代码，不会抛出异常：</p>
<h3 id="finally不带return"><a href="#finally不带return" class="headerlink" title="finally不带return"></a>finally不带return</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://bshtj.github.io">bshtj</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://bshtj.github.io/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">https://bshtj.github.io/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://bshtj.github.io" target="_blank">bshtj_blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post-share"><div class="social-share" data-image="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-12.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/02/13/JUC-%E6%97%A0%E9%94%81/" title="JUC_无锁"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">JUC_无锁</div></div><div class="info-2"><div class="info-item-1">无锁CAS原理无锁编程：Lock Free CAS 的全称是 Compare-And-Swap，是 CPU 并发原语  CAS 并发原语体现在 Java 语言中就是 sun.misc.Unsafe 类的各个方法，调用 UnSafe 类中的 CAS 方法，JVM 会实现出 CAS 汇编指令，这是一种完全依赖于硬件的功能，实现了原子操作 CAS 是一种系统原语，原语属于操作系统范畴，是由若干条指令组成 ，用于完成某个功能的一个过程，并且原语的执行必须是连续的，执行过程中不允许被中断，所以 CAS 是一条 CPU 的原子指令，不会造成数据不一致的问题，是线程安全的  底层原理：CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核和多核 CPU 下都能够保证比较交换的原子性  程序是在单核处理器上运行，会省略 lock 前缀，单处理器自身会维护处理器内的顺序一致性，不需要 lock 前缀的内存屏障效果 程序是在多核处理器上运行，会为 cmpxchg 指令加上 lock 前缀。当某个核执行到带 lock 的指令时，CPU...</div></div></div></a><a class="pagination-related" href="/2025/02/14/JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="JUC_线程池"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">JUC_线程池</div></div><div class="info-2"><div class="info-item-1">线程池基本概述线程池：一个容纳多个线程的容器，容器中的线程可以重复使用，省去了频繁创建和销毁线程对象的操作 线程池作用：  降低资源消耗，减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务 提高响应速度，当任务到达时，如果有线程可以直接用，不会出现系统僵死 提高线程的可管理性，如果无限制的创建线程，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控  线程池的核心思想：线程复用，同一个线程可以被重复使用，来处理多个任务 池化技术 (Pool)...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/06/03/Comparator%E6%8E%A5%E5%8F%A3%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/" title="Comparator接口与装饰器模式的链式调用"><img class="cover" src="/2025/06/03/Comparator%E6%8E%A5%E5%8F%A3%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/home.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-03</div><div class="info-item-2">Comparator接口与装饰器模式的链式调用</div></div><div class="info-2"><div class="info-item-1">Java Comparator 接口方法详解Comparator 是 Java 中用于定义对象比较规则的接口，位于 java.util 包中。以下是 Comparator 接口中的所有方法及其说明： 1. 核心比较方法int compare(T o1, T o2) 功能：比较两个对象 参数：o1 - 第一个对象，o2 - 第二个对象 返回： 负整数：o1 &lt; o2 零：o1 &#x3D;&#x3D; o2 正整数：o1 &gt; o2    1Comparator&lt;String&gt; lengthComparator = (s1, s2) -&gt; s1.length() - s2.length();  2. 默认方法（Java 8+）Comparator&lt;T&gt; reversed() 功能：返回一个逆序比较器 示例：  12Comparator&lt;Integer&gt; natural = Integer::compare;Comparator&lt;Integer&gt; reversed =...</div></div></div></a><a class="pagination-related" href="/2025/02/07/JUC-%E5%86%85%E5%AD%98/" title="JUC_内存"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-07</div><div class="info-item-2">JUC_内存</div></div><div class="info-2"><div class="info-item-1">内存JMM内存模型Java 内存模型是 Java Memory Model（JMM），本身是一种抽象的概念，实际上并不存在，描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式 JMM 作用：  屏蔽各种硬件和操作系统的内存访问差异，实现让 Java 程序在各种平台下都能达到一致的内存访问效果 规定了线程和内存之间的一些关系  根据 JMM 的设计，系统存在一个主内存（Main Memory），Java 中所有变量都存储在主存中，对于所有线程都是共享的；每条线程都有自己的工作内存（Working Memory），工作内存中保存的是主存中某些变量的拷贝，线程对所有变量的操作都是先对变量进行拷贝，然后在工作内存中进行，不能直接操作主内存中的变量；线程之间无法相互直接访问，线程间的通信（传递）必须通过主内存来完成  主内存和工作内存：  主内存：计算机的内存，也就是经常提到的 8G 内存，16G 内存，存储所有共享变量的值 工作内存：存储该线程使用到的共享变量在主内存的的值的副本拷贝  JVM 和 JMM 之间的关系：JMM...</div></div></div></a><a class="pagination-related" href="/2025/02/05/JUC-%E5%90%8C%E6%AD%A5/" title="JUC_同步"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-05</div><div class="info-item-2">JUC_同步</div></div><div class="info-2"><div class="info-item-1">同步临界区临界资源：一次仅允许一个进程使用的资源成为临界资源 临界区：访问临界资源的代码块 竞态条件：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件 一个程序运行多个线程是没有问题，多个线程读共享资源也没有问题，在多个线程对共享资源读写操作时发生指令交错，就会出现问题 为了避免临界区的竞态条件发生（解决线程安全问题）：  阻塞式的解决方案：synchronized，lock 非阻塞式的解决方案：原子变量  管程（monitor）：由局部于自己的若干公共变量和所有访问这些公共变量的过程所组成的软件模块，保证同一时刻只有一个进程在管程内活动，即管程内定义的操作在同一时刻只被一个进程调用（由编译器实现） synchronized：对象锁，保证了临界区内代码的原子性，采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其它线程获取这个对象锁时会阻塞，保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换 互斥和同步都可以采用 synchronized...</div></div></div></a><a class="pagination-related" href="/2025/02/13/JUC-%E6%97%A0%E9%94%81/" title="JUC_无锁"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-13</div><div class="info-item-2">JUC_无锁</div></div><div class="info-2"><div class="info-item-1">无锁CAS原理无锁编程：Lock Free CAS 的全称是 Compare-And-Swap，是 CPU 并发原语  CAS 并发原语体现在 Java 语言中就是 sun.misc.Unsafe 类的各个方法，调用 UnSafe 类中的 CAS 方法，JVM 会实现出 CAS 汇编指令，这是一种完全依赖于硬件的功能，实现了原子操作 CAS 是一种系统原语，原语属于操作系统范畴，是由若干条指令组成 ，用于完成某个功能的一个过程，并且原语的执行必须是连续的，执行过程中不允许被中断，所以 CAS 是一条 CPU 的原子指令，不会造成数据不一致的问题，是线程安全的  底层原理：CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核和多核 CPU 下都能够保证比较交换的原子性  程序是在单核处理器上运行，会省略 lock 前缀，单处理器自身会维护处理器内的顺序一致性，不需要 lock 前缀的内存屏障效果 程序是在多核处理器上运行，会为 cmpxchg 指令加上 lock 前缀。当某个核执行到带 lock 的指令时，CPU...</div></div></div></a><a class="pagination-related" href="/2025/04/28/bitset%E4%BD%BF%E7%94%A8/" title="1.3 计算机的性能指标"><img class="cover" src="/2025/04/28/bitset%E4%BD%BF%E7%94%A8/home.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-28</div><div class="info-item-2">1.3 计算机的性能指标</div></div><div class="info-2"><div class="info-item-1">bitset方法代码参考：https://www.runoob.com/java/java-bitset-class.html 12345678910111213141516171819202122232425262728293031323334import java.util.BitSet; public class BitSetDemo &#123;   public static void main(String args[]) &#123;     BitSet bits1 = new BitSet(16);     BitSet bits2 = new BitSet(16);           // set some bits     for(int i=0; i&lt;16; i++) &#123;        if((i%2) == 0) bits1.set(i);        if((i%5) != 0) bits2.set(i);     &#125;     System.out.println(&quot;Initial pattern in...</div></div></div></a><a class="pagination-related" href="/2025/02/14/JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="JUC_线程池"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-14</div><div class="info-item-2">JUC_线程池</div></div><div class="info-2"><div class="info-item-1">线程池基本概述线程池：一个容纳多个线程的容器，容器中的线程可以重复使用，省去了频繁创建和销毁线程对象的操作 线程池作用：  降低资源消耗，减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务 提高响应速度，当任务到达时，如果有线程可以直接用，不会出现系统僵死 提高线程的可管理性，如果无限制的创建线程，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控  线程池的核心思想：线程复用，同一个线程可以被重复使用，来处理多个任务 池化技术 (Pool)...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/wuliannan.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">bshtj</div><div class="author-info-description">学术辣鸡，不定时更新</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8PC-Register"><span class="toc-number">1.1.</span> <span class="toc-text">程序计数器PC Register</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.2.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E6%98%AF%E5%90%A6%E4%BC%9A%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">分析以下代码是否会是线程安全的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">1.2.3.</span> <span class="toc-text">栈内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%AF%8A%E6%96%AD"><span class="toc-number">1.2.4.</span> <span class="toc-text">线程运行诊断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">1.2.5.</span> <span class="toc-text">本地方法栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">1.3.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.3.2.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">1.4.</span> <span class="toc-text">方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">方法区内存溢出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">1.5.</span> <span class="toc-text">直接内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-number">1.5.1.</span> <span class="toc-text">定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">分配和回收原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-XX-DisableExplicitGC%E7%A6%81%E7%94%A8%E6%98%BE%E7%A4%BAGC"><span class="toc-number">1.5.2.</span> <span class="toc-text">使用-XX:+DisableExplicitGC禁用显示GC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">2.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6"><span class="toc-number">2.1.</span> <span class="toc-text">判断对象是否可以回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">可达性分析算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%E7%9A%84%E4%BA%94%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="toc-number">2.1.3.</span> <span class="toc-text">java中的五种引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">软引用实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">弱引用实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%E4%BD%9C%E7%BC%93%E5%AD%98"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">弱引用作缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.标记清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.标记整理算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.3.</span> <span class="toc-text">3.复制算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">2.3.</span> <span class="toc-text">分代垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">回收流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3VM%E5%8F%82%E6%95%B0"><span class="toc-number">2.3.2.</span> <span class="toc-text">相关VM参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%A4%A7%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.3.</span> <span class="toc-text">GC分析——大对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">2.4.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">2.4.1.</span> <span class="toc-text">串行的垃圾回收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">2.4.2.</span> <span class="toc-text">吞吐量优先的垃圾回收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">2.4.3.</span> <span class="toc-text">响应时间优先的垃圾回收器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">2.5.</span> <span class="toc-text">G1垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%BD%95%E6%97%B6%E8%A7%A6%E5%8F%91Full-GC%EF%BC%9A"><span class="toc-number">2.5.1.</span> <span class="toc-text">不同垃圾回收器何时触发Full GC：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Remark"><span class="toc-number">2.5.2.</span> <span class="toc-text">Remark</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gc%E8%B0%83%E4%BC%98"><span class="toc-number">2.6.</span> <span class="toc-text">gc调优</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.</span> <span class="toc-text">字节码与类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-new-String-%E2%80%9Ckkk%E2%80%9D-%E5%9C%A8%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">A &#x3D; new String(“kkk”)在方法区和运行时常量池如何存储？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#invokevirtual%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%98%AF%E5%A4%9A%E6%80%81%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">invokevirtual为什么实现的是多态调用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">多态的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">3.4.</span> <span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Try-catch"><span class="toc-number">3.4.1.</span> <span class="toc-text">Try-catch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AAsingle-catch"><span class="toc-number">3.4.2.</span> <span class="toc-text">多个single-catch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Finally"><span class="toc-number">3.4.3.</span> <span class="toc-text">Finally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finally%E4%B8%AD%E7%9A%84return"><span class="toc-number">3.4.4.</span> <span class="toc-text">finally中的return</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finally%E4%B8%8D%E5%B8%A6return"><span class="toc-number">3.4.5.</span> <span class="toc-text">finally不带return</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/03/Comparator%E6%8E%A5%E5%8F%A3%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/" title="Comparator接口与装饰器模式的链式调用"><img src="/2025/06/03/Comparator%E6%8E%A5%E5%8F%A3%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/home.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Comparator接口与装饰器模式的链式调用"/></a><div class="content"><a class="title" href="/2025/06/03/Comparator%E6%8E%A5%E5%8F%A3%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/" title="Comparator接口与装饰器模式的链式调用">Comparator接口与装饰器模式的链式调用</a><time datetime="2025-06-03T06:26:18.000Z" title="发表于 2025-06-03 14:26:18">2025-06-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/13/%E4%B8%8D%E5%90%8C%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" title="不同形式的二分查找"><img src="/2025/05/13/%E4%B8%8D%E5%90%8C%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/home.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="不同形式的二分查找"/></a><div class="content"><a class="title" href="/2025/05/13/%E4%B8%8D%E5%90%8C%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" title="不同形式的二分查找">不同形式的二分查找</a><time datetime="2025-05-13T02:13:03.000Z" title="发表于 2025-05-13 10:13:03">2025-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/08/%E4%BB%8E%E8%95%BE%E7%BC%AA%E5%AE%89%E7%9A%84%E6%8A%80%E8%83%BD%E5%85%A5%E6%89%8B%E8%AE%BE%E6%83%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="从蕾缪安的技能入手设想设计模式"><img src="/2025/05/08/%E4%BB%8E%E8%95%BE%E7%BC%AA%E5%AE%89%E7%9A%84%E6%8A%80%E8%83%BD%E5%85%A5%E6%89%8B%E8%AE%BE%E6%83%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/home.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从蕾缪安的技能入手设想设计模式"/></a><div class="content"><a class="title" href="/2025/05/08/%E4%BB%8E%E8%95%BE%E7%BC%AA%E5%AE%89%E7%9A%84%E6%8A%80%E8%83%BD%E5%85%A5%E6%89%8B%E8%AE%BE%E6%83%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="从蕾缪安的技能入手设想设计模式">从蕾缪安的技能入手设想设计模式</a><time datetime="2025-05-08T15:48:03.000Z" title="发表于 2025-05-08 23:48:03">2025-05-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/28/bitset%E4%BD%BF%E7%94%A8/" title="1.3 计算机的性能指标"><img src="/2025/04/28/bitset%E4%BD%BF%E7%94%A8/home.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="1.3 计算机的性能指标"/></a><div class="content"><a class="title" href="/2025/04/28/bitset%E4%BD%BF%E7%94%A8/" title="1.3 计算机的性能指标">1.3 计算机的性能指标</a><time datetime="2025-04-28T12:08:48.000Z" title="发表于 2025-04-28 20:08:48">2025-04-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/27/%E6%89%8B%E5%86%99%E5%A4%A7%E5%B0%8F%E6%A0%B9%E5%A0%86/" title="手写大小根堆"><img src="/2025/04/27/%E6%89%8B%E5%86%99%E5%A4%A7%E5%B0%8F%E6%A0%B9%E5%A0%86/home.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="手写大小根堆"/></a><div class="content"><a class="title" href="/2025/04/27/%E6%89%8B%E5%86%99%E5%A4%A7%E5%B0%8F%E6%A0%B9%E5%A0%86/" title="手写大小根堆">手写大小根堆</a><time datetime="2025-04-27T07:43:56.000Z" title="发表于 2025-04-27 15:43:56">2025-04-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By bshtj</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>