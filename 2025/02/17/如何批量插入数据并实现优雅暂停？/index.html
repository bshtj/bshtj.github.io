<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>如何批量插入数据并实现优雅暂停？ | bshtj_blog</title><meta name="author" content="bshtj"><meta name="copyright" content="bshtj"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="如何批量插入数据并实现优雅暂停？要实现“当前批量插入循环插入完毕之后终止，不再执行之后的循环”，同时确保线程池状态变为 SHUTDOWN 后不再接收新任务，但已提交的任务会执行完毕，可以通过以下步骤实现： 1. 配置线程池配置一个线程池，并确保它支持优雅关闭。 1234567891011121314151617181920import org.springframework.context.ann">
<meta property="og:type" content="article">
<meta property="og:title" content="如何批量插入数据并实现优雅暂停？">
<meta property="og:url" content="https://bshtj.github.io/2025/02/17/%E5%A6%82%E4%BD%95%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%BC%98%E9%9B%85%E6%9A%82%E5%81%9C%EF%BC%9F/index.html">
<meta property="og:site_name" content="bshtj_blog">
<meta property="og:description" content="如何批量插入数据并实现优雅暂停？要实现“当前批量插入循环插入完毕之后终止，不再执行之后的循环”，同时确保线程池状态变为 SHUTDOWN 后不再接收新任务，但已提交的任务会执行完毕，可以通过以下步骤实现： 1. 配置线程池配置一个线程池，并确保它支持优雅关闭。 1234567891011121314151617181920import org.springframework.context.ann">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bshtj.github.io/img/wuliannan.png">
<meta property="article:published_time" content="2025-02-17T11:32:33.000Z">
<meta property="article:modified_time" content="2025-02-23T12:53:33.626Z">
<meta property="article:author" content="bshtj">
<meta property="article:tag" content="java">
<meta property="article:tag" content="突发奇想的问题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bshtj.github.io/img/wuliannan.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "如何批量插入数据并实现优雅暂停？",
  "url": "https://bshtj.github.io/2025/02/17/%E5%A6%82%E4%BD%95%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%BC%98%E9%9B%85%E6%9A%82%E5%81%9C%EF%BC%9F/",
  "image": "https://bshtj.github.io/img/wuliannan.png",
  "datePublished": "2025-02-17T11:32:33.000Z",
  "dateModified": "2025-02-23T12:53:33.626Z",
  "author": [
    {
      "@type": "Person",
      "name": "bshtj",
      "url": "https://bshtj.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/wuliannan.png"><link rel="canonical" href="https://bshtj.github.io/2025/02/17/%E5%A6%82%E4%BD%95%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%BC%98%E9%9B%85%E6%9A%82%E5%81%9C%EF%BC%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"Z9MP5121BD","apiKey":"10b5fa00d61ba271dd1619df1cc5263e","indexName":"butterfly","hitsPerPage":6,"languages":{"input_placeholder":"Search...","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '如何批量插入数据并实现优雅暂停？',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/wuliannan.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/bg.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">bshtj_blog</span></a><a class="nav-page-title" href="/"><span class="site-name">如何批量插入数据并实现优雅暂停？</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">如何批量插入数据并实现优雅暂停？</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-17T11:32:33.000Z" title="发表于 2025-02-17 19:32:33">2025-02-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-23T12:53:33.626Z" title="更新于 2025-02-23 20:53:33">2025-02-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%96%91%E6%83%91/">疑惑</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="如何批量插入数据并实现优雅暂停？"><a href="#如何批量插入数据并实现优雅暂停？" class="headerlink" title="如何批量插入数据并实现优雅暂停？"></a>如何批量插入数据并实现优雅暂停？</h2><p>要实现“当前批量插入循环插入完毕之后终止，不再执行之后的循环”，同时确保线程池状态变为 <code>SHUTDOWN</code> 后不再接收新任务，但已提交的任务会执行完毕，可以通过以下步骤实现：</p>
<h3 id="1-配置线程池"><a href="#1-配置线程池" class="headerlink" title="1. 配置线程池"></a>1. 配置线程池</h3><p>配置一个线程池，并确保它支持优雅关闭。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;batchInsertThreadPool&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">batchInsertThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>); <span class="comment">// 核心线程数</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">20</span>);  <span class="comment">// 最大线程数</span></span><br><span class="line">        executor.setQueueCapacity(<span class="number">100</span>); <span class="comment">// 队列容量</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;BatchInsertThread-&quot;</span>); <span class="comment">// 线程名前缀</span></span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="literal">true</span>); <span class="comment">// 关闭时等待任务完成</span></span><br><span class="line">        executor.setAwaitTerminationSeconds(<span class="number">60</span>); <span class="comment">// 等待任务完成的最大时间</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-实现批量插入逻辑"><a href="#2-实现批量插入逻辑" class="headerlink" title="2. 实现批量插入逻辑"></a>2. 实现批量插入逻辑</h3><p>编写批量插入的逻辑，并在插入完成后检查线程池状态，决定是否继续插入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchInsertService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor batchInsertThreadPool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量插入数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchInsert</span><span class="params">(List&lt;Data&gt; dataList)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO your_table (column1, column2) VALUES (?, ?)&quot;</span>;</span><br><span class="line">        jdbcTemplate.batchUpdate(sql, dataList, dataList.size(), (ps, data) -&gt; &#123;</span><br><span class="line">            ps.setString(<span class="number">1</span>, data.getColumn1());</span><br><span class="line">            ps.setString(<span class="number">2</span>, data.getColumn2());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查线程池是否已关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isThreadPoolShutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> batchInsertThreadPool.getThreadPoolExecutor().isShutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-控制批量插入循环"><a href="#3-控制批量插入循环" class="headerlink" title="3. 控制批量插入循环"></a>3. 控制批量插入循环</h3><p>在批量插入的循环中，每次插入后检查线程池状态。如果线程池已关闭，则退出循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BatchInsertService batchInsertService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor batchInsertThreadPool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量插入数据循环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchInsertLoop</span><span class="params">(List&lt;List&lt;Data&gt;&gt; dataBatches)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Data&gt; batch : dataBatches) &#123;</span><br><span class="line">            <span class="comment">// 检查线程池是否已关闭</span></span><br><span class="line">            <span class="keyword">if</span> (batchInsertThreadPool.getThreadPoolExecutor().isShutdown()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程池已关闭，停止插入任务。&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 提交批量插入任务</span></span><br><span class="line">            batchInsertThreadPool.execute(() -&gt; &#123;</span><br><span class="line">                batchInsertService.batchInsert(batch);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-实现优雅关闭"><a href="#4-实现优雅关闭" class="headerlink" title="4. 实现优雅关闭"></a>4. 实现优雅关闭</h3><p>编写一个方法，用于关闭线程池并等待任务完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolShutdownService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor batchInsertThreadPool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优雅关闭线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdownThreadPoolGracefully</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一阶段：停止接受新任务</span></span><br><span class="line">        batchInsertThreadPool.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二阶段：等待已提交的任务完成</span></span><br><span class="line">        <span class="keyword">while</span> (!batchInsertThreadPool.getThreadPoolExecutor().isTerminated()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 每隔100ms检查一次</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;线程池已优雅关闭，所有任务已完成。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-触发优雅关闭"><a href="#5-触发优雅关闭" class="headerlink" title="5. 触发优雅关闭"></a>5. 触发优雅关闭</h3><p>通过REST接口或其他方式触发线程池的优雅关闭。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/thread-pool&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolShutdownService threadPoolShutdownService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/shutdown&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">shutdownThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        threadPoolShutdownService.shutdownThreadPoolGracefully();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池正在优雅关闭...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-测试与验证"><a href="#6-测试与验证" class="headerlink" title="6. 测试与验证"></a>6. 测试与验证</h3><p>启动Spring应用，调用批量插入接口和关闭接口，观察线程池的行为。</p>
<ul>
<li><strong>批量插入接口</strong>：提交多个批量插入任务。</li>
<li><strong>关闭接口</strong>：调用关闭接口后，线程池会停止接受新任务，但会等待已提交的任务完成。</li>
</ul>
<h3 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h3><ol>
<li><strong>线程池状态检查</strong>：在批量插入循环中，每次插入后检查线程池状态（<code>isShutdown()</code>），如果线程池已关闭，则退出循环。</li>
<li><strong>优雅关闭</strong>：通过<code>shutdown()</code>方法停止接受新任务，并通过<code>isTerminated()</code>等待任务完成。</li>
<li><strong>Spring继续运行</strong>：线程池关闭后，Spring应用的其他部分仍然可以正常运行。</li>
</ol>
<h2 id="spring和servlet之间有从属关系吗？"><a href="#spring和servlet之间有从属关系吗？" class="headerlink" title="spring和servlet之间有从属关系吗？"></a>spring和servlet之间有从属关系吗？</h2><p>你的问题涉及 <strong>Spring 容器</strong>、<strong>Tomcat线程池</strong>以及 <strong>Spring 管理的 <code>ThreadPoolTaskExecutor</code></strong> 之间的关系。我们一步步解析它们的 <strong>从属结构</strong> 和 <strong>线程生命周期</strong>。</p>
<h3 id="1-Spring-和-Tomcat-线程池的关系"><a href="#1-Spring-和-Tomcat-线程池的关系" class="headerlink" title="1. Spring 和 Tomcat 线程池的关系"></a><strong>1. Spring 和</strong> <strong>Tomcat</strong> <strong>线程池</strong>的关系</h3><p>Spring Web 应用 <strong>运行在</strong> <strong>Tomcat</strong> <strong>之上</strong>，但它和 Tomcat 的线程管理是 <strong>两个独立的体系</strong>。</p>
<h4 id="1-1-Tomcat-线程池"><a href="#1-1-Tomcat-线程池" class="headerlink" title="1.1 Tomcat 线程池"></a><strong>1.1</strong> <strong>Tomcat</strong> <strong>线程池</strong></h4><ul>
<li><strong>Tomcat</strong> <strong>是 HTTP 服务器</strong>，它负责接收请求并分配线程来处理。</li>
<li>Tomcat 的 <strong>线程池</strong>（通常是 <code>org.apache.tomcat.util.threads.ThreadPoolExecutor</code>）维护着 <code>http-nio-8080-exec-</code> 线程，它们 <strong>执行</strong> <strong>Spring MVC</strong> <strong>Controller</strong> <strong>方法</strong>。</li>
<li><strong>生命周期</strong>：Tomcat 线程池在 <strong>Tomcat 启动时创建</strong>，在 <strong>Tomcat 关闭时销毁</strong>。</li>
</ul>
<h4 id="1-2-Spring-容器和-Bean"><a href="#1-2-Spring-容器和-Bean" class="headerlink" title="1.2 Spring 容器和 Bean"></a><strong>1.2 Spring 容器和 Bean</strong></h4><ul>
<li>Spring 在 Tomcat 启动时 <strong>加载自己的容器</strong>（<code>ApplicationContext</code>），实例化所有 <strong>单例</strong> <strong>Bean</strong>，包括 <code>ThreadPoolTaskExecutor</code>。</li>
<li>这些 <strong>Spring Bean 在整个应用中共享</strong>，它们不依赖单个 HTTP 请求，而是<strong>全局管理</strong>的。</li>
</ul>
<h4 id="1-3-ThreadPoolTaskExecutor-线程池"><a href="#1-3-ThreadPoolTaskExecutor-线程池" class="headerlink" title="1.3 ThreadPoolTaskExecutor 线程池"></a><strong>1.3</strong> <strong><code>ThreadPoolTaskExecutor</code></strong> <strong>线程池</strong></h4><ul>
<li><strong><code>ThreadPoolTaskExecutor</code></strong> <strong>是 Spring 维护的****线程池</strong>，它独立于 Tomcat 线程池。</li>
<li>这个线程池的 <strong>生命周期由 Spring 容器管理</strong>，在 Spring 启动时创建，在 Spring 关闭时销毁。</li>
<li>当 <code>Controller</code> 里提交任务到 <code>ThreadPoolTaskExecutor</code>，这个任务会在 <strong>Spring</strong> <strong>线程池</strong> 里执行，而不是在 Tomcat 线程池里。</li>
</ul>
<h3 id="2-为什么-ThreadPoolTaskExecutor-可以脱离-Tomcat-线程？"><a href="#2-为什么-ThreadPoolTaskExecutor-可以脱离-Tomcat-线程？" class="headerlink" title="2. 为什么 ThreadPoolTaskExecutor 可以脱离 Tomcat 线程？"></a><strong>2. 为什么</strong> <strong><code>ThreadPoolTaskExecutor</code></strong> <strong>可以脱离</strong> <strong>Tomcat</strong> <strong>线程？</strong></h3><p>你提到：</p>
<blockquote>
<p><strong>在一个线程中</strong> **<code>new ThreadA()</code><strong>，再在另一个线程</strong><code>new ThreadB()</code>**，它们应该是相互隔离的，为什么 <strong><code>ThreadPoolTaskExecutor</code></strong> <strong>不是这样？</strong></p>
</blockquote>
<p>答案是：</p>
<ul>
<li><strong>Spring</strong> <strong>线程池</strong>是 <strong>“全局”</strong> <strong>的</strong>，它不属于单个 Tomcat 线程，而是由 <strong>Spring 容器管理</strong>，所有 Tomcat 线程都可以访问它。</li>
<li><strong>Tomcat</strong> <strong>线程只是 “请求处理线程”，并不掌控</strong> **<code>ThreadPoolTaskExecutor</code>**。</li>
<li><strong>当</strong> <strong>Tomcat</strong> <strong>线程调用</strong> <strong><code>batchInsertThreadPool.execute()</code><strong>，它只是把任务提交给</strong>线程池</strong>，然后它自己会立即返回，而 <code>ThreadPoolTaskExecutor</code> 负责在自己的线程中执行任务。</li>
</ul>
<h3 id="3-从属关系（Spring-vs-Tomcat-vs-线程池）"><a href="#3-从属关系（Spring-vs-Tomcat-vs-线程池）" class="headerlink" title="3. 从属关系（Spring vs. Tomcat vs. 线程池）"></a><strong>3. 从属关系（Spring vs.</strong> <strong>Tomcat</strong> <strong>vs.</strong> <strong>线程池</strong>）</h3><p>可以用下图表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Tomcat 服务器（管理 HTTP 线程池）</span><br><span class="line">│</span><br><span class="line">├── Tomcat 线程池（http-nio-8080-exec-1, 2, 3, ...）</span><br><span class="line">│   ├── 处理 HTTP 请求（调用 Spring Controller）</span><br><span class="line">│   ├── 在 Controller 里提交任务给 Spring 线程池</span><br><span class="line">│</span><br><span class="line">└── Spring 容器（ApplicationContext）</span><br><span class="line">    ├── 管理 Spring Bean（包括 ThreadPoolTaskExecutor）</span><br><span class="line">    ├── 管理业务逻辑（Service、Repository）</span><br><span class="line">    ├── 启动 ThreadPoolTaskExecutor（独立于 Tomcat）</span><br><span class="line">    │   ├── 线程：BatchInsertThread-1, 2, 3, ...</span><br><span class="line">    │   ├── 运行异步任务</span><br></pre></td></tr></table></figure>

<h3 id="4-示例：Tomcat-线程如何与-ThreadPoolTaskExecutor-交互"><a href="#4-示例：Tomcat-线程如何与-ThreadPoolTaskExecutor-交互" class="headerlink" title="4. 示例：Tomcat 线程如何与 ThreadPoolTaskExecutor 交互"></a><strong>4. 示例：</strong>Tomcat <strong>线程如何与</strong> <strong><code>ThreadPoolTaskExecutor</code></strong> <strong>交互</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor batchInsertThreadPool;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/submitTask&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">submitTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        batchInsertThreadPool.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行任务的线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;任务已提交&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>请求</strong> <strong><code>/test/submitTask</code></strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080/test/submitTask</span><br></pre></td></tr></table></figure>

<p><strong>控制台输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请求线程：http-nio-8080-exec-1</span><br><span class="line">执行任务的线程：BatchInsertThread-1</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>Tomcat 线程 <code>http-nio-8080-exec-1</code> 负责处理 HTTP 请求，执行 <code>Controller</code> 代码。</li>
<li><code>Controller</code> 把任务提交给 <code>ThreadPoolTaskExecutor</code>，然后立即返回。</li>
<li><code>ThreadPoolTaskExecutor</code> <strong>在自己的线程</strong> <code>BatchInsertThread-1</code> 里执行任务，<strong>不再依赖</strong> <strong>Tomcat</strong> <strong>线程</strong>。</li>
</ul>
<h3 id="5-为什么-ThreadPoolTaskExecutor-不会受到-Tomcat-线程的限制？"><a href="#5-为什么-ThreadPoolTaskExecutor-不会受到-Tomcat-线程的限制？" class="headerlink" title="5. 为什么 ThreadPoolTaskExecutor 不会受到 Tomcat 线程的限制？"></a><strong>5. 为什么</strong> <strong><code>ThreadPoolTaskExecutor</code></strong> <strong>不会受到</strong> <strong>Tomcat</strong> <strong>线程的限制？</strong></h3><ul>
<li><strong>线程池</strong>是 Spring 容器管理的全局 Bean，所有 Tomcat 线程都可以访问它。</li>
<li><strong>任务是提交给线程池，而不是运行在Tomcat 线程里</strong>，所以 Tomcat 线程和 <code>ThreadPoolTaskExecutor</code> 线程是分开的。</li>
<li><strong>Spring 线程池的生命周期不依赖于单个 HTTP 请求</strong>，即使 Tomcat 线程结束，Spring 线程池仍然可以运行。</li>
</ul>
<h3 id="6-线程池-shutdown-为什么能影响所有任务？"><a href="#6-线程池-shutdown-为什么能影响所有任务？" class="headerlink" title="6. 线程池 shutdown() 为什么能影响所有任务？"></a><strong>6. 线程池</strong> <strong><code>shutdown()</code></strong> <strong>为什么能影响所有任务？</strong></h3><blockquote>
<p><strong>不同</strong> <strong>REST API</strong> <strong>的线程为什么可以互相控制</strong> **<code>ThreadPoolTaskExecutor</code>**？</p>
</blockquote>
<p>原因是：</p>
<ol>
<li><strong>所有请求共享同一个</strong> <strong><code>ThreadPoolTaskExecutor</code></strong> <strong>实例</strong>（Spring 容器管理的单例 Bean）。</li>
<li><strong><code>shutdown()</code></strong> <strong>作用于整个线程池</strong>，而不是单个任务，所以不管是哪个请求触发的 <code>shutdown()</code>，它都会让整个线程池停止。</li>
<li><strong>结论</strong></li>
</ol>
<table>
<thead>
<tr>
<th>组件</th>
<th>作用</th>
<th>线程管理方式</th>
</tr>
</thead>
<tbody><tr>
<td>Tomcat 线程池</td>
<td>处理 HTTP 请求（Controller）</td>
<td>Tomcat 管理</td>
</tr>
<tr>
<td>Spring 容器</td>
<td>管理 Bean 和 ThreadPoolTaskExecutor</td>
<td>Spring 管理</td>
</tr>
<tr>
<td>ThreadPoolTaskExecutor</td>
<td>处理异步任务</td>
<td>Spring 管理</td>
</tr>
</tbody></table>
<p>✅ <strong>Tomcat</strong> <strong>线程和</strong> <strong><code>ThreadPoolTaskExecutor</code></strong> <strong>线程是完全独立的</strong>，但它们可以互相交互。 </p>
<p>✅ <strong>所有 HTTP 请求共享</strong> **<code>ThreadPoolTaskExecutor</code>**，所以 <code>shutdown()</code> 会影响所有提交的任务。</p>
<h2 id="多个servlet线程与spring的单例模式之间会造成线程冲突吗？"><a href="#多个servlet线程与spring的单例模式之间会造成线程冲突吗？" class="headerlink" title="多个servlet线程与spring的单例模式之间会造成线程冲突吗？"></a>多个servlet线程与spring的单例模式之间会造成线程冲突吗？</h2><p>不会，<strong>除非</strong> <strong><code>OrderService</code></strong> <strong>里有共享的可变状态（如全局变量）</strong>，否则不会发生线程冲突。</p>
<h3 id="1-Spring-单例-Bean-并发访问的本质"><a href="#1-Spring-单例-Bean-并发访问的本质" class="headerlink" title="1. Spring 单例 Bean 并发访问的本质"></a><strong>1. Spring</strong> <strong>单例</strong> <strong>Bean 并发访问的本质</strong></h3><h4 id="1-每个请求的线程是独立的"><a href="#1-每个请求的线程是独立的" class="headerlink" title="(1) 每个请求的线程是独立的"></a><strong>(1) 每个请求的线程是独立的</strong></h4><p>Spring 的 <code>@Service</code> Bean 默认是<strong>单例模式</strong>，但<strong>它的方法是被不同的</strong> <strong>Tomcat</strong> <strong>线程调用的</strong>，而每个 Tomcat 线程都有自己的<strong>独立调用栈</strong>，不会共享方法里的局部变量。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在处理订单：&quot;</span> + userId);</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 这是一个局部变量，每个线程都有自己的副本</span></span><br><span class="line">        total++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 订单完成，total = &quot;</span> + total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 5 个用户同时访问这个方法，Tomcat 可能会分配 5 个线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http-nio-8080-exec-1 正在处理订单：A</span><br><span class="line">http-nio-8080-exec-2 正在处理订单：B</span><br><span class="line">http-nio-8080-exec-3 正在处理订单：C</span><br><span class="line">http-nio-8080-exec-4 正在处理订单：D</span><br><span class="line">http-nio-8080-exec-5 正在处理订单：E</span><br></pre></td></tr></table></figure>

<p>每个线程都会有自己独立的 <code>total</code> 变量，<strong>互不影响</strong>，因此不会有线程冲突。</p>
<h4 id="2-什么时候会发生线程冲突？"><a href="#2-什么时候会发生线程冲突？" class="headerlink" title="(2) 什么时候会发生线程冲突？"></a><strong>(2) 什么时候会发生线程冲突？</strong></h4><p>如果 <code>OrderService</code> 里有<strong>共享的可变全局变量</strong>，那么多个线程可能会同时修改它，导致<strong>数据错乱</strong>。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">orderCount</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 共享变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        orderCount++; <span class="comment">// 线程不安全操作</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 订单处理完毕，orderCount = &quot;</span> + orderCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 5 个线程同时执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http-nio-8080-exec-1 订单处理完毕，orderCount = 1</span><br><span class="line">http-nio-8080-exec-2 订单处理完毕，orderCount = 2</span><br><span class="line">http-nio-8080-exec-3 订单处理完毕，orderCount = 3</span><br><span class="line">http-nio-8080-exec-4 订单处理完毕，orderCount = 4</span><br><span class="line">http-nio-8080-exec-5 订单处理完毕，orderCount = 5</span><br></pre></td></tr></table></figure>

<p><strong>问题：</strong></p>
<ul>
<li><code>orderCount++</code> 不是原子操作，多个线程可能会同时读取 <code>orderCount</code>，导致最终值不准确（可能丢失部分更新）。</li>
<li>这是线程安全问题，因为 <code>orderCount</code> 是多个线程共享的可变变量。</li>
</ul>
<h3 id="2-如何避免线程冲突？"><a href="#2-如何避免线程冲突？" class="headerlink" title="2. 如何避免线程冲突？"></a><strong>2. 如何避免线程冲突？</strong></h3><h4 id="✅-方案-1：避免共享可变变量"><a href="#✅-方案-1：避免共享可变变量" class="headerlink" title="✅ 方案 1：避免共享可变变量"></a><strong>✅ 方案 1：避免共享可变变量</strong></h4><p>如果 <code>orderCount</code> 只是一个业务逻辑内部的计数，不应该作为全局变量，可以把它改成<strong>局部变量</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">orderCount</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 线程安全，局部变量不会被共享</span></span><br><span class="line">        orderCount++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 订单处理完毕，orderCount = &quot;</span> + orderCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这样每个线程都有自己独立的</strong> <strong><code>orderCount</code></strong> <strong>变量，就不会有冲突。</strong></p>
<h4 id="✅-方案-2：使用-ThreadLocal"><a href="#✅-方案-2：使用-ThreadLocal" class="headerlink" title="✅ 方案 2：使用 ThreadLocal"></a><strong>✅ 方案 2：使用</strong> <strong><code>ThreadLocal</code></strong></h4><p>如果需要在同一个线程中共享数据，但不想让不同线程相互干扰，可以用 <code>ThreadLocal</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; orderCount = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        orderCount.set(orderCount.get() + <span class="number">1</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 订单处理完毕，orderCount = &quot;</span> + orderCount.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>ThreadLocal</code></strong> <strong>的作用：</strong></p>
<ul>
<li><strong>每个线程都会有自己独立的</strong> <strong><code>orderCount</code></strong> <strong>变量</strong>，不会和其他线程共享。</li>
<li><strong>适用于线程内部存储数据</strong>，比如用户会话信息、事务 ID 等。</li>
</ul>
<h4 id="✅-方案-3：使用-synchronized-（不推荐）"><a href="#✅-方案-3：使用-synchronized-（不推荐）" class="headerlink" title="✅ 方案 3：使用 **synchronized**（不推荐）"></a><strong>✅ 方案 3：使用</strong> **<code>synchronized</code>**（不推荐）</h4><p>如果确实需要在多个线程间共享变量，可以使用 <strong>同步锁</strong>，但这样会降低并发性能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">orderCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(String userId)</span> &#123; <span class="comment">// 方法加锁</span></span><br><span class="line">        orderCount++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 订单处理完毕，orderCount = &quot;</span> + orderCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题：</strong></p>
<ul>
<li><code>synchronized</code> 会<strong>让方法变成串行执行</strong>，一个线程执行时，其他线程必须等待，会导致性能下降。</li>
<li><strong>不推荐在高并发场景下使用</strong> **<code>synchronized</code>**。</li>
</ul>
<h4 id="✅-方案-4：使用-AtomicInteger"><a href="#✅-方案-4：使用-AtomicInteger" class="headerlink" title="✅ 方案 4：使用 AtomicInteger"></a><strong>✅ 方案 4：使用</strong> <strong><code>AtomicInteger</code></strong></h4><p><code>AtomicInteger</code> 通过 <strong>CAS（Compare And Swap）</strong> 操作保证线程安全：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">orderCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> orderCount.incrementAndGet(); <span class="comment">// 线程安全自增</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 订单处理完毕，orderCount = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li><code>incrementAndGet()</code> 是原子操作，多个线程同时调用不会导致数据丢失。</li>
<li>性能比 <code>synchronized</code> 更高。</li>
</ul>
<ol>
<li><strong>结论</strong></li>
</ol>
<p>❌ <strong>会引发线程冲突的情况</strong></p>
<ul>
<li><strong>Service 里的全局变量是可变的（非线程安全操作）</strong></li>
<li><strong>多个线程同时修改这个共享变量</strong></li>
</ul>
<p>✅ <strong>不会有线程冲突的情况</strong></p>
<ul>
<li><strong>方法里只有</strong>局部变量</li>
<li><strong>Tomcat</strong> <strong>分配的每个线程都有自己的</strong>调用栈</li>
<li><strong>使用</strong> <code>ThreadLocal</code><strong>、</strong><code>AtomicInteger</code>等解决共享变量问题</li>
</ul>
<p>🚀 <strong>Spring</strong> <strong><code>@Service</code></strong> 是单例的，但方法调用是并发的，不会天然有线程冲突，只有在共享全局变量时才需要额外注意线程安全。</p>
<h2 id="什么时候要调整-scope为多例"><a href="#什么时候要调整-scope为多例" class="headerlink" title="什么时候要调整@scope为多例"></a>什么时候要调整@scope为多例</h2><p>在 Spring 中，<strong>默认的 Bean</strong> <strong>作用域</strong>（Scope）是单例<strong>（</strong>Singleton<strong>）</strong>，即<strong>Spring 容器</strong>在应用启动时创建一个<strong>唯一的实例</strong>，并在整个应用程序范围内共享该实例。</p>
<p>但在某些情况下，我们需要使用 <code>@Scope</code> <strong>改变 Bean 的作用域</strong>，使其不再是单例模式，例如<strong>每个请求、每个线程、甚至每次调用都创建新的实例</strong>。</p>
<h3 id="1-什么时候需要使用-Scope-改变默认单例？"><a href="#1-什么时候需要使用-Scope-改变默认单例？" class="headerlink" title="1. 什么时候需要使用 @Scope 改变默认单例？"></a><strong>1. 什么时候需要使用</strong> <strong><code>@Scope</code></strong> <em>改变默认</em>单例？</h3><h4 id="✅-场景-1：需要为每个-HTTP-请求创建新的-Bean"><a href="#✅-场景-1：需要为每个-HTTP-请求创建新的-Bean" class="headerlink" title="✅ 场景 1：需要为每个 HTTP 请求创建新的 Bean"></a><strong>✅ 场景 1：需要为每个 HTTP 请求创建新的 Bean</strong></h4><blockquote>
<p><strong>适用</strong> <strong><code>@Scope(&quot;request&quot;)</code></strong> 适用于：Controller、用户信息、登录状态等与请求相关的 Bean</p>
</blockquote>
<p>在 Web 应用中，每个 HTTP 请求可能需要一个<strong>独立的 Bean 实例</strong>，比如<strong>存储当前请求的用户信息</strong>。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;request&quot;)</span> <span class="comment">// 每个 HTTP 请求都会创建新的 UserInfo 实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建新的 UserInfo 实例：&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123; <span class="keyword">return</span> username; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123; <span class="built_in">this</span>.username = username; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserInfo userInfo;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/set&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">setUser</span><span class="params">(<span class="meta">@RequestParam</span> String name)</span> &#123;</span><br><span class="line">        userInfo.setUsername(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User set: &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/get&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Current User: &quot;</span> + userInfo.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>📌 结果</strong></p>
<ul>
<li><code>GET /user/set?name=Alice</code> → <strong>创建新的</strong> <strong><code>UserInfo</code></strong> <strong>实例</strong></li>
<li><code>GET /user/get</code> → <strong>返回 Alice</strong></li>
<li>但如果换一个请求（比如新用户 <code>Bob</code>），Spring 会创建一个<strong>新的</strong> <strong><code>UserInfo</code></strong> <strong>实例</strong>。</li>
</ul>
<h4 id="✅-场景-2：每个会话（Session）创建一个新的-Bean"><a href="#✅-场景-2：每个会话（Session）创建一个新的-Bean" class="headerlink" title="✅ 场景 2：每个会话（Session）创建一个新的 Bean"></a><strong>✅ 场景 2：每个会话（Session）创建一个新的 Bean</strong></h4><blockquote>
<p><strong>适用</strong> <strong><code>@Scope(&quot;session&quot;)</code></strong> <strong>适用于：存储用户登录信息（比如购物车、用户认证信息等）</strong></p>
</blockquote>
<p>当用户登录后，我们通常需要在<strong>整个会话（Session）中保存用户状态</strong>，例如用户购物车、登录信息等。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;session&quot;)</span> <span class="comment">// 每个用户的 Session 共享一个实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCart</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; items = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addItem</span><span class="params">(String item)</span> &#123; items.add(item); &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getItems</span><span class="params">()</span> &#123; <span class="keyword">return</span> items; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a><strong>使用</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/cart&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCartController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ShoppingCart shoppingCart;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addItem</span><span class="params">(<span class="meta">@RequestParam</span> String item)</span> &#123;</span><br><span class="line">        shoppingCart.addItem(item);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Item added: &quot;</span> + item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getItems</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shoppingCart.getItems();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>📌 结果</strong></p>
<ul>
<li><strong>用户 A（Session 1）</strong> → <code>GET /cart/add?item=Apple</code> → <code>GET /cart/list</code> → <code>[&quot;Apple&quot;]</code></li>
<li><strong>用户 B（Session 2）</strong> → <code>GET /cart/list</code> → <code>[]</code>（因为 B 是新的会话）</li>
</ul>
<h4 id="✅-场景-3：每个线程创建一个独立的-Bean"><a href="#✅-场景-3：每个线程创建一个独立的-Bean" class="headerlink" title="✅ 场景 3：每个线程创建一个独立的 Bean"></a><strong>✅ 场景 3：每个线程创建一个独立的 Bean</strong></h4><blockquote>
<p><strong>适用</strong> <strong><code>@Scope(&quot;prototype&quot;)</code></strong> <strong>或</strong> <strong><code>@Scope(&quot;thread&quot;)</code></strong> <strong>适用于：<strong><strong>多线程</strong></strong>任务、线程隔离数据</strong></p>
</blockquote>
<p>在一些并发任务中，我们希望<strong>每个线程有自己的 Bean 实例</strong>，而不是所有线程共享同一个实例。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span> <span class="comment">// 每次调用都会创建新的实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TaskProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建新的 TaskProcessor：&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 处理任务：&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a><strong>使用</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TaskProcessor taskProcessor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeTask</span><span class="params">()</span> &#123;</span><br><span class="line">        taskProcessor.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多线程调用"><a href="#多线程调用" class="headerlink" title="多线程调用"></a>多线程调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/task&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TaskService taskService;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/start&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">startTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(taskService::executeTask).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(taskService::executeTask).start();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Tasks started!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>📌 结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread-1 处理任务：TaskProcessor@12345</span><br><span class="line">Thread-2 处理任务：TaskProcessor@67890</span><br></pre></td></tr></table></figure>

<p><strong>每个线程都有自己的</strong> <strong><code>TaskProcessor</code></strong> <strong>实例，互不干扰。</strong></p>
<h4 id="✅-场景-4：Bean-具有状态，每次使用都应该创建新实例"><a href="#✅-场景-4：Bean-具有状态，每次使用都应该创建新实例" class="headerlink" title="✅ 场景 4：Bean 具有状态，每次使用都应该创建新实例"></a><strong>✅ 场景 4：Bean 具有状态，每次使用都应该创建新实例</strong></h4><blockquote>
<p><strong>适用</strong> <strong><code>@Scope(&quot;prototype&quot;)</code></strong> <strong>适用于：任务处理器、算法计算等短生命周期对象</strong></p>
</blockquote>
<p>如果某个 Bean 有<strong>内部状态</strong>，并且不能被多个线程或请求共享，就需要 <code>prototype</code> 作用域。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span> <span class="comment">// 每次调用都会创建新实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">processCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        processCount++;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单处理次数：&quot;</span> + processCount + <span class="string">&quot; 实例：&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a><strong>使用</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processNewOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">OrderProcessor</span> <span class="variable">orderProcessor</span> <span class="operator">=</span> context.getBean(OrderProcessor.class);</span><br><span class="line">        orderProcessor.processOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a><strong>调用</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/process&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">processOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        orderService.processNewOrder();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Order processed!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>📌 结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">订单处理次数：1 实例：OrderProcessor@12345</span><br><span class="line">订单处理次数：1 实例：OrderProcessor@67890</span><br></pre></td></tr></table></figure>

<p>每次调用 <code>processNewOrder()</code> 都会创建一个新的 <code>OrderProcessor</code> 实例，避免了状态共享导致的数据错误。</p>
<h3 id="2-Scope-作用范围总结"><a href="#2-Scope-作用范围总结" class="headerlink" title="2.@Scope 作用范围总结"></a><strong>2.<code>@Scope</code></strong> <strong>作用范围总结</strong></h3><table>
<thead>
<tr>
<th>作用域</th>
<th>说明</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td>默认作用域，Spring 只创建一个实例</td>
<td>大多数无状态 Service、DAO</td>
</tr>
<tr>
<td>prototype</td>
<td>每次请求都会创建新实例</td>
<td>任务处理器、状态 Bean</td>
</tr>
<tr>
<td>request</td>
<td>每个 HTTP 请求创建一个实例</td>
<td>存储当前请求数据</td>
</tr>
<tr>
<td>session</td>
<td>每个用户 Session 创建一个实例</td>
<td>存储用户登录状态</td>
</tr>
<tr>
<td>application</td>
<td>整个 Web 应用共享一个实例</td>
<td>全局配置 Bean</td>
</tr>
<tr>
<td>websocket</td>
<td>每个 WebSocket 连接创建一个实例</td>
<td>WebSocket 会话管理</td>
</tr>
</tbody></table>
<h3 id="3-结论"><a href="#3-结论" class="headerlink" title="3.结论"></a><strong>3.结论</strong></h3><p><strong>🌟 什么时候用</strong> <strong><code>@Scope</code></strong> 改变默认单例模式？</p>
<ol>
<li><strong>如果 Bean 需要保存 HTTP 请求的状态</strong>，使用 <code>@Scope(&quot;request&quot;)</code></li>
<li><strong>如果 Bean 需要在整个用户 Session 共享</strong>，使用 <code>@Scope(&quot;session&quot;)</code></li>
<li><strong>如果 Bean 需要在每个线程中独立使用</strong>，使用 <code>@Scope(&quot;prototype&quot;)</code></li>
<li><strong>如果 Bean 具有状态，每次调用都需要新实例</strong>，使用 <code>@Scope(&quot;prototype&quot;)</code></li>
</ol>
<p><strong>🚀 Spring 默认使用</strong> <strong><code>singleton</code></strong> <strong>是因为它节省</strong>内存<strong>，提高性能，但在某些情况下，我们需要使用</strong> <strong><code>@Scope</code></strong> 来改变作用域<strong>，以保证</strong>线程安全和数据隔离。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://bshtj.github.io">bshtj</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://bshtj.github.io/2025/02/17/%E5%A6%82%E4%BD%95%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%BC%98%E9%9B%85%E6%9A%82%E5%81%9C%EF%BC%9F/">https://bshtj.github.io/2025/02/17/%E5%A6%82%E4%BD%95%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%BC%98%E9%9B%85%E6%9A%82%E5%81%9C%EF%BC%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://bshtj.github.io" target="_blank">bshtj_blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E9%97%AE%E9%A2%98/">突发奇想的问题</a></div><div class="post-share"><div class="social-share" data-image="/img/wuliannan.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/02/14/JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="JUC_线程池"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">JUC_线程池</div></div><div class="info-2"><div class="info-item-1">线程池基本概述线程池：一个容纳多个线程的容器，容器中的线程可以重复使用，省去了频繁创建和销毁线程对象的操作 线程池作用：  降低资源消耗，减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务 提高响应速度，当任务到达时，如果有线程可以直接用，不会出现系统僵死 提高线程的可管理性，如果无限制的创建线程，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控  线程池的核心思想：线程复用，同一个线程可以被重复使用，来处理多个任务 池化技术 (Pool)...</div></div></div></a><a class="pagination-related" href="/2025/02/20/1-2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E6%B5%81%E7%A8%8B/" title="1-2操作系统的发展流程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">1-2操作系统的发展流程</div></div><div class="info-2"><div class="info-item-1">1.2 操作系统发展历程1.2.1 手工操作阶段（无操作系统）计算机所有的工作都需要人工干预，如装入、运行、输出等。 缺点：  用户独占全机，不会出现资源被其他用户占用而等待（因为独占，只能运行一个），但是资源利用率低。 CPU等待手工操作，CPU利用不充分  1.2.2...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/06/03/Comparator%E6%8E%A5%E5%8F%A3%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/" title="Comparator接口与装饰器模式的链式调用"><img class="cover" src="/2025/06/03/Comparator%E6%8E%A5%E5%8F%A3%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/home.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-03</div><div class="info-item-2">Comparator接口与装饰器模式的链式调用</div></div><div class="info-2"><div class="info-item-1">Java Comparator 接口方法详解Comparator 是 Java 中用于定义对象比较规则的接口，位于 java.util 包中。以下是 Comparator 接口中的所有方法及其说明： 1. 核心比较方法int compare(T o1, T o2) 功能：比较两个对象 参数：o1 - 第一个对象，o2 - 第二个对象 返回： 负整数：o1 &lt; o2 零：o1 &#x3D;&#x3D; o2 正整数：o1 &gt; o2    1Comparator&lt;String&gt; lengthComparator = (s1, s2) -&gt; s1.length() - s2.length();  2. 默认方法（Java 8+）Comparator&lt;T&gt; reversed() 功能：返回一个逆序比较器 示例：  12Comparator&lt;Integer&gt; natural = Integer::compare;Comparator&lt;Integer&gt; reversed =...</div></div></div></a><a class="pagination-related" href="/2025/02/05/JUC-%E5%90%8C%E6%AD%A5/" title="JUC_同步"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-05</div><div class="info-item-2">JUC_同步</div></div><div class="info-2"><div class="info-item-1">同步临界区临界资源：一次仅允许一个进程使用的资源成为临界资源 临界区：访问临界资源的代码块 竞态条件：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件 一个程序运行多个线程是没有问题，多个线程读共享资源也没有问题，在多个线程对共享资源读写操作时发生指令交错，就会出现问题 为了避免临界区的竞态条件发生（解决线程安全问题）：  阻塞式的解决方案：synchronized，lock 非阻塞式的解决方案：原子变量  管程（monitor）：由局部于自己的若干公共变量和所有访问这些公共变量的过程所组成的软件模块，保证同一时刻只有一个进程在管程内活动，即管程内定义的操作在同一时刻只被一个进程调用（由编译器实现） synchronized：对象锁，保证了临界区内代码的原子性，采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其它线程获取这个对象锁时会阻塞，保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换 互斥和同步都可以采用 synchronized...</div></div></div></a><a class="pagination-related" href="/2025/02/07/JUC-%E5%86%85%E5%AD%98/" title="JUC_内存"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-07</div><div class="info-item-2">JUC_内存</div></div><div class="info-2"><div class="info-item-1">内存JMM内存模型Java 内存模型是 Java Memory Model（JMM），本身是一种抽象的概念，实际上并不存在，描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式 JMM 作用：  屏蔽各种硬件和操作系统的内存访问差异，实现让 Java 程序在各种平台下都能达到一致的内存访问效果 规定了线程和内存之间的一些关系  根据 JMM 的设计，系统存在一个主内存（Main Memory），Java 中所有变量都存储在主存中，对于所有线程都是共享的；每条线程都有自己的工作内存（Working Memory），工作内存中保存的是主存中某些变量的拷贝，线程对所有变量的操作都是先对变量进行拷贝，然后在工作内存中进行，不能直接操作主内存中的变量；线程之间无法相互直接访问，线程间的通信（传递）必须通过主内存来完成  主内存和工作内存：  主内存：计算机的内存，也就是经常提到的 8G 内存，16G 内存，存储所有共享变量的值 工作内存：存储该线程使用到的共享变量在主内存的的值的副本拷贝  JVM 和 JMM 之间的关系：JMM...</div></div></div></a><a class="pagination-related" href="/2025/02/14/JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="JUC_线程池"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-14</div><div class="info-item-2">JUC_线程池</div></div><div class="info-2"><div class="info-item-1">线程池基本概述线程池：一个容纳多个线程的容器，容器中的线程可以重复使用，省去了频繁创建和销毁线程对象的操作 线程池作用：  降低资源消耗，减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务 提高响应速度，当任务到达时，如果有线程可以直接用，不会出现系统僵死 提高线程的可管理性，如果无限制的创建线程，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控  线程池的核心思想：线程复用，同一个线程可以被重复使用，来处理多个任务 池化技术 (Pool)...</div></div></div></a><a class="pagination-related" href="/2025/02/13/JUC-%E6%97%A0%E9%94%81/" title="JUC_无锁"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-13</div><div class="info-item-2">JUC_无锁</div></div><div class="info-2"><div class="info-item-1">无锁CAS原理无锁编程：Lock Free CAS 的全称是 Compare-And-Swap，是 CPU 并发原语  CAS 并发原语体现在 Java 语言中就是 sun.misc.Unsafe 类的各个方法，调用 UnSafe 类中的 CAS 方法，JVM 会实现出 CAS 汇编指令，这是一种完全依赖于硬件的功能，实现了原子操作 CAS 是一种系统原语，原语属于操作系统范畴，是由若干条指令组成 ，用于完成某个功能的一个过程，并且原语的执行必须是连续的，执行过程中不允许被中断，所以 CAS 是一条 CPU 的原子指令，不会造成数据不一致的问题，是线程安全的  底层原理：CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核和多核 CPU 下都能够保证比较交换的原子性  程序是在单核处理器上运行，会省略 lock 前缀，单处理器自身会维护处理器内的顺序一致性，不需要 lock 前缀的内存屏障效果 程序是在多核处理器上运行，会为 cmpxchg 指令加上 lock 前缀。当某个核执行到带 lock 的指令时，CPU...</div></div></div></a><a class="pagination-related" href="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="JVM快速入门"><img class="cover" src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-12.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-13</div><div class="info-item-2">JVM快速入门</div></div><div class="info-2"><div class="info-item-1">本笔记基于视频 https://www.bilibili.com/video/BV1yE411Z7AP，旨在快速入门JVM。 笔记借 https://blog.csdn.net/qq\_45966440/article/details/120824295?spm=1001.2014.3001.5502    ClassLoader：Java 代码编译成二进制后，会经过类加载器，这样才能加载到 JVM 中运行。  Method Area：类是放在方法区中。  Heap：类的实例对象。   当类调用方法时，会用到 JVM Stack、PC Register、本地方法栈。 方法执行时的每行代码是有执行引擎中的解释器逐行执行，方法中的热点代码频繁调用的方法，由 JIT 编译器优化后执行，GC 会对堆中不用的对象进行回收。需要和操作系统打交道就需要使用到本地方法接口。 内存结构程序计数器PC Register和操作系统中的程序计数器类似，作用是记录吓一跳jvm指令的执行地址行号。 特点：  线程私有(每一个线程有一个程序计数器)  不存在内存溢出(jvm规范规定的，程序计数器是 JVM...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/wuliannan.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">bshtj</div><div class="author-info-description">学术辣鸡，不定时更新</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%BC%98%E9%9B%85%E6%9A%82%E5%81%9C%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">如何批量插入数据并实现优雅暂停？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%85%8D%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.1.</span> <span class="toc-text">1. 配置线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E9%80%BB%E8%BE%91"><span class="toc-number">1.2.</span> <span class="toc-text">2. 实现批量插入逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8E%A7%E5%88%B6%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.</span> <span class="toc-text">3. 控制批量插入循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AE%9E%E7%8E%B0%E4%BC%98%E9%9B%85%E5%85%B3%E9%97%AD"><span class="toc-number">1.4.</span> <span class="toc-text">4. 实现优雅关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%A7%A6%E5%8F%91%E4%BC%98%E9%9B%85%E5%85%B3%E9%97%AD"><span class="toc-number">1.5.</span> <span class="toc-text">5. 触发优雅关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%B5%8B%E8%AF%95%E4%B8%8E%E9%AA%8C%E8%AF%81"><span class="toc-number">1.6.</span> <span class="toc-text">6. 测试与验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">关键点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E5%92%8Cservlet%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%8E%E5%B1%9E%E5%85%B3%E7%B3%BB%E5%90%97%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">spring和servlet之间有从属关系吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Spring-%E5%92%8C-Tomcat-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.</span> <span class="toc-text">1. Spring 和 Tomcat 线程池的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-Tomcat-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 Tomcat 线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-Spring-%E5%AE%B9%E5%99%A8%E5%92%8C-Bean"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 Spring 容器和 Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-ThreadPoolTaskExecutor-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3 ThreadPoolTaskExecutor 线程池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88-ThreadPoolTaskExecutor-%E5%8F%AF%E4%BB%A5%E8%84%B1%E7%A6%BB-Tomcat-%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2. 为什么 ThreadPoolTaskExecutor 可以脱离 Tomcat 线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%8E%E5%B1%9E%E5%85%B3%E7%B3%BB%EF%BC%88Spring-vs-Tomcat-vs-%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">3. 从属关系（Spring vs. Tomcat vs. 线程池）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%A4%BA%E4%BE%8B%EF%BC%9ATomcat-%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E4%B8%8E-ThreadPoolTaskExecutor-%E4%BA%A4%E4%BA%92"><span class="toc-number">2.4.</span> <span class="toc-text">4. 示例：Tomcat 线程如何与 ThreadPoolTaskExecutor 交互</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88-ThreadPoolTaskExecutor-%E4%B8%8D%E4%BC%9A%E5%8F%97%E5%88%B0-Tomcat-%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%99%90%E5%88%B6%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">5. 为什么 ThreadPoolTaskExecutor 不会受到 Tomcat 线程的限制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%BA%BF%E7%A8%8B%E6%B1%A0-shutdown-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%BD%B1%E5%93%8D%E6%89%80%E6%9C%89%E4%BB%BB%E5%8A%A1%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">6. 线程池 shutdown() 为什么能影响所有任务？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AAservlet%E7%BA%BF%E7%A8%8B%E4%B8%8Espring%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%97%B4%E4%BC%9A%E9%80%A0%E6%88%90%E7%BA%BF%E7%A8%8B%E5%86%B2%E7%AA%81%E5%90%97%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">多个servlet线程与spring的单例模式之间会造成线程冲突吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Spring-%E5%8D%95%E4%BE%8B-Bean-%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">3.1.</span> <span class="toc-text">1. Spring 单例 Bean 并发访问的本质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%AF%8F%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%98%AF%E7%8B%AC%E7%AB%8B%E7%9A%84"><span class="toc-number">3.1.1.</span> <span class="toc-text">(1) 每个请求的线程是独立的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E7%BA%BF%E7%A8%8B%E5%86%B2%E7%AA%81%EF%BC%9F"><span class="toc-number">3.1.2.</span> <span class="toc-text">(2) 什么时候会发生线程冲突？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%BA%BF%E7%A8%8B%E5%86%B2%E7%AA%81%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">2. 如何避免线程冲突？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88-1%EF%BC%9A%E9%81%BF%E5%85%8D%E5%85%B1%E4%BA%AB%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F"><span class="toc-number">3.2.1.</span> <span class="toc-text">✅ 方案 1：避免共享可变变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88-2%EF%BC%9A%E4%BD%BF%E7%94%A8-ThreadLocal"><span class="toc-number">3.2.2.</span> <span class="toc-text">✅ 方案 2：使用 ThreadLocal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88-3%EF%BC%9A%E4%BD%BF%E7%94%A8-synchronized-%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">3.2.3.</span> <span class="toc-text">✅ 方案 3：使用 **synchronized**（不推荐）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88-4%EF%BC%9A%E4%BD%BF%E7%94%A8-AtomicInteger"><span class="toc-number">3.2.4.</span> <span class="toc-text">✅ 方案 4：使用 AtomicInteger</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A6%81%E8%B0%83%E6%95%B4-scope%E4%B8%BA%E5%A4%9A%E4%BE%8B"><span class="toc-number">4.</span> <span class="toc-text">什么时候要调整@scope为多例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8-Scope-%E6%94%B9%E5%8F%98%E9%BB%98%E8%AE%A4%E5%8D%95%E4%BE%8B%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">1. 什么时候需要使用 @Scope 改变默认单例？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E5%9C%BA%E6%99%AF-1%EF%BC%9A%E9%9C%80%E8%A6%81%E4%B8%BA%E6%AF%8F%E4%B8%AA-HTTP-%E8%AF%B7%E6%B1%82%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84-Bean"><span class="toc-number">4.1.1.</span> <span class="toc-text">✅ 场景 1：需要为每个 HTTP 请求创建新的 Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.1.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">4.1.3.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E5%9C%BA%E6%99%AF-2%EF%BC%9A%E6%AF%8F%E4%B8%AA%E4%BC%9A%E8%AF%9D%EF%BC%88Session%EF%BC%89%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84-Bean"><span class="toc-number">4.1.4.</span> <span class="toc-text">✅ 场景 2：每个会话（Session）创建一个新的 Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">4.1.5.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-number">4.1.6.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E5%9C%BA%E6%99%AF-3%EF%BC%9A%E6%AF%8F%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E7%9A%84-Bean"><span class="toc-number">4.1.7.</span> <span class="toc-text">✅ 场景 3：每个线程创建一个独立的 Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">4.1.8.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-2"><span class="toc-number">4.1.9.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">4.1.10.</span> <span class="toc-text">多线程调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E5%9C%BA%E6%99%AF-4%EF%BC%9ABean-%E5%85%B7%E6%9C%89%E7%8A%B6%E6%80%81%EF%BC%8C%E6%AF%8F%E6%AC%A1%E4%BD%BF%E7%94%A8%E9%83%BD%E5%BA%94%E8%AF%A5%E5%88%9B%E5%BB%BA%E6%96%B0%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.1.11.</span> <span class="toc-text">✅ 场景 4：Bean 具有状态，每次使用都应该创建新实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">4.1.12.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-3"><span class="toc-number">4.1.13.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8"><span class="toc-number">4.1.14.</span> <span class="toc-text">调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Scope-%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4%E6%80%BB%E7%BB%93"><span class="toc-number">4.2.</span> <span class="toc-text">2.@Scope 作用范围总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%93%E8%AE%BA"><span class="toc-number">4.3.</span> <span class="toc-text">3.结论</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/04/3-2%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" title="3.2 虚拟内存"><img src="/2025/06/04/3-2%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-14.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="3.2 虚拟内存"/></a><div class="content"><a class="title" href="/2025/06/04/3-2%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" title="3.2 虚拟内存">3.2 虚拟内存</a><time datetime="2025-06-04T10:43:50.000Z" title="发表于 2025-06-04 18:43:50">2025-06-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/03/Comparator%E6%8E%A5%E5%8F%A3%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/" title="Comparator接口与装饰器模式的链式调用"><img src="/2025/06/03/Comparator%E6%8E%A5%E5%8F%A3%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/home.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Comparator接口与装饰器模式的链式调用"/></a><div class="content"><a class="title" href="/2025/06/03/Comparator%E6%8E%A5%E5%8F%A3%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/" title="Comparator接口与装饰器模式的链式调用">Comparator接口与装饰器模式的链式调用</a><time datetime="2025-06-03T06:26:18.000Z" title="发表于 2025-06-03 14:26:18">2025-06-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/13/%E4%B8%8D%E5%90%8C%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" title="不同形式的二分查找"><img src="/2025/05/13/%E4%B8%8D%E5%90%8C%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/home.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="不同形式的二分查找"/></a><div class="content"><a class="title" href="/2025/05/13/%E4%B8%8D%E5%90%8C%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" title="不同形式的二分查找">不同形式的二分查找</a><time datetime="2025-05-13T02:13:03.000Z" title="发表于 2025-05-13 10:13:03">2025-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/08/%E4%BB%8E%E8%95%BE%E7%BC%AA%E5%AE%89%E7%9A%84%E6%8A%80%E8%83%BD%E5%85%A5%E6%89%8B%E8%AE%BE%E6%83%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="从蕾缪安的技能入手设想设计模式"><img src="/2025/05/08/%E4%BB%8E%E8%95%BE%E7%BC%AA%E5%AE%89%E7%9A%84%E6%8A%80%E8%83%BD%E5%85%A5%E6%89%8B%E8%AE%BE%E6%83%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/home.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从蕾缪安的技能入手设想设计模式"/></a><div class="content"><a class="title" href="/2025/05/08/%E4%BB%8E%E8%95%BE%E7%BC%AA%E5%AE%89%E7%9A%84%E6%8A%80%E8%83%BD%E5%85%A5%E6%89%8B%E8%AE%BE%E6%83%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="从蕾缪安的技能入手设想设计模式">从蕾缪安的技能入手设想设计模式</a><time datetime="2025-05-08T15:48:03.000Z" title="发表于 2025-05-08 23:48:03">2025-05-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/28/bitset%E4%BD%BF%E7%94%A8/" title="1.3 计算机的性能指标"><img src="/2025/04/28/bitset%E4%BD%BF%E7%94%A8/home.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="1.3 计算机的性能指标"/></a><div class="content"><a class="title" href="/2025/04/28/bitset%E4%BD%BF%E7%94%A8/" title="1.3 计算机的性能指标">1.3 计算机的性能指标</a><time datetime="2025-04-28T12:08:48.000Z" title="发表于 2025-04-28 20:08:48">2025-04-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By bshtj</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>