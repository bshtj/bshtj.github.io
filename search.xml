<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Comparator接口与装饰器模式的链式调用</title>
      <link href="/2025/06/03/Comparator%E6%8E%A5%E5%8F%A3%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/"/>
      <url>/2025/06/03/Comparator%E6%8E%A5%E5%8F%A3%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-Comparator-接口方法详解"><a href="#Java-Comparator-接口方法详解" class="headerlink" title="Java Comparator 接口方法详解"></a>Java Comparator 接口方法详解</h1><p>Comparator 是 Java 中用于定义对象比较规则的接口，位于 <code>java.util</code> 包中。以下是 Comparator 接口中的所有方法及其说明：</p><h2 id="1-核心比较方法"><a href="#1-核心比较方法" class="headerlink" title="1. 核心比较方法"></a>1. 核心比较方法</h2><h3 id="int-compare-T-o1-T-o2"><a href="#int-compare-T-o1-T-o2" class="headerlink" title="int compare(T o1, T o2)"></a><code>int compare(T o1, T o2)</code></h3><ul><li><strong>功能</strong>：比较两个对象</li><li><strong>参数</strong>：o1 - 第一个对象，o2 - 第二个对象</li><li>返回：<ul><li>负整数：o1 &lt; o2</li><li>零：o1 &#x3D;&#x3D; o2</li><li>正整数：o1 &gt; o2</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; lengthComparator = (s1, s2) -&gt; s1.length() - s2.length();</span><br></pre></td></tr></table></figure><h2 id="2-默认方法（Java-8-）"><a href="#2-默认方法（Java-8-）" class="headerlink" title="2. 默认方法（Java 8+）"></a>2. 默认方法（Java 8+）</h2><h3 id="Comparator-reversed"><a href="#Comparator-reversed" class="headerlink" title="Comparator&lt;T&gt; reversed()"></a><code>Comparator&lt;T&gt; reversed()</code></h3><ul><li><strong>功能</strong>：返回一个逆序比较器</li><li><strong>示例</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; natural = Integer::compare;</span><br><span class="line">Comparator&lt;Integer&gt; reversed = natural.reversed();</span><br></pre></td></tr></table></figure><h3 id="Comparator-thenComparing-Comparator-other"><a href="#Comparator-thenComparing-Comparator-other" class="headerlink" title="Comparator&lt;T&gt; thenComparing(Comparator&lt;? super T&gt; other)"></a><code>Comparator&lt;T&gt; thenComparing(Comparator&lt;? super T&gt; other)</code></h3><ul><li><strong>功能</strong>：当第一个比较器比较结果为相等时，使用另一个比较器继续比较</li><li><strong>示例</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; byLastName = Comparator.comparing(Person::getLastName);</span><br><span class="line">Comparator&lt;Person&gt; byFirstName = Comparator.comparing(Person::getFirstName);</span><br><span class="line">Comparator&lt;Person&gt; fullCompare = byLastName.thenComparing(byFirstName);</span><br></pre></td></tr></table></figure><h3 id="default-Comparator-thenComparing-Function-keyExtractor-Comparator-keyComparator"><a href="#default-Comparator-thenComparing-Function-keyExtractor-Comparator-keyComparator" class="headerlink" title="default &lt;U&gt; Comparator&lt;T&gt; thenComparing(Function&lt;? super T, ? extends U&gt; keyExtractor, Comparator&lt;? super U&gt; keyComparator)"></a><code>default &lt;U&gt; Comparator&lt;T&gt; thenComparing(Function&lt;? super T, ? extends U&gt; keyExtractor, Comparator&lt;? super U&gt; keyComparator)</code></h3><ul><li><strong>功能</strong>：先按当前比较器比较，相等时再按提取的键和指定的比较器比较</li><li><strong>示例</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; compare = Comparator.comparing(Person::getLastName)</span><br><span class="line">    .thenComparing(Person::getFirstName, String.CASE_INSENSITIVE_ORDER);</span><br></pre></td></tr></table></figure><h3 id="default-Comparator-thenComparing-Function-keyExtractor"><a href="#default-Comparator-thenComparing-Function-keyExtractor" class="headerlink" title="default &lt;U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; thenComparing(Function&lt;? super T, ? extends U&gt; keyExtractor)"></a><code>default &lt;U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; thenComparing(Function&lt;? super T, ? extends U&gt; keyExtractor)</code></h3><ul><li><strong>功能</strong>：先按当前比较器比较，相等时再按提取的键的自然顺序比较</li><li><strong>示例</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; compare = Comparator.comparing(Person::getAge)</span><br><span class="line">    .thenComparing(Person::getName);</span><br></pre></td></tr></table></figure><h3 id="default-Comparator-thenComparingInt-ToIntFunction-keyExtractor"><a href="#default-Comparator-thenComparingInt-ToIntFunction-keyExtractor" class="headerlink" title="default Comparator&lt;T&gt; thenComparingInt(ToIntFunction&lt;? super T&gt; keyExtractor)"></a><code>default Comparator&lt;T&gt; thenComparingInt(ToIntFunction&lt;? super T&gt; keyExtractor)</code></h3><ul><li><strong>功能</strong>：先按当前比较器比较，相等时再按int类型键比较</li><li><strong>示例</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; compare = Comparator.comparing(Person::getLastName)</span><br><span class="line">    .thenComparingInt(Person::getAge);</span><br></pre></td></tr></table></figure><h3 id="default-Comparator-thenComparingLong-ToLongFunction-keyExtractor"><a href="#default-Comparator-thenComparingLong-ToLongFunction-keyExtractor" class="headerlink" title="default Comparator&lt;T&gt; thenComparingLong(ToLongFunction&lt;? super T&gt; keyExtractor)"></a><code>default Comparator&lt;T&gt; thenComparingLong(ToLongFunction&lt;? super T&gt; keyExtractor)</code></h3><ul><li><strong>功能</strong>：先按当前比较器比较，相等时再按long类型键比较</li><li><strong>示例</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; compare = Comparator.comparing(Person::getLastName)</span><br><span class="line">    .thenComparingLong(Person::getId);</span><br></pre></td></tr></table></figure><h3 id="default-Comparator-thenComparingDouble-ToDoubleFunction-keyExtractor"><a href="#default-Comparator-thenComparingDouble-ToDoubleFunction-keyExtractor" class="headerlink" title="default Comparator&lt;T&gt; thenComparingDouble(ToDoubleFunction&lt;? super T&gt; keyExtractor)"></a><code>default Comparator&lt;T&gt; thenComparingDouble(ToDoubleFunction&lt;? super T&gt; keyExtractor)</code></h3><ul><li><strong>功能</strong>：先按当前比较器比较，相等时再按double类型键比较</li><li><strong>示例</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Product&gt; compare = Comparator.comparing(Product::getName)</span><br><span class="line">    .thenComparingDouble(Product::getPrice);</span><br></pre></td></tr></table></figure><h2 id="3-静态方法（Java-8-）"><a href="#3-静态方法（Java-8-）" class="headerlink" title="3. 静态方法（Java 8+）"></a>3. 静态方法（Java 8+）</h2><h3 id="static-Comparator-naturalOrder"><a href="#static-Comparator-naturalOrder" class="headerlink" title="static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; naturalOrder()"></a><code>static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; naturalOrder()</code></h3><ul><li><strong>功能</strong>：返回自然顺序比较器</li><li><strong>示例</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; natural = Comparator.naturalOrder();</span><br></pre></td></tr></table></figure><h3 id="static-Comparator-reverseOrder"><a href="#static-Comparator-reverseOrder" class="headerlink" title="static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; reverseOrder()"></a><code>static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; reverseOrder()</code></h3><ul><li><strong>功能</strong>：返回逆序自然顺序比较器</li><li><strong>示例</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; reverse = Comparator.reverseOrder();</span><br></pre></td></tr></table></figure><h3 id="static-Comparator-comparing-Function-keyExtractor-Comparator-keyComparator"><a href="#static-Comparator-comparing-Function-keyExtractor-Comparator-keyComparator" class="headerlink" title="static &lt;T, U&gt; Comparator&lt;T&gt; comparing(Function&lt;? super T, ? extends U&gt; keyExtractor, Comparator&lt;? super U&gt; keyComparator)"></a><code>static &lt;T, U&gt; Comparator&lt;T&gt; comparing(Function&lt;? super T, ? extends U&gt; keyExtractor, Comparator&lt;? super U&gt; keyComparator)</code></h3><ul><li><strong>功能</strong>：根据提取的键和指定的比较器创建比较器</li><li><strong>示例</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; compare = Comparator.comparing(</span><br><span class="line">    Person::getLastName, </span><br><span class="line">    String.CASE_INSENSITIVE_ORDER</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="static-Comparator-comparing-Function-keyExtractor"><a href="#static-Comparator-comparing-Function-keyExtractor" class="headerlink" title="static &lt;T, U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; comparing(Function&lt;? super T, ? extends U&gt; keyExtractor)"></a><code>static &lt;T, U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; comparing(Function&lt;? super T, ? extends U&gt; keyExtractor)</code></h3><ul><li><strong>功能</strong>：根据提取的键的自然顺序创建比较器</li><li><strong>示例</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; compare = Comparator.comparing(Person::getLastName);</span><br></pre></td></tr></table></figure><h3 id="static-Comparator-comparingInt-ToIntFunction-keyExtractor"><a href="#static-Comparator-comparingInt-ToIntFunction-keyExtractor" class="headerlink" title="static &lt;T&gt; Comparator&lt;T&gt; comparingInt(ToIntFunction&lt;? super T&gt; keyExtractor)"></a><code>static &lt;T&gt; Comparator&lt;T&gt; comparingInt(ToIntFunction&lt;? super T&gt; keyExtractor)</code></h3><ul><li><strong>功能</strong>：根据int类型键创建比较器</li><li><strong>示例</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; compare = Comparator.comparingInt(Person::getAge);</span><br></pre></td></tr></table></figure><h3 id="static-Comparator-comparingLong-ToLongFunction-keyExtractor"><a href="#static-Comparator-comparingLong-ToLongFunction-keyExtractor" class="headerlink" title="static &lt;T&gt; Comparator&lt;T&gt; comparingLong(ToLongFunction&lt;? super T&gt; keyExtractor)"></a><code>static &lt;T&gt; Comparator&lt;T&gt; comparingLong(ToLongFunction&lt;? super T&gt; keyExtractor)</code></h3><ul><li><strong>功能</strong>：根据long类型键创建比较器</li><li><strong>示例</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; compare = Comparator.comparingLong(Person::getId);</span><br></pre></td></tr></table></figure><h3 id="static-Comparator-comparingDouble-ToDoubleFunction-keyExtractor"><a href="#static-Comparator-comparingDouble-ToDoubleFunction-keyExtractor" class="headerlink" title="static &lt;T&gt; Comparator&lt;T&gt; comparingDouble(ToDoubleFunction&lt;? super T&gt; keyExtractor)"></a><code>static &lt;T&gt; Comparator&lt;T&gt; comparingDouble(ToDoubleFunction&lt;? super T&gt; keyExtractor)</code></h3><ul><li><strong>功能</strong>：根据double类型键创建比较器</li><li><strong>示例</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Product&gt; compare = Comparator.comparingDouble(Product::getPrice);</span><br></pre></td></tr></table></figure><h3 id="static-Comparator-nullsFirst-Comparator-comparator"><a href="#static-Comparator-nullsFirst-Comparator-comparator" class="headerlink" title="static &lt;T&gt; Comparator&lt;T&gt; nullsFirst(Comparator&lt;? super T&gt; comparator)"></a><code>static &lt;T&gt; Comparator&lt;T&gt; nullsFirst(Comparator&lt;? super T&gt; comparator)</code></h3><ul><li><strong>功能</strong>：将null视为小于非null值，非null值使用指定比较器比较</li><li><strong>示例</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comparator = Comparator.nullsFirst(String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure><h3 id="static-Comparator-nullsLast-Comparator-comparator"><a href="#static-Comparator-nullsLast-Comparator-comparator" class="headerlink" title="static &lt;T&gt; Comparator&lt;T&gt; nullsLast(Comparator&lt;? super T&gt; comparator)"></a><code>static &lt;T&gt; Comparator&lt;T&gt; nullsLast(Comparator&lt;? super T&gt; comparator)</code></h3><ul><li><strong>功能</strong>：将null视为大于非null值，非null值使用指定比较器比较</li><li><strong>示例</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comparator = Comparator.nullsLast(String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure><h1 id="如何使用-Java-Comparator-接口"><a href="#如何使用-Java-Comparator-接口" class="headerlink" title="如何使用 Java Comparator 接口"></a>如何使用 Java Comparator 接口</h1><p>Comparator 接口在 Java 中非常实用，主要用于自定义对象排序规则。下面我会通过具体示例展示如何使用 Comparator 的各种方法。</p><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h2><h3 id="创建简单的比较器"><a href="#创建简单的比较器" class="headerlink" title="创建简单的比较器"></a>创建简单的比较器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;David&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按字符串长度排序</span></span><br><span class="line">Comparator&lt;String&gt; byLength = (s1, s2) -&gt; s1.length() - s2.length();</span><br><span class="line">names.sort(byLength);</span><br><span class="line"><span class="comment">// 结果: [Bob, Alice, David, Charlie]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按字母顺序排序</span></span><br><span class="line">Comparator&lt;String&gt; alphabetical = String::compareTo;</span><br><span class="line">names.sort(alphabetical);</span><br><span class="line"><span class="comment">// 结果: [Alice, Bob, Charlie, David]</span></span><br></pre></td></tr></table></figure><h2 id="2-使用静态工厂方法"><a href="#2-使用静态工厂方法" class="headerlink" title="2. 使用静态工厂方法"></a>2. 使用静态工厂方法</h2><p>Java 8 提供了方便的静态方法来创建比较器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; people = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Smith&quot;</span>, <span class="number">25</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Johnson&quot;</span>, <span class="number">30</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;Williams&quot;</span>, <span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按姓氏排序</span></span><br><span class="line">Comparator&lt;Person&gt; byLastName = Comparator.comparing(Person::getLastName);</span><br><span class="line">people.sort(byLastName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按年龄排序</span></span><br><span class="line">Comparator&lt;Person&gt; byAge = Comparator.comparingInt(Person::getAge);</span><br><span class="line">people.sort(byAge);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按姓氏长度排序</span></span><br><span class="line">Comparator&lt;Person&gt; byLastNameLength = </span><br><span class="line">    Comparator.comparing(p -&gt; p.getLastName().length());</span><br><span class="line">people.sort(byLastNameLength);</span><br></pre></td></tr></table></figure><h2 id="3-链式比较（多级排序）"><a href="#3-链式比较（多级排序）" class="headerlink" title="3. 链式比较（多级排序）"></a>3. 链式比较（多级排序）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先按姓氏排序，姓氏相同再按名字排序</span></span><br><span class="line">Comparator&lt;Person&gt; byLastNameThenFirstName = </span><br><span class="line">    Comparator.comparing(Person::getLastName)</span><br><span class="line">              .thenComparing(Person::getFirstName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先按年龄降序，年龄相同再按名字排序</span></span><br><span class="line">Comparator&lt;Person&gt; byAgeDescThenName = </span><br><span class="line">    Comparator.comparingInt(Person::getAge).reversed()</span><br><span class="line">              .thenComparing(Person::getFirstName);</span><br><span class="line"></span><br><span class="line">people.sort(byLastNameThenFirstName);</span><br></pre></td></tr></table></figure><h2 id="4-处理-null-值"><a href="#4-处理-null-值" class="headerlink" title="4. 处理 null 值"></a>4. 处理 null 值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; namesWithNulls = Arrays.asList(<span class="string">&quot;Alice&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Bob&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// null 值排在前面</span></span><br><span class="line">Comparator&lt;String&gt; nullsFirst = Comparator.nullsFirst(String::compareTo);</span><br><span class="line">namesWithNulls.sort(nullsFirst);</span><br><span class="line"><span class="comment">// 结果: [null, null, Alice, Bob, Charlie]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null 值排在后面</span></span><br><span class="line">Comparator&lt;String&gt; nullsLast = Comparator.nullsLast(String::compareTo);</span><br><span class="line">namesWithNulls.sort(nullsLast);</span><br><span class="line"><span class="comment">// 结果: [Alice, Bob, Charlie, null, null]</span></span><br></pre></td></tr></table></figure><h2 id="5-逆序排序"><a href="#5-逆序排序" class="headerlink" title="5. 逆序排序"></a>5. 逆序排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自然顺序</span></span><br><span class="line">numbers.sort(Comparator.naturalOrder());</span><br><span class="line"><span class="comment">// 结果: [1, 2, 3, 5, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆序</span></span><br><span class="line">numbers.sort(Comparator.reverseOrder());</span><br><span class="line"><span class="comment">// 结果: [8, 5, 3, 2, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用 reversed() 方法</span></span><br><span class="line">Comparator&lt;Integer&gt; natural = Comparator.naturalOrder();</span><br><span class="line">numbers.sort(natural.reversed());</span><br><span class="line"><span class="comment">// 结果: [8, 5, 3, 2, 1]</span></span><br></pre></td></tr></table></figure><h2 id="6-复杂对象排序示例"><a href="#6-复杂对象排序示例" class="headerlink" title="6. 复杂对象排序示例"></a>6. 复杂对象排序示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Product &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private double price;</span><br><span class="line">    private int stock;</span><br><span class="line">    </span><br><span class="line">    // 构造方法、getter 和 setter 省略</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Product&gt; products = Arrays.asList(</span><br><span class="line">    new Product(&quot;Laptop&quot;, 999.99, 10),</span><br><span class="line">    new Product(&quot;Phone&quot;, 699.99, 15),</span><br><span class="line">    new Product(&quot;Tablet&quot;, 299.99, 20),</span><br><span class="line">    new Product(&quot;Laptop&quot;, 899.99, 5)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 按价格升序</span><br><span class="line">products.sort(Comparator.comparingDouble(Product::getPrice));</span><br><span class="line"></span><br><span class="line">// 按价格降序</span><br><span class="line">products.sort(Comparator.comparingDouble(Product::getPrice).reversed());</span><br><span class="line"></span><br><span class="line">// 按名称升序，名称相同按库存降序</span><br><span class="line">Comparator&lt;Product&gt; byNameThenStock = </span><br><span class="line">    Comparator.comparing(Product::getName)</span><br><span class="line">              .thenComparingInt(Product::getStock).reversed();</span><br><span class="line"></span><br><span class="line">products.sort(byNameThenStock);</span><br></pre></td></tr></table></figure><h2 id="7-与-Lambda-表达式结合"><a href="#7-与-Lambda-表达式结合" class="headerlink" title="7. 与 Lambda 表达式结合"></a>7. 与 Lambda 表达式结合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;pear&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按字符串长度排序</span></span><br><span class="line">words.sort((s1, s2) -&gt; s1.length() - s2.length());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按最后一个字母排序</span></span><br><span class="line">words.sort((s1, s2) -&gt; </span><br><span class="line">    s1.charAt(s1.length()-<span class="number">1</span>) - s2.charAt(s2.length()-<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法引用</span></span><br><span class="line">words.sort(Comparator.comparingInt(String::length));</span><br></pre></td></tr></table></figure><h2 id="8-在集合中使用"><a href="#8-在集合中使用" class="headerlink" title="8. 在集合中使用"></a>8. 在集合中使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建有序集合</span></span><br><span class="line">Set&lt;String&gt; sortedSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Comparator.comparingInt(String::length));</span><br><span class="line">sortedSet.addAll(Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建有序Map</span></span><br><span class="line">Map&lt;Product, Integer&gt; inventory = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(</span><br><span class="line">    Comparator.comparing(Product::getName)</span><br><span class="line">              .thenComparingDouble(Product::getPrice)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><ol><li><strong>数据库查询结果排序</strong>：从数据库获取数据后按不同字段排序</li><li><strong>报表生成</strong>：生成报表时按多列排序</li><li><strong>UI展示</strong>：前端表格支持多列排序时，后端处理排序逻辑</li><li><strong>数据分析</strong>：分析数据前对数据进行排序处理</li></ol><p>Comparator 的强大之处在于它的灵活性和可组合性，你可以轻松创建各种复杂的排序逻辑来满足不同的业务需求。</p><h1 id="如何使用装饰器模式实现链式调用"><a href="#如何使用装饰器模式实现链式调用" class="headerlink" title="如何使用装饰器模式实现链式调用"></a>如何使用装饰器模式实现链式调用</h1><p>装饰器模式非常适合实现链式调用，因为它允许动态地添加功能到对象中。下面我将展示如何用装饰器模式实现一个支持链式调用的 <code>Comparator</code>。</p><h2 id="1-基础实现"><a href="#1-基础实现" class="headerlink" title="1. 基础实现"></a>1. 基础实现</h2><p>首先定义一个基本的 <code>Comparator</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链式调用的关键方法</span></span><br><span class="line">    <span class="keyword">default</span> Comparator&lt;T&gt; <span class="title function_">thenComparing</span><span class="params">(Comparator&lt;T&gt; other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThenComparingComparator</span>&lt;&gt;(<span class="built_in">this</span>, other);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-装饰器实现"><a href="#2-装饰器实现" class="headerlink" title="2. 装饰器实现"></a>2. 装饰器实现</h2><p>装饰器模式是一种 <strong>结构型设计模式</strong>，它允许 <strong>动态地扩展对象的功能</strong>，而 <strong>不改变其原始结构</strong>。它的核心特点是：</p><ul><li><strong>装饰器（Decorator）</strong> 持有 <strong>被装饰对象（Component）</strong> 的引用，并实现相同的接口。</li><li>装饰器可以在 <strong>调用被装饰对象的方法前后</strong> 添加额外的逻辑。</li><li>可以 <strong>嵌套多个装饰器</strong>，形成链式增强。</li></ul><h3 id="ThenComparingComparator-如何体现装饰器模式？"><a href="#ThenComparingComparator-如何体现装饰器模式？" class="headerlink" title="ThenComparingComparator 如何体现装饰器模式？"></a><strong><code>ThenComparingComparator</code> 如何体现装饰器模式？</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThenComparingComparator</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;T&gt; first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;T&gt; second;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThenComparingComparator</span><span class="params">(Comparator&lt;T&gt; first, Comparator&lt;T&gt; second)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> first.compare(o1, o2);</span><br><span class="line">        <span class="keyword">return</span> result != <span class="number">0</span> ? result : second.compare(o1, o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-它实现了-MyComparator-接口，并持有另一个-MyComparator"><a href="#1-它实现了-MyComparator-接口，并持有另一个-MyComparator" class="headerlink" title="(1) 它实现了 MyComparator 接口，并持有另一个 MyComparator"></a><strong>(1) 它实现了 <code>MyComparator</code> 接口，并持有另一个 <code>MyComparator</code></strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThenComparingComparator</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">MyComparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyComparator&lt;T&gt; first;  <span class="comment">// 被装饰的原始比较器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyComparator&lt;T&gt; second; <span class="comment">// 新增的比较逻辑</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>first</code> 是被装饰的原始比较器（如 <code>PropertyComparator</code>）。</li><li><code>second</code> 是新增的比较逻辑（如另一个 <code>PropertyComparator</code> 或 <code>ThenComparingComparator</code>）。</li><li>**<code>ThenComparingComparator</code> 本身也是一个 <code>MyComparator</code>**，所以它可以 <strong>递归嵌套</strong>，形成链式调用。</li></ul><h4 id="2-它增强（装饰）了-compare-方法"><a href="#2-它增强（装饰）了-compare-方法" class="headerlink" title="(2) 它增强（装饰）了 compare 方法"></a><strong>(2) 它增强（装饰）了 <code>compare</code> 方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> first.compare(o1, o2);  <span class="comment">// 先调用被装饰的比较器</span></span><br><span class="line">    <span class="keyword">return</span> result != <span class="number">0</span> ? result : second.compare(o1, o2); <span class="comment">// 如果相等，再调用新增的比较器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>**先调用 <code>first.compare()</code>**（原始比较逻辑）。</li><li>**如果 <code>first</code> 返回 <code>0</code>（相等），再调用 <code>second.compare()</code>**（新增比较逻辑）。</li><li>这样，<code>ThenComparingComparator</code> <strong>在不修改 <code>first</code> 和 <code>second</code> 的情况下</strong>，扩展了比较逻辑。</li></ul><h4 id="3-可以无限嵌套，形成链式装饰"><a href="#3-可以无限嵌套，形成链式装饰" class="headerlink" title="(3) 可以无限嵌套，形成链式装饰"></a><strong>(3) 可以无限嵌套，形成链式装饰</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyComparator&lt;Person&gt; comparator = </span><br><span class="line">    MyComparator.comparing(Person::getLastName)       <span class="comment">// 1. 原始比较器</span></span><br><span class="line">        .thenComparing(MyComparator.comparing(Person::getFirstName))  <span class="comment">// 2. 装饰一层</span></span><br><span class="line">        .thenComparing(MyComparator.comparingInt(Person::getAge));     <span class="comment">// 3. 再装饰一层</span></span><br></pre></td></tr></table></figure><ul><li>每次调用 <code>thenComparing</code>，都会 **创建一个新的 <code>ThenComparingComparator</code>**，并 **把当前的比较器作为 <code>first</code>，新的比较器作为 <code>second</code>**。</li><li>最终形成一个 <strong>嵌套的装饰链</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThenComparingComparator(</span><br><span class="line">    first = ThenComparingComparator(</span><br><span class="line">        first = PropertyComparator (比较 lastName),</span><br><span class="line">        second = PropertyComparator (比较 firstName)</span><br><span class="line">    ),</span><br><span class="line">    second = PropertyComparator (比较 age)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>这样，<strong>每层装饰器都能增强比较逻辑</strong>，而 <strong>不修改原有的比较器</strong>。</li></ul><h2 id="3-具体比较器实现"><a href="#3-具体比较器实现" class="headerlink" title="3. 具体比较器实现"></a>3. 具体比较器实现</h2><p>实现一个简单的属性比较器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertyComparator</span>&lt;T, U <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;U&gt;&gt; <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;T, U&gt; propertyExtractor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PropertyComparator</span><span class="params">(Function&lt;T, U&gt; propertyExtractor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.propertyExtractor = propertyExtractor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span> &#123;</span><br><span class="line">        <span class="type">U</span> <span class="variable">p1</span> <span class="operator">=</span> propertyExtractor.apply(o1);</span><br><span class="line">        <span class="type">U</span> <span class="variable">p2</span> <span class="operator">=</span> propertyExtractor.apply(o2);</span><br><span class="line">        <span class="keyword">return</span> p1.compareTo(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-使用示例"><a href="#4-使用示例" class="headerlink" title="4. 使用示例"></a>4. 使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法、getters 省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Person&gt; people = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>, <span class="number">25</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Smith&quot;</span>, <span class="number">30</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Smith&quot;</span>, <span class="number">25</span>)</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建比较器链</span></span><br><span class="line">        Comparator&lt;Person&gt; comparator = <span class="keyword">new</span> <span class="title class_">PropertyComparator</span>&lt;&gt;(Person::getLastName)</span><br><span class="line">            .thenComparing(<span class="keyword">new</span> <span class="title class_">PropertyComparator</span>&lt;&gt;(Person::getFirstName))</span><br><span class="line">            .thenComparing((p1, p2) -&gt; Integer.compare(p1.getAge(), p2.getAge()));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        people.sort(comparator);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        people.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-更优雅的工厂方法"><a href="#5-更优雅的工厂方法" class="headerlink" title="5. 更优雅的工厂方法"></a>5. 更优雅的工厂方法</h2><p>可以添加静态工厂方法使创建更简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> Comparator&lt;T&gt; <span class="title function_">thenComparing</span><span class="params">(Comparator&lt;T&gt; other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThenComparingComparator</span>&lt;&gt;(<span class="built_in">this</span>, other);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T, U <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;U&gt;&gt; Comparator&lt;T&gt; <span class="title function_">comparing</span><span class="params">(Function&lt;T, U&gt; keyExtractor)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PropertyComparator</span>&lt;&gt;(keyExtractor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用方式变为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; comparator = Comparator.comparing(Person::getLastName)</span><br><span class="line">    .thenComparing(Comparator.comparing(Person::getFirstName))</span><br><span class="line">    .thenComparing((p1, p2) -&gt; Integer.compare(p1.getAge(), p2.getAge()));</span><br></pre></td></tr></table></figure><h2 id="装饰器模式的关键点"><a href="#装饰器模式的关键点" class="headerlink" title="装饰器模式的关键点"></a>装饰器模式的关键点</h2><ol><li><strong>包装对象</strong>：装饰器类持有被装饰对象的引用</li><li><strong>保持接口一致</strong>：装饰器与被装饰对象实现相同接口</li><li><strong>动态扩展</strong>：可以在运行时组合多个装饰器</li><li><strong>透明性</strong>：客户端无需知道是否使用了装饰器</li></ol><p>这种实现方式与 JDK 中的 <code>Comparator</code> 实现原理非常相似，只是简化了一些细节。通过装饰器模式，我们可以灵活地组合多个比较逻辑，形成链式调用。</p><p><strong>总体代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.functionalInterface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChainableComparatorExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Person&gt; people = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>, <span class="number">25</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Smith&quot;</span>, <span class="number">30</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Smith&quot;</span>, <span class="number">25</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>, <span class="number">30</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用链式比较器进行排序</span></span><br><span class="line">        MyComparator&lt;Person&gt; comparator = MyComparator.comparing(Person::getLastName)</span><br><span class="line">                .thenComparing(MyComparator.comparing(Person::getFirstName))</span><br><span class="line">                .thenComparing(MyComparator.comparingInt(Person::getAge));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span>);</span><br><span class="line">        people.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为标准Comparator接口</span></span><br><span class="line">        people.sort(comparator::compare);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n排序后:&quot;</span>);</span><br><span class="line">        people.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改名为MyComparator避免冲突</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyComparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链式调用的关键方法</span></span><br><span class="line">    <span class="comment">// this=first,other=second</span></span><br><span class="line">    <span class="keyword">default</span> MyComparator&lt;T&gt; <span class="title function_">thenComparing</span><span class="params">(MyComparator&lt;T&gt; other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThenComparingComparator</span>&lt;&gt;(<span class="built_in">this</span>, other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态工厂方法</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T, U <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;U&gt;&gt; MyComparator&lt;T&gt; <span class="title function_">comparing</span><span class="params">(Function&lt;T, U&gt; keyExtractor)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PropertyComparator</span>&lt;&gt;(keyExtractor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本类型特化</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; MyComparator&lt;T&gt; <span class="title function_">comparingInt</span><span class="params">(ToIntFunction&lt;T&gt; keyExtractor)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (o1, o2) -&gt; Integer.compare(keyExtractor.applyAsInt(o1), keyExtractor.applyAsInt(o2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器实现 - 用于链式调用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThenComparingComparator</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">MyComparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyComparator&lt;T&gt; first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyComparator&lt;T&gt; second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThenComparingComparator</span><span class="params">(MyComparator&lt;T&gt; first, MyComparator&lt;T&gt; second)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> first.compare(o1, o2);  <span class="comment">// 第一步：用第一个比较器比较</span></span><br><span class="line">        <span class="keyword">return</span> result != <span class="number">0</span> ? result : second.compare(o1, o2); <span class="comment">// 第二步：如果相等，再用第二个比较器比较</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性比较器实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PropertyComparator</span>&lt;T, U <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;U&gt;&gt; <span class="keyword">implements</span> <span class="title class_">MyComparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;T, U&gt; propertyExtractor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PropertyComparator</span><span class="params">(Function&lt;T, U&gt; propertyExtractor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.propertyExtractor = propertyExtractor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span> &#123;</span><br><span class="line">        <span class="type">U</span> <span class="variable">p1</span> <span class="operator">=</span> propertyExtractor.apply(o1);</span><br><span class="line">        <span class="type">U</span> <span class="variable">p2</span> <span class="operator">=</span> propertyExtractor.apply(o2);</span><br><span class="line">        <span class="keyword">return</span> p1.compareTo(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本类型函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ToIntFunction</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">applyAsInt</span><span class="params">(T value)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用Person类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String firstName, String lastName, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFirstName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLastName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastName + <span class="string">&quot; &quot;</span> + firstName + <span class="string">&quot; (&quot;</span> + age + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 装饰器模式 </tag>
            
            <tag> 函数式接口 </tag>
            
            <tag> Comparator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不同形式的二分查找</title>
      <link href="/2025/05/13/%E4%B8%8D%E5%90%8C%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2025/05/13/%E4%B8%8D%E5%90%8C%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/discuss/post/3579164/ti-dan-er-fen-suan-fa-er-fen-da-an-zui-x-3rqn/">https://leetcode.cn/discuss/post/3579164/ti-dan-er-fen-suan-fa-er-fen-da-an-zui-x-3rqn/</a></p><h1 id="一、二分查找"><a href="#一、二分查找" class="headerlink" title="一、二分查找"></a>一、二分查找</h1><h2 id="1-1-基础-红蓝染色法"><a href="#1-1-基础-红蓝染色法" class="headerlink" title="1.1 基础(红蓝染色法)"></a>1.1 基础(红蓝染色法)</h2><p>思路就是首先规定红色和蓝色表示的范围</p><p><img src="/2025/05/13/%E4%B8%8D%E5%90%8C%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-6.png"></p><p>然后二分查找实际上就是确定红色和蓝色所能表示的范围。</p><p><strong>核心思路就是确定一个颜色表示的范围，那么这个颜色和其他颜色的补集都要符合这个范围（循环不变量）。</strong></p><ul><li><p>这里在写代码的时候其实可以其实可以这么想：（假设红左，蓝右)</p><ul><li>我们默认一开始写的判断条件比如说<code>if nums[mid] &lt; target</code>就是红色（因为修改的是left），那么它的else就一定是红色（&gt;&#x3D;），在写红色时候考虑要不要-1实际上只要考虑不能包含&#x3D;的情况（因为当前确定的是蓝色部分，要把剩余的部分留给红色）</li></ul></li></ul><p><strong>不同的写法可以这么想，就是以两侧都是闭区间为基准，他是left &#x3D; mid + 1; right &#x3D; mid - 1;对于开区间，比如说左开就是left &#x3D; mid，右开就是right &#x3D; mid，两侧都开就是既要left &#x3D; mid，又要right &#x3D; mid。</strong></p><h3 id="闭区间写法"><a href="#闭区间写法" class="headerlink" title="闭区间写法"></a>闭区间写法</h3><p><img src="/2025/05/13/%E4%B8%8D%E5%90%8C%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-5.png"></p><p>L&#x3D;M+1确定的是红色</p><p><img src="/2025/05/13/%E4%B8%8D%E5%90%8C%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-3.png"></p><p>R &#x3D; M-1确定的是蓝色</p><p><img src="/2025/05/13/%E4%B8%8D%E5%90%8C%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-4.png"></p><p>可以想象，这种写法最后得到的第一个蓝色区块的位置（L指向的）就是第一个大于等于target的位置。</p><p><img src="/2025/05/13/%E4%B8%8D%E5%90%8C%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-2.png"></p><h3 id="一侧开区间写法"><a href="#一侧开区间写法" class="headerlink" title="一侧开区间写法"></a>一侧开区间写法</h3><p><img src="/2025/05/13/%E4%B8%8D%E5%90%8C%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-1.png"></p><h3 id="左右都是开区间写法"><a href="#左右都是开区间写法" class="headerlink" title="左右都是开区间写法"></a>左右都是开区间写法</h3><p><strong><code>求最小：check(mid) == true 时更新 right = mid，反之更新 left = mid，最后返回 right。</code></strong></p><p><strong>返回的right是第一个符合check(mid)&#x3D;&#x3D;true的数值。如下图就是else中的部分，也就是nums[mid]&gt;&#x3D;target，也就是第一个大于等于target的数。</strong></p><p><img src="/2025/05/13/%E4%B8%8D%E5%90%8C%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image.png"></p><ul><li>注意这里返回的是right，可以这么想，[]区间最后状态是RL（一前一后），[)区间最后的状态是RL(两个只想同一个点)，()就是LR(一前一后)。</li></ul><h2 id="1-2-进阶"><a href="#1-2-进阶" class="headerlink" title="1.2 进阶"></a>1.2 进阶</h2><h3 id="658-找到-K-个最接近的元素"><a href="#658-找到-K-个最接近的元素" class="headerlink" title="658. 找到 K 个最接近的元素"></a>658. 找到 K 个最接近的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findClosestElements</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 二分查找+双指针，以x为边界进行划分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; x) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; x) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">                <span class="comment">//保证left永远是大于x的第一个位置的数</span></span><br><span class="line">                left = right + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//left永远是大于x的第一个位置的数，right&lt;=x</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> left;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ans.size() &lt; k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(arr[l] - x) &lt;= Math.abs(arr[r] - x)) &#123;</span><br><span class="line">                    ans.add(arr[l--]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.add(arr[r++]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ans.add(arr[l--]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.add(arr[r++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-求最小"><a href="#2-1-求最小" class="headerlink" title="2.1 求最小"></a>2.1 求最小</h2><p><strong>求最小和返回第一个符合要求的元素的题目是一致的。</strong></p><blockquote><p>题目求什么，就二分什么。</p><p>答疑</p><p>问：如何把二分答案与数组上的二分查找联系起来？</p><p>答：假设范围是 [2,3,4,5]，我们相当于在一个虚拟数组 [check(2),check(3),check(4),check(5)] 中二分找第一个（或者最后一个）值为 true 的 check(i)。这同样可以用红蓝染色法思考。</p><p>问：有些题目，明明 m 可以是答案，但却不在初始二分区间中。比如闭区间二分初始化 right&#x3D;m−1（或者开区间 right&#x3D;m），这不会算错吗？</p><p>答：不会算错。想一想，如果二分的 while 循环每次更新的都是 left，那么最终答案是什么？正好就是 m。一般地，如果一开始就能确定 m 一定可以满足题目要求，那么 m 是不需要在二分区间中的。换句话说，二分区间是「尚未确定是否满足题目要求」的数的范围。那些在区间外面的数，都是已确定的满足（不满足）题目要求的数。</p><p>问：什么是<strong>循环不变量</strong>？</p><p>答：想一想，对于求最小的题目，开区间二分的写法，为什么最终返回的是 right，而不是别的数？在初始化（循环之前）、循环中、循环结束后，都<strong>时时刻刻保证 check(right) &#x3D;&#x3D; true 和 check(left) &#x3D;&#x3D; false，这就叫循环不变量。</strong>&#x6839;据循环不变量，循环结束时 left + 1 &#x3D;&#x3D; right，那么 right 就是最小的满足要求的数（因为再 −1 就不满足要求了），所以答案是 right。</p><p>注：部分题目可以优化二分边界，减少二分次数，从而减少代码运行时间。对于初次接触二分答案的同学，无需强求自己写出最优的代码，设定一个比较大的二分上界也是可以的。</p></blockquote><h3 id="475-供暖器"><a href="#475-供暖器" class="headerlink" title="475.供暖器"></a>475.供暖器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRadius</span><span class="params">(<span class="type">int</span>[] houses, <span class="type">int</span>[] heaters)</span> &#123;</span><br><span class="line">        <span class="comment">// 写check函数的时候可以使用双指针来优化时间复杂度。</span></span><br><span class="line">        Arrays.sort(houses);</span><br><span class="line">        Arrays.sort(heaters);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//求最小：check(mid) == true 时更新 right = mid，反之更新 left = mid，最后返回 right。</span></span><br><span class="line">            <span class="keyword">if</span> (check(houses, heaters, mid))</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left= mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双指针进行优化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] houses, <span class="type">int</span>[] heaters, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> houses.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heaters.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; heaters[j] + r &lt; houses[i])</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n &amp;&amp; heaters[j] - r &lt;= houses[i] &amp;&amp; houses[i] &lt;= heaters[j] + r)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-求最大"><a href="#2-2-求最大" class="headerlink" title="2.2 求最大"></a>2.2 求最大</h2><p>求最大更新的时候它改变left和right的情况和求最小是相反的。</p><blockquote><p>在练习时，请注意「求最小」和「求最大」的二分写法上的区别。</p><p><strong>前面的「求最小」和二分查找求「排序数组中某元素的第一个位置」是类似的，按照红蓝染色法，左边是不满足要求的（红色），右边则是满足要求的（蓝色）。</strong></p><p><strong>「求最大」的题目则相反，左边是满足要求的（蓝色），右边是不满足要求的（红色）。这会导致二分写法和上面的「求最小」有一些区别。</strong></p><p>以开区间二分为例：</p><p><strong>求最小：check(mid) &#x3D;&#x3D; true 时更新 right &#x3D; mid，反之更新 left &#x3D; mid，最后返回 right。</strong></p><p><strong>求最大：check(mid) &#x3D;&#x3D; true 时更新 left &#x3D; mid，反之更新 right &#x3D; mid，最后返回 left。</strong></p><p><strong>对于开区间写法，简单来说 check(mid) &#x3D;&#x3D; true 时更新的是谁，最后就返回谁。相比其他二分写法，开区间写法不需要思考加一减一等细节，推荐使用开区间写二分。</strong></p></blockquote><h3 id="275-H指数2"><a href="#275-H指数2" class="headerlink" title="275.H指数2"></a>275.H指数2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> citations.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 这里要留出一个1</span></span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//求最大：check(mid) == true 时更新 left = mid，反之更新 right = mid，最后返回 left。</span></span><br><span class="line">            <span class="keyword">if</span> (check(citations, mid))</span><br><span class="line">                left = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对于开区间写法，简单来说 check(mid) == true 时更新的是谁，最后就返回谁。</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] citations, <span class="type">int</span> cnt)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> citations.length;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// h=0 总是合法</span></span><br><span class="line">        <span class="keyword">if</span> (n - cnt &gt;= <span class="number">0</span> &amp;&amp; citations[n - cnt] &gt;= cnt) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-最小化最大化"><a href="#2-4-最小化最大化" class="headerlink" title="2.4 最小化最大化"></a>2.4 最小化最大化</h2><h3 id="410-分割数组的最大值（很厉害的思路）"><a href="#410-分割数组的最大值（很厉害的思路）" class="headerlink" title="410.分割数组的最大值（很厉害的思路）"></a>410.分割数组的最大值（很厉害的思路）</h3><p>之前在dp中做过一遍，使用恰好分割k型dp做的，现在用二分查找来做：</p><p>如果同样是闭区间然后用3个if-else应该这么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">splitArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="comment">// 由于题目的返回要求：返回最小和的值</span></span><br><span class="line">        <span class="comment">// 最小和必然落在 [max(nums), sum(nums)] 之间</span></span><br><span class="line">        <span class="comment">// 我们可以使用二分来进行查找</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> getMax(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> getSum(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 淘汰算法</span></span><br><span class="line">            <span class="comment">// 我们由前向后对nums进行划分，使其子数组和 &lt;= mid，然后统计满足条件的数组数量</span></span><br><span class="line">            <span class="comment">// 若我们选的sum值过小，则满足条件的数量 &gt; m，目标值应落在 [mid+1, high]</span></span><br><span class="line">            <span class="comment">// 若我们选的sum值过大，则满足条件的数量 &lt;= m，目标值应落在 [low, mid]</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 初始至少有一个子数组</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">subSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">                subSum += num;</span><br><span class="line">                <span class="keyword">if</span> (subSum &gt; mid) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    subSum = num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意：这里不需要额外加1，因为count初始化为1已经包含了最后一个子数组</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; m) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// count&lt;=m是有可能符合条件的，所以不用mid-1</span></span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 辅助方法：计算数组最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; max) &#123;</span><br><span class="line">                max = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 辅助方法：计算数组总和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从蕾缪安的技能入手设想设计模式</title>
      <link href="/2025/05/08/%E4%BB%8E%E8%95%BE%E7%BC%AA%E5%AE%89%E7%9A%84%E6%8A%80%E8%83%BD%E5%85%A5%E6%89%8B%E8%AE%BE%E6%83%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/05/08/%E4%BB%8E%E8%95%BE%E7%BC%AA%E5%AE%89%E7%9A%84%E6%8A%80%E8%83%BD%E5%85%A5%E6%89%8B%E8%AE%BE%E6%83%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><strong><del>全程乱想,不涉及具体实现</del></strong></p><p><img src="/2025/05/08/%E4%BB%8E%E8%95%BE%E7%BC%AA%E5%AE%89%E7%9A%84%E6%8A%80%E8%83%BD%E5%85%A5%E6%89%8B%E8%AE%BE%E6%83%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/0.png" alt="img"></p><h2 id="1-初步构思"><a href="#1-初步构思" class="headerlink" title="1. 初步构思"></a>1. 初步构思</h2><p>假设原有基础代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 敌人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Enemy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> health;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takeDamage</span><span class="params">(<span class="type">int</span> damage)</span> &#123;</span><br><span class="line">        health -= damage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 干员基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> attackRange;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">(Enemy enemy)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(distanceTo(enemy) &lt;= attackRange) &#123;</span><br><span class="line">            enemy.takeDamage(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加通缉机制</strong></p><p><strong>适用设计模式</strong>：观察者模式 + 装饰器模式</p><p><strong>1. 添加观察者模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通缉状态接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">WantedStatusObserver</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onWantedStatusChanged</span><span class="params">(Enemy enemy, <span class="type">boolean</span> isWanted)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后的Enemy类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Enemy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;WantedStatusObserver&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isWanted;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(WantedStatusObserver o)</span> &#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWanted</span><span class="params">(<span class="type">boolean</span> status)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.isWanted = status;</span><br><span class="line">        notifyObservers(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(<span class="type">boolean</span> status)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(WantedStatusObserver o : observers) &#123;</span><br><span class="line">            o.onWantedStatusChanged(<span class="built_in">this</span>, status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 添加装饰器模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 攻击增强装饰器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WantedAttackDecorator</span> <span class="keyword">extends</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Operator wrapped;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WantedAttackDecorator</span><span class="params">(Operator operator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.wrapped = operator;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">(Enemy enemy)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(enemy.isWanted()) &#123;</span><br><span class="line">            <span class="comment">// 无视距离攻击</span></span><br><span class="line">            enemy.takeDamage(<span class="number">15</span>); <span class="comment">// 增强伤害</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wrapped.attack(enemy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 最终调用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">Operator</span> <span class="variable">baseOperator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sniper</span>(); <span class="comment">// 原有狙击干员</span></span><br><span class="line"><span class="type">Operator</span> <span class="variable">reunion</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WantedAttackDecorator</span>(baseOperator);</span><br><span class="line"></span><br><span class="line"><span class="type">Enemy</span> <span class="variable">enemy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enemy</span>();</span><br><span class="line">enemy.addObserver((e, status) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(status) reunion.attack(e); <span class="comment">// 状态变化时触发</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当满足通缉条件时</span></span><br><span class="line">enemy.setWanted(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h2 id="2-改进思路"><a href="#2-改进思路" class="headerlink" title="2. 改进思路"></a>2. 改进思路</h2><p>现在请想象一个问题，之后我想要添加其他特性的时候不是还要直接在enemy中新增东西（如观察者列表、isWanted标签）吗？这也太不优雅了，如何改进？</p><h3 id="解决方案：组件模式-事件总线"><a href="#解决方案：组件模式-事件总线" class="headerlink" title="解决方案：组件模式 + 事件总线"></a>解决方案：组件模式 + 事件总线</h3><h4 id="1-核心架构"><a href="#1-核心架构" class="headerlink" title="1. 核心架构"></a>1. 核心架构</h4><p><img src="/2025/05/08/%E4%BB%8E%E8%95%BE%E7%BC%AA%E5%AE%89%E7%9A%84%E6%8A%80%E8%83%BD%E5%85%A5%E6%89%8B%E8%AE%BE%E6%83%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.png" alt="img"></p><h4 id="2-实现代码"><a href="#2-实现代码" class="headerlink" title="2. 实现代码"></a>2. 实现代码</h4><p><strong>（1）基础组件接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有组件实现的基类接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event event)</span>; <span class="comment">// 接收事件总线消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）改造后的Enemy类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Enemy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Component&gt; components = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 动态添加组件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addComponent</span><span class="params">(String key, Component comp)</span> &#123;</span><br><span class="line">        components.put(key, comp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 触发事件（不再直接维护观察者）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireEvent</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">        EventBus.publish(event); <span class="comment">// 将事件交给全局总线</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）事件总线系统</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, List&lt;Consumer&lt;Event&gt;&gt;&gt; handlers = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册事件处理器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Event</span>&gt; <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(Class&lt;T&gt; type, Consumer&lt;T&gt; handler)</span> &#123;</span><br><span class="line">        handlers.computeIfAbsent(type, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())</span><br><span class="line">                .add(event -&gt; handler.accept((T)event));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发布事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">        handlers.getOrDefault(event.getClass(), Collections.emptyList())</span><br><span class="line">                .forEach(handler -&gt; handler.accept(event));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、添加新特性示例"><a href="#三、添加新特性示例" class="headerlink" title="三、添加新特性示例"></a>三、添加新特性示例</h3><h4 id="案例：添加通缉系统（无需修改Enemy类）"><a href="#案例：添加通缉系统（无需修改Enemy类）" class="headerlink" title="案例：添加通缉系统（无需修改Enemy类）"></a>案例：添加通缉系统（无需修改Enemy类）</h4><p><strong>（1）定义通缉事件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WantedEvent</span> <span class="keyword">extends</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Enemy target;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> isWanted;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WantedEvent</span><span class="params">(Enemy target, <span class="type">boolean</span> status)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">        <span class="built_in">this</span>.isWanted = status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）实现通缉组件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WantedComponent</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(event <span class="keyword">instanceof</span> WantedEvent we) &#123;</span><br><span class="line">            <span class="comment">// 处理通缉逻辑</span></span><br><span class="line">            <span class="keyword">if</span>(we.isWanted) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始追踪目标：&quot;</span> + we.target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）注册到Enemy</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Enemy</span> <span class="variable">enemy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enemy</span>();</span><br><span class="line">enemy.addComponent(<span class="string">&quot;wanted&quot;</span>, <span class="keyword">new</span> <span class="title class_">WantedComponent</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发通缉事件</span></span><br><span class="line">enemy.fireEvent(<span class="keyword">new</span> <span class="title class_">WantedEvent</span>(enemy, <span class="literal">true</span>));</span><br></pre></td></tr></table></figure><p><strong>（4）其他系统监听事件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 攻击系统监听通缉事件</span></span><br><span class="line">EventBus.subscribe(WantedEvent.class, event -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(event.isWanted) &#123;</span><br><span class="line">        AttackSystem.focusTarget(event.target); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.3 计算机的性能指标</title>
      <link href="/2025/04/28/bitset%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/04/28/bitset%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="bitset方法"><a href="#bitset方法" class="headerlink" title="bitset方法"></a>bitset方法</h2><p>代码参考：<a href="https://www.runoob.com/java/java-bitset-class.html">https://www.runoob.com/java/java-bitset-class.html</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BitSetDemo</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">     <span class="type">BitSet</span> <span class="variable">bits1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>(<span class="number">16</span>);</span><br><span class="line">     <span class="type">BitSet</span> <span class="variable">bits2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>(<span class="number">16</span>);</span><br><span class="line">      </span><br><span class="line">     <span class="comment">// set some bits</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((i%<span class="number">2</span>) == <span class="number">0</span>) bits1.set(i);</span><br><span class="line">        <span class="keyword">if</span>((i%<span class="number">5</span>) != <span class="number">0</span>) bits2.set(i);</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(<span class="string">&quot;Initial pattern in bits1: &quot;</span>);</span><br><span class="line">     System.out.println(bits1);</span><br><span class="line">     System.out.println(<span class="string">&quot;\nInitial pattern in bits2: &quot;</span>);</span><br><span class="line">     System.out.println(bits2);</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// AND bits</span></span><br><span class="line">     bits2.and(bits1);</span><br><span class="line">     System.out.println(<span class="string">&quot;\nbits2 AND bits1: &quot;</span>);</span><br><span class="line">     System.out.println(bits2);</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// OR bits</span></span><br><span class="line">     bits2.or(bits1);</span><br><span class="line">     System.out.println(<span class="string">&quot;\nbits2 OR bits1: &quot;</span>);</span><br><span class="line">     System.out.println(bits2);</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// XOR bits</span></span><br><span class="line">     bits2.xor(bits1);</span><br><span class="line">     System.out.println(<span class="string">&quot;\nbits2 XOR bits1: &quot;</span>);</span><br><span class="line">     System.out.println(bits2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Initial pattern in bits1:</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>&#125;</span><br><span class="line"></span><br><span class="line">Initial pattern in bits2:</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>&#125;</span><br><span class="line"></span><br><span class="line">bits2 AND bits1:</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">14</span>&#125;</span><br><span class="line"></span><br><span class="line">bits2 OR bits1:</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>&#125;</span><br><span class="line"></span><br><span class="line">bits2 XOR bits1:</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>XOR是异或，AND是与，OR是或。要他们比较的是对应索引是否为true。</li></ul><h2 id="bitset底层"><a href="#bitset底层" class="headerlink" title="bitset底层"></a>bitset底层</h2><p>详情参考：<a href="https://blog.csdn.net/jiangnan2014/article/details/53735429">https://blog.csdn.net/jiangnan2014/article/details/53735429</a></p><h3 id="long的含义？"><a href="#long的含义？" class="headerlink" title="long的含义？"></a>long的含义？</h3><p>根据上文中的代码：</p><p>看到</p><p><img src="/2025/04/28/bitset%E4%BD%BF%E7%94%A8/image-1.png"></p><p>long的含义如下，可以看到是从下标0开始计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bits1 (偶数位):</span><br><span class="line">位索引: 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0</span><br><span class="line">值:    0  1  0  1  0  1 0 1 0 1 0 1 0 1 0 1</span><br><span class="line">       |  |  |  |  |  | | | | | | | | | | |</span><br><span class="line">       v  v  v  v  v  v v v v v v v v v v v</span><br><span class="line">long 值: 0x0000000000005555 = （21845）10进制</span><br></pre></td></tr></table></figure><p>所以不能set负数，如bits1.set(-1)。</p><p><img src="/2025/04/28/bitset%E4%BD%BF%E7%94%A8/image.png"></p><h3 id="为什么使用long-而不是long？"><a href="#为什么使用long-而不是long？" class="headerlink" title="为什么使用long[]而不是long？"></a>为什么使用long[]而不是long？</h3><ol><li><p>高效位操作​：</p><ul><li><p><code>long</code> 是 64 位，可以一次性处理 64 个位的逻辑运算（如 <code>AND</code>、<code>OR</code>、<code>XOR</code>），比逐位操作更高效。</p></li><li><p>CPU 指令集对 <code>long</code> 的位运算有原生支持，速度极快。</p></li></ul></li><li><p>内存紧凑​：</p><ul><li><p>用 <code>long[]</code> 存储可以最小化内存占用。例如：</p><ul><li><code>BitSet(64)</code> 只需 1 个 <code>long</code>（8 字节），而用 <code>boolean[]</code> 需要 64 字节（每个 <code>boolean</code> 占 1 字节）。</li></ul></li><li><p>对稀疏位集（大部分位为 <code>0</code>），<code>BitSet</code> 会动态压缩存储（如全 <code>0</code> 的 <code>long</code> 可能被忽略）。</p></li></ul></li><li><p>动态扩容​：</p><ul><li><p><code>words</code> 数组会按需扩容。例如：</p><ul><li><p>初始 <code>BitSet(16)</code> 分配 <code>long[1]</code>。</p></li><li><p>设置 <code>bits.set(100)</code> 后，<code>words</code> 扩容为 <code>long[2]</code>（因为 <code>100 / 64 = 1</code>，需要 <code>words[0]</code> 和 <code>words[1]</code>）。</p></li></ul></li></ul></li></ol><h2 id="力扣算法应用"><a href="#力扣算法应用" class="headerlink" title="力扣算法应用"></a>力扣算法应用</h2><h3 id="1930-长度为3的不同回文子序列"><a href="#1930-长度为3的不同回文子序列" class="headerlink" title="1930.长度为3的不同回文子序列"></a>1930.长度为3的不同回文子序列</h3><ul><li>cardinality()返回bitset中为索引对应为true的个数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPalindromicSubsequence</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] pre = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] suf = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        BitSet[] has = <span class="keyword">new</span> <span class="title class_">BitSet</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            has[i] = <span class="keyword">new</span> <span class="title class_">BitSet</span>(<span class="number">26</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize suf with counts from s[1..n-1]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            suf[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// Update pre with s[i-1]</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">leftChar</span> <span class="operator">=</span> s.charAt(i - <span class="number">1</span>);</span><br><span class="line">            pre[leftChar - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update suf by removing s[i] (since it&#x27;s now the middle character)</span></span><br><span class="line">            <span class="comment">// 每次右移j的过程中，后缀中统计的的个数会转移到前缀。</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">middleChar</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            suf[middleChar - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check for all possible left and right characters</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pre[j] &gt; <span class="number">0</span> &amp;&amp; suf[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 以当前元素为中心时，两侧具有相同的元素</span></span><br><span class="line">                    has[middleChar - <span class="string">&#x27;a&#x27;</span>].set(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Count the number of unique palindromic subsequences</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (BitSet bitSet : has) &#123;</span><br><span class="line">            <span class="comment">// 返回bitset中为索引对应值true的个数。</span></span><br><span class="line">            ans += bitSet.cardinality();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>参考：<a href="https://blog.csdn.net/jiangnan2014/article/details/53735429">https://blog.csdn.net/jiangnan2014/article/details/53735429</a></p><p>常见的应用是那些需要对海量数据进行一些统计工作的时候，比如日志分析、用户数统计等等</p><p>&#x20;   如统计40亿个数据中没有出现的数据，将40亿个不同数据进行排序等。<br>&#x20;   现在有1千万个随机数，随机数的范围在1到1亿之间。现在要求写出一种算法，将1到1亿之间没有在随机数中的数求出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> util;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BitSetDemo</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 求一个字符串包含的char</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">containChars</span><span class="params">(String str)</span> &#123;</span><br><span class="line">                <span class="type">BitSet</span> <span class="variable">used</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">                        used.set(str.charAt(i)); <span class="comment">// set bit for char</span></span><br><span class="line"> </span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> used.size();</span><br><span class="line">                System.out.println(size);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (used.get(i)) &#123;</span><br><span class="line">                                sb.append((<span class="type">char</span>) i);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">                System.out.println(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 求素数 有无限个。一个大于1的自然数，如果除了1和它本身外，不能被其他自然数整除(除0以外）的数称之为素数(质数） 否则称为合数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">computePrime</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">BitSet</span> <span class="variable">sieve</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>(<span class="number">1024</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> sieve.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; size; i++)</span><br><span class="line">                        sieve.set(i);</span><br><span class="line">                <span class="type">int</span> <span class="variable">finalBit</span> <span class="operator">=</span> (<span class="type">int</span>) Math.sqrt(sieve.size());</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; finalBit; i++)</span><br><span class="line">                        <span class="keyword">if</span> (sieve.get(i))</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * i; j &lt; size; j += i)</span><br><span class="line">                                        sieve.clear(j);</span><br><span class="line"> </span><br><span class="line">                <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sieve.get(i)) &#123;</span><br><span class="line">                                System.out.printf(<span class="string">&quot;%5d&quot;</span>, i);</span><br><span class="line">                                <span class="keyword">if</span> (++counter % <span class="number">15</span> == <span class="number">0</span>)</span><br><span class="line">                                        System.out.println();</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 进行数字排序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sortArray</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">423</span>, <span class="number">700</span>, <span class="number">9999</span>, <span class="number">2323</span>, <span class="number">356</span>, <span class="number">6400</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span> &#125;;</span><br><span class="line">                <span class="type">BitSet</span> <span class="variable">bitSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>(<span class="number">2</span> &lt;&lt; <span class="number">13</span>);</span><br><span class="line">                <span class="comment">// 虽然可以自动扩容，但尽量在构造时指定估算大小,默认为64</span></span><br><span class="line">                System.out.println(<span class="string">&quot;BitSet size: &quot;</span> + bitSet.size());</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                        bitSet.set(array[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//剔除重复数字后的元素个数</span></span><br><span class="line">                <span class="type">int</span> bitLen=bitSet.cardinality();        </span><br><span class="line"> </span><br><span class="line">                <span class="comment">//进行排序，即把bit为true的元素复制到另一个数组</span></span><br><span class="line">                <span class="type">int</span>[] orderedArray = <span class="keyword">new</span> <span class="title class_">int</span>[bitLen];</span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bitSet.nextSetBit(<span class="number">0</span>); i &gt;= <span class="number">0</span>; i = bitSet.nextSetBit(i + <span class="number">1</span>)) &#123;</span><br><span class="line">                        orderedArray[k++] = i;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                System.out.println(<span class="string">&quot;After ordering: &quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bitLen; i++) &#123;</span><br><span class="line">                        System.out.print(orderedArray[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                System.out.println(<span class="string">&quot;iterate over the true bits in a BitSet&quot;</span>);</span><br><span class="line">                <span class="comment">//或直接迭代BitSet中bit为true的元素iterate over the true bits in a BitSet</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bitSet.nextSetBit(<span class="number">0</span>); i &gt;= <span class="number">0</span>; i = bitSet.nextSetBit(i + <span class="number">1</span>)) &#123;</span><br><span class="line">                        System.out.print(i+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将BitSet对象转化为ByteArray</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> bitSet</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] bitSet2ByteArray(BitSet bitSet) &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[bitSet.size() / <span class="number">8</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bitSet.size(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i / <span class="number">8</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">7</span> - i % <span class="number">8</span>;</span><br><span class="line">            bytes[index] |= (bitSet.get(i) ? <span class="number">1</span> : <span class="number">0</span>) &lt;&lt; offset;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将ByteArray对象转化为BitSet</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BitSet <span class="title function_">byteArray2BitSet</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="type">BitSet</span> <span class="variable">bitSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>(bytes.length * <span class="number">8</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">7</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                bitSet.set(index++, (bytes[i] &amp; (<span class="number">1</span> &lt;&lt; j)) &gt;&gt; j == <span class="number">1</span> ? <span class="literal">true</span></span><br><span class="line">                        : <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bitSet;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 简单使用示例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">simpleExample</span><span class="params">()</span> &#123;</span><br><span class="line">                String names[] = &#123; <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Source&quot;</span>, <span class="string">&quot;and&quot;</span>, <span class="string">&quot;Support&quot;</span> &#125;;</span><br><span class="line">                <span class="type">BitSet</span> <span class="variable">bits</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = names.length; i &lt; n; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((names[i].length() % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                                bits.set(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                System.out.println(bits);</span><br><span class="line">                System.out.println(<span class="string">&quot;Size : &quot;</span> + bits.size());</span><br><span class="line">                System.out.println(<span class="string">&quot;Length: &quot;</span> + bits.length());</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = names.length; i &lt; n; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!bits.get(i)) &#123;</span><br><span class="line">                                System.out.println(names[i] + <span class="string">&quot; is odd&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">BitSet</span> <span class="variable">bites</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>();</span><br><span class="line">                bites.set(<span class="number">0</span>);</span><br><span class="line">                bites.set(<span class="number">1</span>);</span><br><span class="line">                bites.set(<span class="number">2</span>);</span><br><span class="line">                bites.set(<span class="number">3</span>);</span><br><span class="line">                bites.andNot(bits);</span><br><span class="line">                System.out.println(bites);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">                <span class="comment">//BitSet使用示例</span></span><br><span class="line">                BitSetDemo.containChars(<span class="string">&quot;How do you do? 你好呀&quot;</span>);</span><br><span class="line">                BitSetDemo.computePrime();</span><br><span class="line">                BitSetDemo.sortArray();</span><br><span class="line">                BitSetDemo.simpleExample();</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                <span class="comment">//BitSet与Byte数组互转示例</span></span><br><span class="line">                <span class="type">BitSet</span> <span class="variable">bitSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>();</span><br><span class="line">        bitSet.set(<span class="number">3</span>, <span class="literal">true</span>);</span><br><span class="line">        bitSet.set(<span class="number">98</span>, <span class="literal">true</span>);</span><br><span class="line">        System.out.println(bitSet.size()+<span class="string">&quot;,&quot;</span>+bitSet.cardinality());</span><br><span class="line">        <span class="comment">//将BitSet对象转成byte数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = BitSetDemo.bitSet2ByteArray(bitSet);</span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//在将byte数组转回来</span></span><br><span class="line">        bitSet = BitSetDemo.byteArray2BitSet(bytes);</span><br><span class="line">        System.out.println(bitSet.size()+<span class="string">&quot;,&quot;</span>+bitSet.cardinality());</span><br><span class="line">        System.out.println(bitSet.get(<span class="number">3</span>));</span><br><span class="line">        System.out.println(bitSet.get(<span class="number">98</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bitSet.nextSetBit(<span class="number">0</span>); i &gt;= <span class="number">0</span>; i = bitSet.nextSetBit(i + <span class="number">1</span>)) &#123;</span><br><span class="line">                        System.out.print(i+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码展示了 Java 中 <code>BitSet</code> 类的多种实际用途，主要体现了以下几个核心作用：</p><p><strong>1. 高效存储和操作布尔值集合</strong></p><p><code>BitSet</code> 用位（<code>0/1</code>）代替布尔数组，​极大节省内存​：</p><ul><li><p>示例​：<code>containChars()</code> 方法统计字符串中的唯一字符。</p><ul><li><p>每个字符的 ASCII 值作为索引，用 1 个 <code>BitSet</code> 代替 <code>boolean[65536]</code>。</p></li><li><p>内存占用从 64KB 降至 8KB​（假设存储所有 ASCII 字符）。</p></li></ul></li></ul><p><strong>2. 快速去重和排序</strong></p><ul><li><p>示例​：<code>sortArray()</code> 方法对整数数组去重并排序。</p><ul><li><p>将数字直接作为索引设置到 <code>BitSet</code> 中（如 <code>bitSet.set(423)</code>）。</p></li><li><p>自动去重（重复数字多次设置同一位置）。</p></li><li><p>通过 <code>nextSetBit()</code> 遍历已设置的位，​天然有序输出​（升序）。</p></li></ul></li></ul><p><strong>3. 数学算法优化（如素数筛）​</strong></p><ul><li><p>示例​：<code>computePrime()</code> 实现埃拉托斯特尼筛法。</p><ul><li><p>用 <code>BitSet</code> 标记非素数，​比数组更省空间。</p></li><li><p>位操作（<code>set</code>&#x2F;<code>clear</code>）比数组赋值更快。</p></li></ul></li></ul><p><strong>4. 二进制与字节数据转换</strong></p><ul><li><p>示例​：<code>bitSet2ByteArray()</code> 和 <code>byteArray2BitSet()</code>。</p><ul><li><p>序列化​：将 <code>BitSet</code> 转换为紧凑的 <code>byte[]</code>（如网络传输）。</p></li><li><p>反序列化​：从 <code>byte[]</code> 恢复 <code>BitSet</code> 状态。</p></li></ul></li></ul><p><strong>5. 集合运算（交集、差集等）​</strong></p><ul><li><p>示例​：<code>simpleExample()</code> 中的 <code>andNot()</code> 操作。</p><ul><li>支持逻辑运算（<code>AND</code>、<code>OR</code>、<code>XOR</code>），适合处理权限位掩码等场景</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> bitset </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写大小根堆</title>
      <link href="/2025/04/27/%E6%89%8B%E5%86%99%E5%A4%A7%E5%B0%8F%E6%A0%B9%E5%A0%86/"/>
      <url>/2025/04/27/%E6%89%8B%E5%86%99%E5%A4%A7%E5%B0%8F%E6%A0%B9%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h2 id="215-数组中的第k个最大值-手写大根堆"><a href="#215-数组中的第k个最大值-手写大根堆" class="headerlink" title="215.数组中的第k个最大值(手写大根堆)"></a>215.数组中的第k个最大值(手写大根堆)</h2><h3 id="构造大根堆"><a href="#构造大根堆" class="headerlink" title="构造大根堆"></a>构造大根堆</h3><p>力扣上的一道题，手写大根堆实现，或者直接用PriorityQueue。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    /​**​</span><br><span class="line">     * 找到数组中第 k 大的元素（使用最大堆实现）</span><br><span class="line">     * <span class="meta">@param</span> nums 输入数组</span><br><span class="line">     * <span class="meta">@param</span> k 要找的第 k 大的元素</span><br><span class="line">     * <span class="meta">@return</span> 第 k 大的元素</span><br><span class="line">     */</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 首先构建最大堆</span></span><br><span class="line">        buildMaxHeap(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 执行 k-1 次移除堆顶元素的操作</span></span><br><span class="line">        <span class="comment">// 每次移除当前最大值后，重新调整堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 将当前堆顶元素（最大值）与堆末尾元素交换</span></span><br><span class="line">            swap(nums, <span class="number">0</span>, --len);</span><br><span class="line">            <span class="comment">// 对新的堆顶元素进行堆调整，保持最大堆性质</span></span><br><span class="line">            maxHeapify(nums, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 经过 k-1 次移除后，堆顶就是第 k 大的元素</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /​**​</span><br><span class="line">     * 构建最大堆</span><br><span class="line">     * <span class="meta">@param</span> nums 待构建的数组</span><br><span class="line">     */</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 从最后一个非叶子节点开始，自底向上构建最大堆</span></span><br><span class="line">        <span class="comment">// 最后一个非叶子节点的索引是 size/2 - 1(-1是因为下标0开始)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxHeapify(nums, i, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /​**​</span><br><span class="line">     * 调整以 i 为根的子树，使其满足最大堆性质</span><br><span class="line">     * <span class="meta">@param</span> nums 堆数组</span><br><span class="line">     * <span class="meta">@param</span> i 当前要调整的节点索引</span><br><span class="line">     * <span class="meta">@param</span> heapSize 当前堆的大小</span><br><span class="line">     */</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">maxHeapify</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;        <span class="comment">// 初始化最大值为当前节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;  <span class="comment">// 左子节点索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>; <span class="comment">// 右子节点索引</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果左子节点存在且大于当前最大值</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; nums[largest] &lt; nums[left]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果右子节点存在且大于当前最大值</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; nums[largest] &lt; nums[right]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果最大值不是当前节点，需要交换并递归调整</span></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(nums, largest, i);</span><br><span class="line">            <span class="comment">// 递归调整被交换的子节点</span></span><br><span class="line">            <span class="comment">// 向下递归</span></span><br><span class="line">            maxHeapify(nums, largest, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /​**​</span><br><span class="line">     * 交换数组中两个元素的位置</span><br><span class="line">     * <span class="meta">@param</span> nums 数组</span><br><span class="line">     * <span class="meta">@param</span> l 第一个元素的索引</span><br><span class="line">     * <span class="meta">@param</span> r 第二个元素的索引</span><br><span class="line">     */</span><br><span class="line">    swap(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[l];</span><br><span class="line">        nums[l] = nums[r];</span><br><span class="line">        nums[r] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大根堆删除元素"><a href="#大根堆删除元素" class="headerlink" title="大根堆删除元素"></a>大根堆删除元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> heapSize; <span class="comment">// 当前堆的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化堆大小</span></span><br><span class="line">        heapSize = nums.length;</span><br><span class="line">        <span class="comment">// 构建最大堆</span></span><br><span class="line">        buildMaxHeap(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行 k-1 次移除堆顶元素的操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 删除堆顶元素（最大值）</span></span><br><span class="line">            deleteRoot(nums);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 经过 k-1 次移除后，堆顶就是第 k 大的元素</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除堆顶元素（最大值）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 堆数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteRoot</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (heapSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Heap is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将堆顶元素与最后一个元素交换</span></span><br><span class="line">        swap(nums, <span class="number">0</span>, heapSize - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 减小堆大小（相当于删除原堆顶）</span></span><br><span class="line">        heapSize--;</span><br><span class="line">        <span class="comment">// 从新的堆顶开始调整堆</span></span><br><span class="line">        maxHeapify(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定索引的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 堆数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 要删除的节点索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= heapSize) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index out of heap bounds&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将要删除的节点与最后一个节点交换</span></span><br><span class="line">        swap(nums, i, heapSize - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 减小堆大小</span></span><br><span class="line">        heapSize--;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从被删除节点的位置开始调整堆</span></span><br><span class="line">        <span class="comment">// 需要同时考虑向上和向下调整的可能性</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; heapSize) &#123; <span class="comment">// 确保交换后的节点仍在堆范围内</span></span><br><span class="line">            <span class="comment">// 向上调整（如果新值比父节点大）</span></span><br><span class="line">            siftUp(nums, i);</span><br><span class="line">            <span class="comment">// 向下调整（如果新值比子节点小）</span></span><br><span class="line">            maxHeapify(nums, i, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向上调整（用于删除节点后可能需要的调整）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 堆数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 要调整的节点索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[parent]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, parent);</span><br><span class="line">            i = parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原有的 buildMaxHeap、maxHeapify 和 swap 方法保持不变</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        heapSize = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> heapSize / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxHeapify(nums, i, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">maxHeapify</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; nums[left] &gt; nums[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; nums[right] &gt; nums[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(nums, i, largest);</span><br><span class="line">            maxHeapify(nums, largest, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[l];</span><br><span class="line">        nums[l] = nums[r];</span><br><span class="line">        nums[r] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造小根堆"><a href="#构造小根堆" class="headerlink" title="构造小根堆"></a>构造小根堆</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到数组中第 k 小的元素（使用最小堆实现）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 输入数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 要找的第 k 小的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 第 k 小的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthSmallest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 首先构建最小堆</span></span><br><span class="line">        buildMinHeap(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 执行 k-1 次移除堆顶元素的操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 将当前堆顶元素（最小值）与堆末尾元素交换</span></span><br><span class="line">            swap(nums, <span class="number">0</span>, --len);</span><br><span class="line">            <span class="comment">// 对新的堆顶元素进行堆调整，保持最小堆性质</span></span><br><span class="line">            minHeapify(nums, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 经过 k-1 次移除后，堆顶就是第 k 小的元素</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建最小堆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 待构建的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildMinHeap</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 从最后一个非叶子节点开始，自底向上构建最小堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            minHeapify(nums, i, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整以 i 为根的子树，使其满足最小堆性质</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 堆数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 当前要调整的节点索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heapSize 当前堆的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">minHeapify</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">smallest</span> <span class="operator">=</span> i;       <span class="comment">// 初始化最小值为当前节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;  <span class="comment">// 左子节点索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>; <span class="comment">// 右子节点索引</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果左子节点存在且小于当前最小值</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; nums[smallest] &gt; nums[left]) &#123;</span><br><span class="line">            smallest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果右子节点存在且小于当前最小值</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; nums[smallest] &gt; nums[right]) &#123;</span><br><span class="line">            smallest = right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果最小值不是当前节点，需要交换并递归调整</span></span><br><span class="line">        <span class="keyword">if</span> (smallest != i) &#123;</span><br><span class="line">            swap(nums, smallest, i);</span><br><span class="line">            <span class="comment">// 递归调整被交换的子节点</span></span><br><span class="line">            minHeapify(nums, smallest, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换数组中两个元素的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l 第一个元素的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r 第二个元素的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[l];</span><br><span class="line">        nums[l] = nums[r];</span><br><span class="line">        nums[r] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小根堆删除元素"><a href="#小根堆删除元素" class="headerlink" title="小根堆删除元素"></a>小根堆删除元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinHeap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] heap;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinHeap</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.heap = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建堆的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinHeap</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = array.length;</span><br><span class="line">        <span class="built_in">this</span>.size = array.length;</span><br><span class="line">        <span class="built_in">this</span>.heap = Arrays.copyOf(array, capacity);</span><br><span class="line">        buildMinHeap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建小根堆</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildMinHeap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            minHeapify(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 堆调整（向下调整）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">minHeapify</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">smallest</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; size &amp;&amp; heap[left] &lt; heap[smallest]) &#123;</span><br><span class="line">            smallest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; heap[right] &lt; heap[smallest]) &#123;</span><br><span class="line">            smallest = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (smallest != i) &#123;</span><br><span class="line">            swap(i, smallest);</span><br><span class="line">            minHeapify(smallest); <span class="comment">// 递归调整受影响的子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向上调整</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (heap[i] &gt;= heap[parent]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(i, parent);</span><br><span class="line">            i = parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> heap[i];</span><br><span class="line">        heap[i] = heap[j];</span><br><span class="line">        heap[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除堆顶元素（最小值）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Heap is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> heap[<span class="number">0</span>];</span><br><span class="line">        heap[<span class="number">0</span>] = heap[size - <span class="number">1</span>]; <span class="comment">// 用最后一个元素替换堆顶</span></span><br><span class="line">        size--;</span><br><span class="line">        minHeapify(<span class="number">0</span>); <span class="comment">// 从根节点开始向下调整</span></span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定索引的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index out of heap bounds&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将要删除的节点与最后一个节点交换</span></span><br><span class="line">        heap[index] = heap[size - <span class="number">1</span>];</span><br><span class="line">        size--;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 需要同时考虑向上和向下调整</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; size) &#123; <span class="comment">// 确保交换后的节点仍在堆范围内</span></span><br><span class="line">            <span class="comment">// 如果新值比父节点小，向上调整</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt; <span class="number">0</span> &amp;&amp; heap[index] &lt; heap[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">                siftUp(index);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 否则向下调整</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                minHeapify(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Heap is full&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        heap[size] = value;</span><br><span class="line">        siftUp(size); <span class="comment">// 向上调整新插入的节点</span></span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取堆顶元素（不删除）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Heap is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么删除节点时既要向上调整又要向下调整，而构造堆时只需向下调整？"><a href="#为什么删除节点时既要向上调整又要向下调整，而构造堆时只需向下调整？" class="headerlink" title="为什么删除节点时既要向上调整又要向下调整，而构造堆时只需向下调整？"></a><strong>为什么删除节点时既要向上调整又要向下调整，而构造堆时只需向下调整？</strong></h2><h4 id="1-堆的构造过程（自底向上-向下调整）"><a href="#1-堆的构造过程（自底向上-向下调整）" class="headerlink" title="1. 堆的构造过程（自底向上 + 向下调整）"></a><strong>1. 堆的构造过程（自底向上 + 向下调整）</strong></h4><ul><li><strong>构造堆的顺序</strong>：从最后一个非叶子节点开始，<strong>自底向上</strong>依次调整每个子树。</li><li>为什么只需向下调整？<ul><li><strong>父节点已经处理过</strong>：当调整节点 <code>i</code> 时，它的父节点（<code>(i-1)/2</code>）已经在前面的步骤中调整完毕，并且满足堆性质。因此，交换后只需要检查子树是否需要调整（即向下调整）。</li><li><strong>自底向上的保证</strong>：由于是从最后一个非叶子节点开始向上处理，每个节点的子树在调整时，其父节点已经满足堆性质，因此不需要向上调整。</li></ul></li></ul><h4 id="2-删除节点时的调整（可能向上或向下）"><a href="#2-删除节点时的调整（可能向上或向下）" class="headerlink" title="2. 删除节点时的调整（可能向上或向下）"></a><strong>2. 删除节点时的调整（可能向上或向下）</strong></h4><ul><li><strong>删除堆顶（最小值&#x2F;最大值）</strong>：<ul><li>直接把最后一个节点放到堆顶，然后 <strong>向下调整（<code>minHeapify</code>）</strong>，因为新堆顶可能比子节点大（小根堆）或小（大根堆）。</li><li><strong>不需要向上调整</strong>，因为堆顶没有父节点。</li></ul></li><li><strong>删除任意节点</strong>：<ul><li>用最后一个节点替换被删除的节点，此时：<ul><li><strong>如果新值比父节点小（小根堆）</strong>：需要 <strong>向上调整（<code>siftUp</code>）</strong>，因为它可能破坏父节点的堆性质。</li><li><strong>如果新值比子节点大（小根堆）</strong>：需要 <strong>向下调整（<code>minHeapify</code>）</strong>，因为它可能破坏子树的堆性质。</li></ul></li><li>为什么不能只向下调整？<ul><li>如果新值比父节点小（比如在小根堆中），它可能比父节点更小，这时必须向上调整，否则堆性质会被破坏。</li></ul></li><li>为什么不能只向上调整？<ul><li>如果新值比子节点大（比如在小根堆中），它可能比子节点更大，这时必须向下调整，否则堆性质会被破坏。</li></ul></li></ul></li></ul><h2 id="为什么删除节点后不能直接从最后一个非叶子节点开始重新建堆？"><a href="#为什么删除节点后不能直接从最后一个非叶子节点开始重新建堆？" class="headerlink" title="为什么删除节点后不能直接从最后一个非叶子节点开始重新建堆？"></a><strong>为什么删除节点后不能直接从最后一个非叶子节点开始重新建堆？</strong></h2><p><strong>在删除节点后，直接对整个数组重新执行 <code>buildMaxHeap</code>（即从最后一个非叶子节点开始重新调整堆）</strong>。这种方法理论上可行，但<strong>效率太低</strong>，原因如下：</p><ul><li><strong>重构方法</strong>（重新 <code>buildMaxOrMinHeap</code>）：<br>每次删除后都花费 ​<strong>​O(n)​</strong>​ 时间重建堆，如果删除 <code>k</code> 次，总时间会是 ​<strong>​O(kn)​</strong>​，效率太低。</li><li><strong>标准方法</strong>（仅调整受影响部分）：<br>每次删除后只需 ​<strong>​O(log n)​</strong>​ 时间调整，删除 <code>k</code> 次总时间是 ​<strong>​O(k log n)​</strong>​，效率更高。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态内部类</title>
      <link href="/2025/04/27/%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2025/04/27/%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="类的初始化过程及内部静态类的初始化时机"><a href="#类的初始化过程及内部静态类的初始化时机" class="headerlink" title="类的初始化过程及内部静态类的初始化时机"></a><strong>类的初始化过程及内部静态类的初始化时机</strong></h2><p>在Java中，类的初始化遵循严格的JVM规范（JLS §12.4）。以下是详细分析：</p><p><strong>1. 类的初始化阶段（Class Initialization）</strong><br>类的初始化发生在首次主动使用时（如创建实例、访问静态成员等），按以下顺序执行：</p><ol><li><p>加载（Loading）<br>JVM将.class文件加载到内存，生成<code>Class</code>对象（仅一次）。</p></li><li><p>链接（Linking）<br>• 验证（Verification）：检查字节码合法性。  </p><p>• 准备（Preparation）：为静态变量分配内存并赋默认值（如<code>int</code>初始化为<code>0</code>）。  </p><p>• 解析（Resolution）：将符号引用转为直接引用。</p></li><li><p>初始化（Initialization）<br>执行静态变量赋值和静态代码块（<code>static&#123;&#125;</code>），按代码顺序执行。</p></li></ol><p><strong>2. 内部静态类的初始化时机</strong><br>静态嵌套类（Static Nested Class）的初始化独立于外部类，遵循以下规则：<br>• 懒加载：仅在首次主动使用时初始化（如<code>new</code>实例或访问静态成员）。  </p><p>• 不依赖外部类：即使外部类未初始化，静态嵌套类也可独立初始化。</p><p><strong>3. 代码示例与执行顺序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Outer类初始化&quot;</span>); <span class="comment">// (1)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Inner类初始化&quot;</span>); <span class="comment">// (2)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="type">String</span> <span class="variable">MESSAGE</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>; <span class="comment">// (3)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Outer.Inner.MESSAGE); <span class="comment">// 触发Inner初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Outer类初始化  </span><br><span class="line">Inner类初始化  </span><br><span class="line">Hello</span><br></pre></td></tr></table></figure><p>关键点：</p><ol><li>访问<code>Inner.MESSAGE</code>时，先初始化<code>Outer</code>（因为<code>Inner</code>是<code>Outer</code>的静态成员）。  </li><li>随后初始化<code>Inner</code>类（执行其静态块）。  </li><li>若仅访问<code>Outer</code>的其他静态成员（如<code>Outer.ANOTHER_FIELD</code>），<code>Inner</code>不会初始化。</li></ol><p><strong>4. 特殊情况与陷阱</strong><br>静态常量（<code>static final</code>）优化：  </p><p>  若静态嵌套类的字段是编译时常量（如<code>static final String MESSAGE = &quot;Hello&quot;</code>），JVM会直接内联该值，不会触发类初始化。<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Outer.Inner.MESSAGE); <span class="comment">// 不触发Inner初始化！</span></span><br></pre></td></tr></table></figure></p><p><strong>即变为<code>static String MESSAGE = &quot;Hello&quot;; // (3)</code>则并不会输出Inner类初始化，因为</strong></p><ul><li><p><code>MESSAGE</code>是<code>static final</code>常量，且值是编译时常量（字符串”Hello”）</p></li><li><p>根据Java语言规范(JLS 13.1)，这类常量会被编译器内联优化</p></li><li><p>实际运行时直接使用常量值，<strong>不会触发类的初始化</strong></p></li></ul><p>外部类卸载：  </p><p>静态嵌套类不会阻止外部类被卸载（因为没有隐式引用）。</p><p><strong>5. 总结</strong></p><table><thead><tr><th>场景</th><th>初始化顺序</th></tr></thead><tbody><tr><td>首次访问<code>Outer.Inner</code>的静态成员</td><td>1. 初始化<code>Outer</code> → 2. 初始化<code>Inner</code></td></tr><tr><td>仅访问<code>Outer</code>的静态成员</td><td>仅初始化<code>Outer</code>，<code>Inner</code>不初始化</td></tr><tr><td><code>static final</code>常量访问</td><td>不触发任何类初始化（内联优化）</td></tr></tbody></table><p>核心结论：<br>静态嵌套类的初始化是按需且独立的，但首次访问时需保证外部类已初始化（除非字段是编译时常量）。</p><h2 id="静态内部类作用"><a href="#静态内部类作用" class="headerlink" title="静态内部类作用"></a>静态内部类作用</h2><p>内部静态类（<code>static nested class</code>）是Java中一种特殊的嵌套类，它与普通内部类（非静态）有显著区别，主要用于以下场景和优势：</p><p><strong>1. 核心作用</strong><br>• 逻辑分组：将紧密关联的类组织在一起，提高代码可读性（如<code>Map.Entry</code>）。</p><p>• 减少命名冲突：通过外部类限定类名（如<code>Outer.Inner</code>）。</p><p>• 访问限制：可声明为<code>private</code>，仅对外部类可见。</p><p><strong>2. 与非静态内部类的关键区别</strong></p><table><thead><tr><th>特性</th><th>静态内部类</th><th>非静态内部类</th></tr></thead><tbody><tr><td>依赖外部类实例</td><td>❌ 不依赖（可单独实例化）</td><td>✅ 必须依赖外部类实例</td></tr><tr><td>隐含引用</td><td>❌ 无<code>Outer.this</code>隐式引用</td><td>✅ 持有外部类实例的隐式引用</td></tr><tr><td>内存泄漏风险</td><td>❌ 无</td><td>✅ 可能引发（如持有外部类引用）</td></tr><tr><td>访问外部类成员</td><td>❌ 只能访问外部类的静态成员</td><td>✅ 可访问外部类所有成员</td></tr></tbody></table><p><strong>3. 典型使用场景</strong><br><strong>(1) 工具类&#x2F;辅助类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collections</span> &#123;</span><br><span class="line">    <span class="comment">// 静态内部类作为工具类的一部分</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EmptyList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="comment">// 实现空列表逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 优势：避免污染全局命名空间，同时对外隐藏实现细节。</p><p><strong>(2) Builder模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> User <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = builder.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>.Builder().setName(<span class="string">&quot;Alice&quot;</span>).build();</span><br></pre></td></tr></table></figure><p>• 优势：分离构造逻辑，支持链式调用。</p><p><strong>(3) 数据结构节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123; <span class="comment">// 静态内部类表示节点</span></span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        </span><br><span class="line">        Node(E item, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = item;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 优势：节点无需访问链表实例，节省内存。</p><p><strong>(4) 回调封装</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetworkRequest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Callback</span> &#123; <span class="comment">// 静态回调类</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String response)</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Exception e)</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendRequest</span><span class="params">(Callback callback)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟网络请求</span></span><br><span class="line">        callback.onSuccess(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 优势：避免持有外部类引用，防止内存泄漏。</p><p><strong>4. 为什么优先选择静态内部类？</strong><br>• 性能更好：无隐式引用，GC效率更高。</p><p>• 更安全：不会意外捕获外部类引用。</p><p>• 更灵活：可独立于外部类实例化。</p><p><strong>5. 代码示例对比</strong><br><strong>(1) 静态内部类（推荐）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticField</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(staticField); <span class="comment">// ✅ 只能访问静态成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner(); <span class="comment">// 无需Outer实例</span></span><br></pre></td></tr></table></figure><p><strong>(2) 非静态内部类（不推荐）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">instanceField</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(instanceField); <span class="comment">// ✅ 访问实例成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>(); <span class="comment">// 必须通过外部实例创建</span></span><br></pre></td></tr></table></figure><p><strong>6. 使用注意事项</strong></p><ol><li>不要滥用：仅在逻辑紧密关联时使用。</li><li>优先静态：除非需要访问外部实例成员，否则默认用<code>static</code>。</li><li>序列化：静态内部类可单独序列化，非静态内部类需外部类可序列化。</li></ol><p><strong>总结</strong><br>内部静态类是Java中实现高内聚低耦合的重要工具，尤其适合：<br>• 封装仅被外部类使用的逻辑（如<code>Node</code>、<code>Builder</code>）</p><p>• 需要避免内存泄漏的场景（如回调）</p><p>• 提供命名空间隔离的辅助功能</p><p>正确使用能显著提升代码的可维护性和性能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 静态内部类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.4 最小生成树+最短路径+拓扑排序+关键路径</title>
      <link href="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
      <url>/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-14.png"></p><h1 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h1><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-12.png"></p><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-9.png"></p><h2 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>每次将代价最小的新顶点纳入生成树，直到所有顶点都被纳入。</li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-10.png"></p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><p>可以看到最小生成树可以有多个。</p></li><li><p>下图从p城出发：</p></li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-11.png"></p><ul><li>从农场出发：</li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-8.png"></p><p>可以看到从不同顶点出发，最后代价的值都是相同的。</p><h2 id="Kru"><a href="#Kru" class="headerlink" title="Kru"></a>Kru</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image.png"></p><ul><li><p>我们看看它的执行过程</p><ul><li><p>如下图，首先连接边1,2,3,4，然后发现最小的边为4（绿色）</p></li><li><p>但是此时p城和渔村已经连通了，所以不选，连接5。</p></li></ul></li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-1.png"></p><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><h2 id="Prim-vs-Kru"><a href="#Prim-vs-Kru" class="headerlink" title="Prim vs Kru"></a>Prim vs Kru</h2><h3 id="时间复杂度（重要）"><a href="#时间复杂度（重要）" class="headerlink" title="时间复杂度（重要）"></a>时间复杂度（重要）</h3><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-2.png"></p><h3 id="prim实现思想"><a href="#prim实现思想" class="headerlink" title="prim实现思想"></a>prim实现思想</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-3.png"></p><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-4.png"></p><h4 id="执行总结"><a href="#执行总结" class="headerlink" title="执行总结"></a>执行总结</h4><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-13.png"></p><h3 id="kru实现思想"><a href="#kru实现思想" class="headerlink" title="kru实现思想"></a>kru实现思想</h3><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-6.png"></p><h4 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h4><p>使用<strong>并查集</strong>检查两条边是否已经连通。</p><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-5.png"></p><p>并查集性能跟树的深度有关系，简称 O(h)，以前介绍二分搜索树的时候，时间复杂度也是为 O(h)。</p><p>但是并查集并不是一个二叉树，而是一个多叉树，所以并查集的查询和合并时间复杂度并不是O(log n)，在加上rank和路径压缩优化后 ，并查集的时间复杂度为 O(logn)</p><h1 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h1><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-7.png"></p><h1 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h1><h2 id="法一：不带权图（bfs）"><a href="#法一：不带权图（bfs）" class="headerlink" title="法一：不带权图（bfs）"></a>法一：不带权图（bfs）</h2><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-28.png"></p><ul><li>path存前驱</li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-27.png"></p><h2 id="法二：Dij算法"><a href="#法二：Dij算法" class="headerlink" title="法二：Dij算法"></a>法二：Dij算法</h2><h3 id="迪杰斯特拉"><a href="#迪杰斯特拉" class="headerlink" title="迪杰斯特拉"></a>迪杰斯特拉</h3><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-25.png"></p><h3 id="bfs的局限性"><a href="#bfs的局限性" class="headerlink" title="bfs的局限性"></a>bfs的局限性</h3><ul><li><p>不适合求<strong>带权图的</strong>单源最短路径</p></li><li><p>带权路径长度简称为路径长度</p></li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-24.png"></p><h3 id="dij算法过程（重要）"><a href="#dij算法过程（重要）" class="headerlink" title="dij算法过程（重要）"></a>dij算法过程（重要）</h3><p>目标：求v0到其他顶点的最短路径</p><ul><li><p>进行初始化</p><ul><li><p>Path依旧存前驱结点下标</p></li><li><p>final为是否已经找到最短路径</p></li><li><p>最短路径长度存权值</p></li></ul></li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-29.png"></p><ul><li><p>第一轮处理需要遍历所有的结点，找到final为false且dist最小的顶点（图中是5,即v4）</p></li><li><p>然后检查所有和v4相连的顶点，如果他的final是false，就更新dist和path（改为红色的字）</p></li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-23.png"></p><ul><li>同样的第二轮循环，找到v3</li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-21.png"></p><ul><li>第3轮循环找v1</li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-26.png"></p><ul><li>最后一轮找v2</li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-20.png"></p><h3 id="使用数组信息"><a href="#使用数组信息" class="headerlink" title="使用数组信息"></a>使用数组信息</h3><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-22.png"></p><h3 id="dij时间复杂度"><a href="#dij时间复杂度" class="headerlink" title="dij时间复杂度"></a>dij时间复杂度</h3><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-19.png"></p><h3 id="dij不能用于带有负数权值的图（重要）"><a href="#dij不能用于带有负数权值的图（重要）" class="headerlink" title="dij不能用于带有负数权值的图（重要）"></a>dij不能用于带有负数权值的图（重要）</h3><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-18.png"></p><h1 id="各顶点间的最短路径"><a href="#各顶点间的最短路径" class="headerlink" title="各顶点间的最短路径"></a>各顶点间的最短路径</h1><h2 id="floyed算法"><a href="#floyed算法" class="headerlink" title="floyed算法"></a>floyed算法</h2><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-15.png"></p><p><strong>利用了动态规划思路</strong></p><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-17.png"></p><h3 id="算法过程（重要）"><a href="#算法过程（重要）" class="headerlink" title="算法过程（重要）"></a>算法过程（重要）</h3><ul><li><p>如果使用某一个结点作为中转站会使新的路径要小于原来的路径，则更新。</p><ul><li>下图中是用v0作为v1和v2之间的中转站。</li></ul></li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-16.png"></p><ul><li>接下来在<strong>v0的基础上</strong>，加上以v1作为中转点。</li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-42.png"></p><ul><li>然后是二轮然后到n-1轮，一共n轮递推。</li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-43.png"></p><h3 id="信息读取-重要"><a href="#信息读取-重要" class="headerlink" title="信息读取(重要)"></a>信息读取(重要)</h3><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-41.png"></p><ul><li><p><strong>A中储存的值就直接是最后两点之间的距离结果</strong></p></li><li><p><strong>path中存储的是两个结点之间的中转点。</strong></p><ul><li>对于下图，v0到v4的中转点是v3，然后再看v0到v3的中转点是v2，然后再看v0到v2的中转点是-1，表明不存在中转点，v2到v3的中转点是1，表明经过v1，而在此递归可以发现没有中中转点了，<strong>所以路径是v0-v2-v1-v3-v4。（递归算法）</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPath</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; path, vector&lt;<span class="type">int</span>&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path[i][j] == <span class="number">-1</span>) &#123;  <span class="comment">// 无中转点，直接连接i和j</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(j); <span class="comment">// 或 result = &#123;i, j&#125;;return;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k = path[i][j];      <span class="comment">// 获取中转点</span></span><br><span class="line">    <span class="built_in">getPath</span>(i, k, path, result);  <span class="comment">// 递归左半部分(i→k)</span></span><br><span class="line">    <span class="built_in">getPath</span>(k, j, path, result);  <span class="comment">// 递归右半部分(k→j)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用示例：</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findPath</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    result.<span class="built_in">push_back</span>(start); <span class="comment">// 先加入起点getPath(start, end, path, result);</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-44.png"></p><h3 id="核心代码与复杂度（重要）"><a href="#核心代码与复杂度（重要）" class="headerlink" title="核心代码与复杂度（重要）"></a>核心代码与复杂度（重要）</h3><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-35.png"></p><h3 id="floyed不能解决带有负权回路的图"><a href="#floyed不能解决带有负权回路的图" class="headerlink" title="floyed不能解决带有负权回路的图"></a>floyed不能解决带有负权回路的图</h3><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-36.png"></p><h1 id="最短路径总结（重要）"><a href="#最短路径总结（重要）" class="headerlink" title="最短路径总结（重要）"></a>最短路径总结（重要）</h1><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-33.png"></p><h1 id="有向无环图描述表达式"><a href="#有向无环图描述表达式" class="headerlink" title="有向无环图描述表达式"></a>有向无环图描述表达式</h1><h2 id="DAG图定义"><a href="#DAG图定义" class="headerlink" title="DAG图定义"></a>DAG图定义</h2><ul><li>Directed acyclic graph</li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-37.png"></p><h2 id="DAG描述表达式"><a href="#DAG描述表达式" class="headerlink" title="DAG描述表达式"></a>DAG描述表达式</h2><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-39.png"></p><ul><li>然后继续合并</li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-40.png"></p><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-38.png"></p><p>最后合并如下</p><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-31.png"></p><h2 id="做题技巧（重要）"><a href="#做题技巧（重要）" class="headerlink" title="做题技巧（重要）"></a>做题技巧（重要）</h2><p>首先列出最基本的图</p><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-32.png"></p><p>按要求合并如下</p><ul><li><p>最底层有3个c+d,合并</p></li><li><p>倒数第二层有两个(c+d)*e，合并</p></li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-30.png"></p><h1 id="AOV网"><a href="#AOV网" class="headerlink" title="AOV网"></a>AOV网</h1><ul><li><p><strong>Activity on vertex</strong> network</p></li><li><p>一定是一个使用<strong>DAG</strong>表示一个工程，顶点表示活动，有向边表示先后顺序。</p></li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-34.png"></p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><ul><li>找到做事的先后顺序</li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-59.png"></p><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-57.png"></p><ul><li><p>所以只要一个图中有回路就一定不可以进行拓扑排序。</p></li><li><p>所以要用DAG表示AVO，因为它不存在回路。</p></li></ul><h3 id="代码实现（模拟过程）"><a href="#代码实现（模拟过程）" class="headerlink" title="代码实现（模拟过程）"></a>代码实现（模拟过程）</h3><ul><li>基于邻接表实现</li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-58.png"></p><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-52.png"></p><ul><li><p>indegree[]记录所有顶点的入度。</p></li><li><p>print[]记录拓扑排序的序列。</p></li><li><p>用栈保存入度为0的点（队列也可以）</p></li></ul><hr><ul><li><p>入度为0的点放到栈中</p><ul><li>count为拓扑排序数组的下标</li></ul></li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-56.png"></p><ul><li>弹出2之后，相邻的顶点入度减一</li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-51.png"></p><ul><li>弹出0号结点。</li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-50.png"></p><ul><li>然后1号结点为0，入栈。</li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-54.png"></p><p>后面省略。</p><h3 id="代码实现（dfs）"><a href="#代码实现（dfs）" class="headerlink" title="代码实现（dfs）"></a>代码实现（dfs）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> vexnum;</span><br><span class="line">    <span class="comment">// 其他图结构定义（如邻接表）</span></span><br><span class="line">&#125; Graph;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM]; <span class="comment">// 访问标记数组</span></span><br><span class="line"><span class="type">int</span> result[MAX_VERTEX_NUM];   <span class="comment">// 存储拓扑序列</span></span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>;                  <span class="comment">// 结果数组的栈顶指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>; <span class="comment">// 标记当前顶点已访问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = <span class="built_in">FirstNeighbor</span>(G, v); w &gt;= <span class="number">0</span>; w = <span class="built_in">NextNeighbor</span>(G, v, w)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(G, w); <span class="comment">// 递归访问未访问的邻接顶点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 顶点退栈时存入结果数组（拓扑排序的关键）</span></span><br><span class="line">    result[top++] = v; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化访问标记</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; ++v) &#123;</span><br><span class="line">        visited[v] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从每个未访问的顶点开始DFS</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; ++v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(G, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出拓扑序列（需逆序输出result数组）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;拓扑排序序列：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = top - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, result[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆拓扑排序"><a href="#逆拓扑排序" class="headerlink" title="逆拓扑排序"></a>逆拓扑排序</h2><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-48.png"></p><ul><li><p>关于拓扑排序的代码实现我们使用的是邻接表进行存储，这是因为每次要将每一个入度为0的结点所指向的所有结点的入度都减一（相当于删除了）</p></li><li><p>而关于逆拓扑排序是反过来的将指向当前出度为0的结点的所有结点的出度减1，若是用领接表则需要全部遍历，所以采用领接矩阵进行存储。</p></li><li><p>或者采用“逆邻接表”。</p></li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-53.png"></p><h3 id="代码实现（dfs）-1"><a href="#代码实现（dfs）-1" class="headerlink" title="代码实现（dfs）"></a>代码实现（dfs）</h3><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-49.png"></p><h1 id="拓扑排序总结"><a href="#拓扑排序总结" class="headerlink" title="拓扑排序总结"></a>拓扑排序总结</h1><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-55.png"></p><h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1><h2 id="AOE网络"><a href="#AOE网络" class="headerlink" title="AOE网络"></a>AOE网络</h2><ul><li><p>AOE（activity on edge network），注意和AOV网的区别。</p><ul><li><p>AOV是顶点表示活动么人AOE是<strong>边表示活动，顶点表示事件。</strong></p><ul><li>活动是需要持续一段时间的；事件的发生是瞬间的。</li></ul></li><li><p>边上的权值表示开销。</p></li></ul></li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-47.png"></p><p>注意AOE网络的性质：</p><ul><li><p>事件发生之后，从它顶点出发的活动才可以被执行。</p></li><li><p>某一事件发生的前提是所有指向他的活动都要完成。</p></li><li><p>有些活动是可以并行的（比如多个人可以同时打鸡蛋和洗番茄）。</p></li></ul><h2 id="AOE特性"><a href="#AOE特性" class="headerlink" title="AOE特性"></a>AOE特性</h2><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-45.png"></p><h2 id="关键路径与关键活动（重要）"><a href="#关键路径与关键活动（重要）" class="headerlink" title="关键路径与关键活动（重要）"></a>关键路径与关键活动（重要）</h2><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-46.png"></p><p>如图所示，上图中的关键路径就是下方使用红色笔标记的路径——即完成整个工程的最短时间。如果关键活动不可以按时完成，则整个工程的完成时间就会被延长。</p><h3 id="最早开始时间与最早发生时间"><a href="#最早开始时间与最早发生时间" class="headerlink" title="最早开始时间与最早发生时间"></a>最早开始时间与最早发生时间</h3><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-70.png"></p><h3 id="最迟发生时间与最迟开始时间"><a href="#最迟发生时间与最迟开始时间" class="headerlink" title="最迟发生时间与最迟开始时间"></a>最迟发生时间与最迟开始时间</h3><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-69.png"></p><h3 id="时间余量与关键活动"><a href="#时间余量与关键活动" class="headerlink" title="时间余量与关键活动"></a>时间余量与关键活动</h3><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-68.png"></p><h3 id="特性（重要）"><a href="#特性（重要）" class="headerlink" title="特性（重要）"></a>特性（重要）</h3><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-64.png"></p><p>主要解释一下第三行的特性：比如缩短图中切番茄的时间，比如为0.5，那么显然此时的关键路径就变成了v1-v3-v4。</p><ul><li>所以不是关键路径的时间越压缩，整个工程的时间就会越提前。</li></ul><p><strong>注意：有的AOE网中又可能存在多个关键路径。所以如果只是缩短一条路肩上的关键活动不一定能缩短工期。除非内压缩了多个关键路径公共的那一个关键活动。</strong></p><h2 id="求关键路径步骤（重要）"><a href="#求关键路径步骤（重要）" class="headerlink" title="求关键路径步骤（重要）"></a>求关键路径步骤（重要）</h2><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-67.png"></p><h3 id="计算所有事件的最早发生时间"><a href="#计算所有事件的最早发生时间" class="headerlink" title="计算所有事件的最早发生时间"></a>计算所有事件的最早发生时间</h3><ul><li>取多个活动到当前时间的时间的最大值。</li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-66.png"></p><h3 id="计算所有事件的最迟发生时间"><a href="#计算所有事件的最迟发生时间" class="headerlink" title="计算所有事件的最迟发生时间"></a>计算所有事件的最迟发生时间</h3><ul><li><p>汇点的最迟发生时间等于最早发生时间。</p></li><li><p>取减法的最小值。</p></li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-65.png"></p><h3 id="计算所有活动的最早开始时间"><a href="#计算所有活动的最早开始时间" class="headerlink" title="计算所有活动的最早开始时间"></a>计算所有活动的最早开始时间</h3><ul><li>事件的最早发生事件等于活动的最早发生时间。</li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-63.png"></p><h3 id="计算所有活动的最晚开始时间"><a href="#计算所有活动的最晚开始时间" class="headerlink" title="计算所有活动的最晚开始时间"></a>计算所有活动的最晚开始时间</h3><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-61.png"></p><h3 id="计算所有活动的时间余量"><a href="#计算所有活动的时间余量" class="headerlink" title="计算所有活动的时间余量"></a>计算所有活动的时间余量</h3><ul><li>活动的最晚-最早开始时间。</li></ul><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-62.png"></p><ul><li>于是可以找到所有的关键活动（<strong>时间余量为0</strong>），对应的事件，组成了一条关键路径。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2025/04/24/6-4%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/image-60.png"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 最小生成树 </tag>
            
            <tag> AOE与AOV </tag>
            
            <tag> 拓扑排序 </tag>
            
            <tag> 关键路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-3浮点数的表示与运算</title>
      <link href="/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/"/>
      <url>/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h1><p><img src="/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-10.png"></p><h2 id="浮点数尾数的规格化"><a href="#浮点数尾数的规格化" class="headerlink" title="浮点数尾数的规格化"></a>浮点数尾数的规格化</h2><ul><li>采用双符号位挽救溢出。</li></ul><p><img src="/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-14.png"></p><h2 id="规格化浮点数的特点"><a href="#规格化浮点数的特点" class="headerlink" title="规格化浮点数的特点"></a>规格化浮点数的特点</h2><h3 id="原码表示尾数"><a href="#原码表示尾数" class="headerlink" title="原码表示尾数"></a>原码表示尾数</h3><p><img src="/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-13.png"></p><h3 id="补码表示尾数"><a href="#补码表示尾数" class="headerlink" title="补码表示尾数"></a>补码表示尾数</h3><ul><li><p>注意，规定补码表示为负数的时候，第二位（符号位之后的那一位）<strong>只能为零</strong>。</p></li><li><p>或者直接说：补码表示的尾数规格化的最高数值位必须和尾数符号位相反。</p></li></ul><p><img src="/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-12.png"></p><h3 id="补码尾数规格化例子"><a href="#补码尾数规格化例子" class="headerlink" title="补码尾数规格化例子"></a>补码尾数规格化例子</h3><p><img src="/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-8.png"></p><h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p><img src="/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-5.png"></p><h2 id="浮点数表示总结"><a href="#浮点数表示总结" class="headerlink" title="浮点数表示总结"></a>浮点数表示总结</h2><p><img src="/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-9.png"></p><h2 id="移码的基础含义"><a href="#移码的基础含义" class="headerlink" title="移码的基础含义"></a>移码的基础含义</h2><p><img src="/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-4.png"></p><h1 id="IEEE-754标准"><a href="#IEEE-754标准" class="headerlink" title="IEEE 754标准"></a>IEEE 754标准</h1><h2 id="IEEE-754格式（重要）"><a href="#IEEE-754格式（重要）" class="headerlink" title="IEEE 754格式（重要）"></a>IEEE 754格式（重要）</h2><p><img src="/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image.png"></p><ul><li><p>理论上来说移码可以表示的范围是-128~127（也就是全零和全一的情况），但是实际上规定，阶数的真值<strong>只能为-126~127。</strong></p></li><li><p>移码的范围是1~254</p></li><li><p>如下图所示，此时偏置值取得是2^(n-1)-1，而不是一般的2^(n-1)</p></li></ul><p><img src="/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-1.png"></p><h2 id="转换示例"><a href="#转换示例" class="headerlink" title="转换示例"></a>转换示例</h2><h3 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h3><p><img src="/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-2.png"></p><h3 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h3><p><img src="/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-11.png"></p><h2 id="特殊情况-阶码全1-or-0，位数全1-or-0"><a href="#特殊情况-阶码全1-or-0，位数全1-or-0" class="headerlink" title="特殊情况(阶码全1 or 0，位数全1 or 0)"></a>特殊情况(阶码全1 or 0，位数全1 or 0)</h2><p><img src="/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-7.png"></p><ul><li><p>注意最小的绝对值时尾数全为0，然后阶码最小为-126</p></li><li><p>阶码E全为0，尾数M不全为0，表示非规格化小数</p><ul><li><strong>比如想要表示0.001*2^-126，可以阶码为0（此时不能用阶码的0-127&#x3D;-127，这个是单独规定的），然后尾数部分为001…(还是要省略第一位0)</strong></li></ul></li><li><p>阶码全0，位数全0，表示0</p></li><li><p>阶码全1，位数全0，表示无穷大</p></li><li><p>阶码全1，位数不全为0，表示NAN（not a number，如0&#x2F;0）</p></li></ul><h1 id="浮点数的加减运算"><a href="#浮点数的加减运算" class="headerlink" title="浮点数的加减运算"></a>浮点数的加减运算</h1><p><img src="/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-3.png"></p><h2 id="运算步骤"><a href="#运算步骤" class="headerlink" title="运算步骤"></a>运算步骤</h2><ul><li><p>对阶：<strong>阶数更小的向更大的对齐</strong>。（更容易操作，左移即可）</p></li><li><p>阶码溢出才是真的溢出，尾数溢出可以通过规格化解决。</p></li></ul><p><img src="/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-6.png"></p><h2 id="无序舍入例子"><a href="#无序舍入例子" class="headerlink" title="无序舍入例子"></a>无序舍入例子</h2><p><img src="/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-20.png"></p><ul><li>首先进行预处理，进行规格化并化为补码形式</li></ul><h2 id="舍入例子（0舍1，恒置1）"><a href="#舍入例子（0舍1，恒置1）" class="headerlink" title="舍入例子（0舍1，恒置1）"></a>舍入例子（0舍1，恒置1）</h2><p><img src="/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-18.png"></p><h2 id="强制类型转换（重要）"><a href="#强制类型转换（重要）" class="headerlink" title="强制类型转换（重要）"></a>强制类型转换（重要）</h2><p><img src="/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-19.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-17.png"></p><h1 id="数据的存储与排列"><a href="#数据的存储与排列" class="headerlink" title="数据的存储与排列"></a>数据的存储与排列</h1><h2 id="大端存储与小端存储"><a href="#大端存储与小端存储" class="headerlink" title="大端存储与小端存储"></a>大端存储与小端存储</h2><p><img src="/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-15.png"></p><ul><li><p>大端存储有利于人阅读（大端存储指的是<strong>数据部分的高位放在地址的低位</strong>）</p><ul><li>所以大端的“大”指的是数据部分的位数，而地址默认都是从小到大排序的</li></ul></li><li><p>小端存储有利于机器处理</p><ul><li>因为机器默认都是从小到大读取的，比如想要直接读取尾数部分那就可以直接读取小端的数据部分。</li></ul></li></ul><h2 id="边界对齐（重要）"><a href="#边界对齐（重要）" class="headerlink" title="边界对齐（重要）"></a>边界对齐（重要）</h2><p><img src="/2025/04/21/2-3%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/image-16.png"></p><h1 id="常考习题"><a href="#常考习题" class="headerlink" title="常考习题"></a>常考习题</h1><ul><li>对于结构体的小端存储，结构体内部如</li></ul><p>注意是否要边界对齐。</p><p>对于a,b,c之间的顺序还是照常，但是每一个类型的内部按照小端存储。</p><ul><li><p>小端存储：以字节为单位，低位的字节对应小地址。</p></li><li><p>注意IEE754可以表示的最大正数是小数部分全1，阶数的最大值取127。（移码取1~255）</p></li><li><p>注意IEEE754的4种特殊情况，比如阶码全为0,为非规格化小数。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-2运算方法和运算电路</title>
      <link href="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/"/>
      <url>/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h1><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-14.png"></p><h2 id="FA-full-adder-一位全加器"><a href="#FA-full-adder-一位全加器" class="headerlink" title="FA(full adder)一位全加器"></a>FA(full adder)一位全加器</h2><p>首先明确加法器所需要的内容</p><ul><li><p>有3个输入，分别是两个该加数的本位以及一个来自低位的进位。</p></li><li><p>有2个输出，分别是本位和以及向高位的进位。</p></li></ul><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-10.png"></p><ul><li><p>如图，对于本位和，采用3个异或，电路如上所示。</p></li><li><p>对于像高位的进位，考虑下图中的两种情况：</p></li></ul><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-9.png"></p><p>合并之后的电路如图所示——“一位全加器”</p><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-7.png"></p><h2 id="串行进位加法器"><a href="#串行进位加法器" class="headerlink" title="串行进位加法器"></a>串行进位加法器</h2><p>对于加法电路，想要进行nbit加法，需要进行串行链接：</p><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-8.png"></p><p>如图，并行输入nbit，从An，Bn输入，进位从Cn输入。</p><h2 id="并行进位加法器"><a href="#并行进位加法器" class="headerlink" title="并行进位加法器"></a>并行进位加法器</h2><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-5.png"></p><h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-4.png"></p><p>如上图所示，我们列出最开始的求进位的公式，如果将其不断展开可以一直展开到C0</p><ul><li>此时可以知道该式子中只有已知的An，Bn以及C0，所以就可以通过并行执行。</li></ul><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-6.png"></p><p>如上图所写的那般：这样做会使电路变得越来越复杂。<strong>因此我们一般套娃到4位即可，</strong>&#x4E4B;后继续串行连&#x63A5;<strong>。</strong></p><p>根据公式可以设计出电路</p><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-1.png"></p><h2 id="带标志位的加法器"><a href="#带标志位的加法器" class="headerlink" title="带标志位的加法器"></a>带标志位的加法器</h2><p>在实际使用加法器的过程中，我们需要考虑3种情况：</p><ul><li><p>加法的运算结果是否溢出（超出nbit）</p></li><li><p>加法的结果是否为0、</p></li><li><p>是正？是负？</p></li></ul><p>所以要将加法器增加一些标志位的信息</p><ul><li><p>OF(overflow flag)：<strong>有符号数</strong>用于判断带符号数是否溢出</p></li><li><p>SF(sign flag)：<strong>有符号数</strong></p></li><li><p>ZF(zero flag)：<strong>有符号数和无符号数</strong></p></li><li><p>CF(carry flag)：用于判断<strong>无符号数</strong>是否溢出</p></li></ul><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-2.png"></p><h3 id="标志位的电路逻辑（重要）"><a href="#标志位的电路逻辑（重要）" class="headerlink" title="标志位的电路逻辑（重要）"></a>标志位的电路逻辑（重要）</h3><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-13.png"></p><ul><li><p>可以看到SF之所以为1表示负数是因为他直接取符号位。</p></li><li><p>OF取相邻两个异或</p></li><li><p>CF取开始和结束两个异或</p></li><li><p>ZF：要求所有的Sn都为0（<strong>注意这里每个Sn都代表二进制的一位，所以要求全为0</strong>）</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-3.png"></p><h1 id="ALU功能"><a href="#ALU功能" class="headerlink" title="ALU功能"></a>ALU功能</h1><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-11.png"></p><h2 id="实现方式（了解即可）"><a href="#实现方式（了解即可）" class="headerlink" title="实现方式（了解即可）"></a>实现方式（了解即可）</h2><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image.png"></p><h2 id="ALU图示"><a href="#ALU图示" class="headerlink" title="ALU图示"></a>ALU图示</h2><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-12.png"></p><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-18.png"></p><h2 id="ALU总结"><a href="#ALU总结" class="headerlink" title="ALU总结"></a>ALU总结</h2><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-28.png"></p><h1 id="定点数的移位运算"><a href="#定点数的移位运算" class="headerlink" title="定点数的移位运算"></a>定点数的移位运算</h1><h2 id="逻辑移位（常用于处理无符号整数）"><a href="#逻辑移位（常用于处理无符号整数）" class="headerlink" title="逻辑移位（常用于处理无符号整数）"></a>逻辑移位（常用于处理无符号整数）</h2><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-29.png"></p><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-22.png"></p><h2 id="算数移位（常用于处理带符号整数）"><a href="#算数移位（常用于处理带符号整数）" class="headerlink" title="算数移位（常用于处理带符号整数）"></a>算数移位（常用于处理带符号整数）</h2><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-25.png"></p><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-21.png"></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-20.png"></p><p>在java中的移位符号代表逻辑左移和算数右移和逻辑右移都有各自独特的，但是左移没有专门符号，因为都是直接在尾巴补上0</p><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-24.png"></p><h1 id="定点数加减运算"><a href="#定点数加减运算" class="headerlink" title="定点数加减运算"></a>定点数加减运算</h1><h2 id="原码的加减运算"><a href="#原码的加减运算" class="headerlink" title="原码的加减运算"></a>原码的加减运算</h2><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-26.png"></p><p>如图所示还是比较复杂的</p><h2 id="补码的加减运算"><a href="#补码的加减运算" class="headerlink" title="补码的加减运算"></a>补码的加减运算</h2><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-27.png"></p><h3 id="取反技巧（重要）"><a href="#取反技巧（重要）" class="headerlink" title="取反技巧（重要）"></a>取反技巧（重要）</h3><p>已知一个数的补码，求该数负数的补码：</p><ul><li>只需要将这个数的<strong>所有位数</strong>取反，最后在末尾加1即可。</li></ul><h2 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h2><h3 id="方法一（数学表达式）"><a href="#方法一（数学表达式）" class="headerlink" title="方法一（数学表达式）"></a>方法一（数学表达式）</h3><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-16.png"></p><h3 id="方法二（采用一位符号位）"><a href="#方法二（采用一位符号位）" class="headerlink" title="方法二（采用一位符号位）"></a>方法二（采用一位符号位）</h3><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-17.png"></p><p>看到如果异或的结果为0，没有用溢出；结果为1，溢出。</p><ul><li><p>上溢：超过正数表达的上限。从正数变为负数。</p></li><li><p>下溢：超过负数表达的下限。从负数变为正数。</p></li></ul><h3 id="方法三（双符号位）"><a href="#方法三（双符号位）" class="headerlink" title="方法三（双符号位）"></a>方法三（双符号位）</h3><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-19.png"></p><p>模4补码相当于把位权小于4（2^2）保留，大于4的舍弃；模2补码一样。</p><p><strong>不会增加存储空间</strong>，实际存储时只存储一个符号位，实际运算的时候会复制一个符号位。</p><ul><li><p>上溢为01</p></li><li><p>下溢为10</p></li></ul><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-23.png"></p><h1 id="无符号数的加减运算"><a href="#无符号数的加减运算" class="headerlink" title="无符号数的加减运算"></a>无符号数的加减运算</h1><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-15.png"></p><p>如图所示，计算机在处理无符号数的减法运算的时候实际上是把它变成被减数<strong>加上减数的补数</strong>。</p><ul><li><p>补数：</p><ul><li>对于8bit的寄存器而言，相当于mod256，于是补数就是256-B的值，在本题中也就是256-99 &#x3D; 247，相当于求247+99</li></ul></li></ul><p>从形式上来看，之前说过求补数实际上就是将<strong>全部位数按位取反，+1。</strong></p><h2 id="无符号数的溢出判断"><a href="#无符号数的溢出判断" class="headerlink" title="无符号数的溢出判断"></a>无符号数的溢出判断</h2><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-43.png"></p><p>考试的时候之间通过十进制相加判断是否在合法范围内即可。</p><h3 id="无符号数加法发生溢出"><a href="#无符号数加法发生溢出" class="headerlink" title="无符号数加法发生溢出"></a>无符号数加法发生溢出</h3><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-36.png"></p><p>关注最高位产生的进位是否为1，为1则溢出，否则则没有。</p><h2 id="无符号位减法发生溢出"><a href="#无符号位减法发生溢出" class="headerlink" title="无符号位减法发生溢出"></a>无符号位减法发生溢出</h2><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-39.png"></p><p>注意还是要先将减数按位取反加1然后相加之后再判断是否进位为0，如果<strong>进位为0则溢出。</strong></p><p>还是刚刚例子，减法进了一个1，不溢出。实际上干脆<strong>直接通过十进制判断即可</strong></p><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-37.png"></p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-40.png"></p><h1 id="补码加减运算电路"><a href="#补码加减运算电路" class="headerlink" title="补码加减运算电路"></a>补码加减运算电路</h1><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-38.png"></p><ul><li><p>该电路也可以用于实现无符号电路的加减运算（因为他们的<strong>加减逻辑都是一样的</strong>）</p></li><li><p>注意这里的多路选择器有sub这信号量控制，并且sub还要连接cin表示低位的进位。</p></li></ul><h2 id="4个标志位总结（重要）"><a href="#4个标志位总结（重要）" class="headerlink" title="4个标志位总结（重要）"></a>4个标志位总结（重要）</h2><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-35.png"></p><h3 id="OF原理"><a href="#OF原理" class="headerlink" title="OF原理"></a>OF原理</h3><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-42.png"></p><p>OF就是这个逻辑，他比较进位Cn和进位Cn-1是否不同，若不同则代表发生了进位。</p><p>比如01+01,0为符号位，相加得10，此时符号位为1，代表溢出（数值进位为1，符号位进位为0）表示上溢，超过了最大值。</p><h3 id="CF原理"><a href="#CF原理" class="headerlink" title="CF原理"></a>CF原理</h3><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-34.png"></p><h1 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h1><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-33.png"></p><h1 id="原码的乘法运算"><a href="#原码的乘法运算" class="headerlink" title="原码的乘法运算"></a>原码的乘法运算</h1><h2 id="手算乘法（入门）"><a href="#手算乘法（入门）" class="headerlink" title="手算乘法（入门）"></a>手算乘法（入门）</h2><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-44.png"></p><h2 id="原码的一位乘法-重要"><a href="#原码的一位乘法-重要" class="headerlink" title="原码的一位乘法(重要)"></a>原码的一位乘法(重要)</h2><ul><li><p>在第一章中谈到运算器的基本组成的时候</p><ul><li>acc存乘积高位，mq存乘积的低位（实际上指的就是以为一位乘法的计算过程）</li></ul></li></ul><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-41.png"></p><ul><li>数值位有n位数，就重复n次，比如以下的这个例子，乘数的数值位有4位，所以重复4次。</li></ul><h3 id="计算第一个位积"><a href="#计算第一个位积" class="headerlink" title="计算第一个位积"></a>计算第一个位积</h3><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-31.png"></p><ul><li>再进行逻辑右移（低位丢弃，高位补0）</li></ul><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-32.png"></p><h3 id="计算第二个位积"><a href="#计算第二个位积" class="headerlink" title="计算第二个位积"></a>计算第二个位积</h3><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-30.png"></p><ul><li>再逻辑右移一位</li></ul><h3 id="最后结果"><a href="#最后结果" class="headerlink" title="最后结果"></a>最后结果</h3><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-58.png"></p><ul><li><p>执行4次之后，原来的符号为到了最后一位。</p></li><li><p>然后处理符号位（将两个符号位进行异或）</p></li></ul><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-57.png"></p><h3 id="书写过程"><a href="#书写过程" class="headerlink" title="书写过程"></a>书写过程</h3><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-59.png"></p><ul><li>在这个例子中，|x|就是被乘数，第二列的那个低位部分就是乘数|y|</li></ul><h1 id="补码的乘法运算"><a href="#补码的乘法运算" class="headerlink" title="补码的乘法运算"></a>补码的乘法运算</h1><h2 id="补码的一位乘法（重要）"><a href="#补码的一位乘法（重要）" class="headerlink" title="补码的一位乘法（重要）"></a>补码的一位乘法（重要）</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li><p>注意对于补码的一位乘法，他的符号位是要参与运算的，也就是说不用|x|这种形式。</p></li><li><p>原码操作每次以为是逻辑右移（符号位跟着右移，前面补上零），而补码乘法是算法右移（符号位不参与右移，补上符号位）</p></li></ul><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-51.png"></p><ul><li><p>辅助位（将MQ寄存器的低位新增一位）</p></li><li><p>乘数是单符号位补码，acc和乘数的计算器在高位都加一位</p></li></ul><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-55.png"></p><h3 id="补码一位运算（手算过程）"><a href="#补码一位运算（手算过程）" class="headerlink" title="补码一位运算（手算过程）"></a>补码一位运算（手算过程）</h3><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-52.png"></p><h1 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h1><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-56.png"></p><h1 id="定点数原码的除法运算"><a href="#定点数原码的除法运算" class="headerlink" title="定点数原码的除法运算"></a>定点数原码的除法运算</h1><h2 id="手算思想"><a href="#手算思想" class="headerlink" title="手算思想"></a>手算思想</h2><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-54.png"></p><h2 id="恢复余数法（重要）"><a href="#恢复余数法（重要）" class="headerlink" title="恢复余数法（重要）"></a>恢复余数法（重要）</h2><ul><li><p>默认商1，然后通过[|被除数|]补+[-|除数|]补判断正负，如果是负数，那就返回一开始的状态（恢复余数）然后商0，然后逻辑左移。</p><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-53.png"></p></li><li><p>逻辑左移</p><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-48.png"></p></li><li><p>重新按照之前的操作</p></li></ul><h3 id="最后结果-1"><a href="#最后结果-1" class="headerlink" title="最后结果"></a>最后结果</h3><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-49.png"></p><h2 id="手算过程"><a href="#手算过程" class="headerlink" title="手算过程"></a>手算过程</h2><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-50.png"></p><h2 id="加减交替法（不恢复余数）"><a href="#加减交替法（不恢复余数）" class="headerlink" title="加减交替法（不恢复余数）"></a>加减交替法（不恢复余数）</h2><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-45.png"></p><p>如图，2a+b相当于左移两位然后加上b（除数），所以如果余数为负数，那么直接商0然后余数左移1为再加上除数。</p><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-46.png"></p><p>根据上面的红框进行新一轮循环</p><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-47.png"></p><ul><li><p><strong>余数为负，商0，左移加</strong></p></li><li><p><strong>余数为正，商1，左移减</strong></p></li></ul><h1 id="定点数补码的加减交替法"><a href="#定点数补码的加减交替法" class="headerlink" title="定点数补码的加减交替法"></a>定点数补码的加减交替法</h1><ul><li><p><strong>余数与除数异号，商0，左移加</strong></p></li><li><p><strong>余数与除数同号，商1，左移减</strong></p></li></ul><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-60.png"></p><h1 id="定点数的原码与补码加减交替法比较"><a href="#定点数的原码与补码加减交替法比较" class="headerlink" title="定点数的原码与补码加减交替法比较"></a>定点数的原码与补码加减交替法比较</h1><p><img src="/2025/04/21/2-2%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF/image-61.png"></p><h1 id="常考习题"><a href="#常考习题" class="headerlink" title="常考习题"></a>常考习题</h1><ul><li><p>首先是要明确，OF是判断有符号数是否溢出，而CF是判断无符号数是否溢出。比如有一个数是-1，那么OF把他的二进制当作有符号数，而CF把他的符号位当成数据。</p></li><li><p>当进行数据类型的转换的时候，比如int变为short会发生阶段，要注意的是，如果是short变为int，要子啊前面补上符号位！</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-1数制与编码</title>
      <link href="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/"/>
      <url>/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h1><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-12.png"></p><h2 id="任意进制转十进制"><a href="#任意进制转十进制" class="headerlink" title="任意进制转十进制"></a>任意进制转十进制</h2><p>采用r进制计数法</p><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-14.png"></p><p><strong>这里要注意小数部分的第一个数是-1次方开始的。</strong></p><h2 id="二进制转八进制、十六进制"><a href="#二进制转八进制、十六进制" class="headerlink" title="二进制转八进制、十六进制"></a>二进制转八进制、十六进制</h2><h3 id="转换方式"><a href="#转换方式" class="headerlink" title="转换方式"></a>转换方式</h3><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-13.png"></p><h3 id="书写方式"><a href="#书写方式" class="headerlink" title="书写方式"></a>书写方式</h3><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-11.png"></p><h2 id="十进制转换任意进制"><a href="#十进制转换任意进制" class="headerlink" title="十进制转换任意进制"></a>十进制转换任意进制</h2><h3 id="标准做法"><a href="#标准做法" class="headerlink" title="标准做法"></a>标准做法</h3><h4 id="表示整数部分"><a href="#表示整数部分" class="headerlink" title="表示整数部分"></a>表示整数部分</h4><p>使用r进制计数法取余数的形式</p><p><strong>除基取余法</strong></p><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-8.png"></p><h4 id="表示小数部分（重要）"><a href="#表示小数部分（重要）" class="headerlink" title="表示小数部分（重要）"></a>表示小数部分（重要）</h4><p><strong>乘积取整法</strong></p><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-9.png"></p><p>可以看到0.3化成二进制是无限的。</p><p>对于有尽头的情况：</p><ol><li><p>0.5×2&#x3D;1.00.5×2&#x3D;1.0（整数部分是 1，小数部分是 0）</p></li><li><p>因为<strong>小数部分是 0，转换停止。</strong></p></li></ol><h3 id="拼凑法"><a href="#拼凑法" class="headerlink" title="拼凑法"></a>拼凑法</h3><p>对于简单情况</p><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-10.png"></p><h2 id="真值、机器数"><a href="#真值、机器数" class="headerlink" title="真值、机器数"></a>真值、机器数</h2><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-5.png"></p><h2 id="进制转换总结"><a href="#进制转换总结" class="headerlink" title="进制转换总结"></a>进制转换总结</h2><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-4.png"></p><h1 id="定点数与浮点数"><a href="#定点数与浮点数" class="headerlink" title="定点数与浮点数"></a>定点数与浮点数</h1><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-7.png"></p><h2 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h2><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-6.png"></p><ul><li>无符号数都是整数，不存在无符号小数。</li></ul><h2 id="有符号数（重要）"><a href="#有符号数（重要）" class="headerlink" title="有符号数（重要）"></a>有符号数（重要）</h2><p>有符号数可以表示小数</p><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-3.png"></p><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-1.png"></p><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image.png"></p><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-2.png"></p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-28.png"></p><p>可以看到+0和-0用补码的形式都是00000000，所以就空出了一个表示负数，因此负数多一位。</p><p>补码小数最小可以表示到-1，即11111111。</p><h3 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h3><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-23.png"></p><h4 id="移码作用"><a href="#移码作用" class="headerlink" title="移码作用"></a>移码作用</h4><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-22.png"></p><p>&#x20;</p><h3 id="用几种吗表示顶点整数"><a href="#用几种吗表示顶点整数" class="headerlink" title="用几种吗表示顶点整数"></a>用几种吗表示顶点整数</h3><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-27.png"></p><h3 id="定点数与浮点数总结"><a href="#定点数与浮点数总结" class="headerlink" title="定点数与浮点数总结"></a>定点数与浮点数总结</h3><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-20.png"></p><h1 id="各种码的作用"><a href="#各种码的作用" class="headerlink" title="各种码的作用"></a>各种码的作用</h1><h2 id="原码的加减"><a href="#原码的加减" class="headerlink" title="原码的加减"></a>原码的加减</h2><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-18.png"></p><h2 id="用加法代替减法思路"><a href="#用加法代替减法思路" class="headerlink" title="用加法代替减法思路"></a>用加法代替减法思路</h2><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-26.png"></p><p>如上图，-3mod12和9mod12,19mod12……这些结果都是一样的，为7，这其中有什么规律？</p><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-25.png"></p><p>如图，-3,9,21,33,-15等价，意味着在同样mod12的基础上，可以相互替换。如下图所示：</p><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-17.png"></p><ul><li><p>注意蓝色框中的话：可以用补数来替换减数。</p><ul><li><p>比如说在无符号数的减法中就可以应用这个思路</p></li><li><p>如（5-2）mod 256 &#x3D; 3</p></li><li><p>(5+253) mod 256 &#x3D; 3</p></li></ul></li></ul><h2 id="补码可以让减法变为加法操作"><a href="#补码可以让减法变为加法操作" class="headerlink" title="补码可以让减法变为加法操作"></a>补码可以让减法变为加法操作</h2><p>根据上面用加法代替减法的思路，我们可以将下图中的-14的二进制原码替换成它的补数。</p><p>根据标黄公式，-14的补数等于模（2^8-a的绝对值），求补数的过程其实就是之前求补码的过程。</p><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-24.png"></p><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-16.png"></p><h3 id="为什么取反加一可以得到补数"><a href="#为什么取反加一可以得到补数" class="headerlink" title="为什么取反加一可以得到补数"></a>为什么取反加一可以得到补数</h3><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-15.png"></p><p>如图，取反之后和原数相加可以得到1111 1111，然后再加一可以得到1 0000 0000相当于模（2^8）的大小。</p><p>所以求补码就是取反加1。</p><h2 id="补码作用总结"><a href="#补码作用总结" class="headerlink" title="补码作用总结"></a>补码作用总结</h2><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-21.png"></p><h1 id="零扩展和符号扩展"><a href="#零扩展和符号扩展" class="headerlink" title="零扩展和符号扩展"></a>零扩展和符号扩展</h1><p><img src="/2025/04/21/2-1%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/image-19.png"></p><h1 id="常见习题"><a href="#常见习题" class="headerlink" title="常见习题"></a>常见习题</h1><p>常考有符号数和无符号数之间的转换</p><ul><li><p>尤其注意short 是-32768~32767，一共65536个数</p></li><li><p>无符号数没有符号位，比如unsigned short 表示从0~65535一共65536个数</p></li><li><p>2的15次方是32768，因为short表示的范围就是-2^15~2^15-1</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遗传算法排课</title>
      <link href="/2025/04/11/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%8E%92%E8%AF%BE/"/>
      <url>/2025/04/11/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%8E%92%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<p>本文笔记基于github项目:Course-Arrangement</p><h1 id="编码结构"><a href="#编码结构" class="headerlink" title="编码结构"></a>编码结构</h1><h2 id="1-定义排课信息结构-CoursePlan"><a href="#1-定义排课信息结构-CoursePlan" class="headerlink" title="1.定义排课信息结构 CoursePlan"></a>1.定义排课信息结构 CoursePlan</h2><p>以下是排课计划的结构，将基于这些结构进行排课的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@TableName(&quot;course_plan&quot;)</span></span><br><span class="line"><span class="meta">@ApiModel(value = &quot;CoursePlan对象&quot;, description = &quot;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoursePlan</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@ApiModelProperty(&quot;id&quot;)</span></span><br><span class="line">      <span class="meta">@TableId(value = &quot;id&quot;, type = IdType.AUTO)</span></span><br><span class="line">      <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@ApiModelProperty(&quot;学期&quot;)</span></span><br><span class="line">      <span class="keyword">private</span> String term;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@ApiModelProperty(&quot;学院&quot;)</span></span><br><span class="line">      <span class="keyword">private</span> String collegeNo;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@ApiModelProperty(&quot;年级编号&quot;)</span></span><br><span class="line">      <span class="keyword">private</span> String gradeNo;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@ApiModelProperty(&quot;班级编号&quot;)</span></span><br><span class="line">      <span class="keyword">private</span> String classNo;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@ApiModelProperty(&quot;课程编号&quot;)</span></span><br><span class="line">      <span class="keyword">private</span> String courseNo;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@ApiModelProperty(&quot;周学时&quot;)</span></span><br><span class="line">      <span class="keyword">private</span> Integer weekTime;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@ApiModelProperty(&quot;周数&quot;)</span></span><br><span class="line">      <span class="keyword">private</span> Integer weeks;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@ApiModelProperty(&quot;上课时间是否固定&quot;)</span></span><br><span class="line">      <span class="keyword">private</span> String isFix;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@ApiModelProperty(&quot;上课时间&quot;)</span></span><br><span class="line">      <span class="keyword">private</span> String courseTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们将一学时认为是一节课，大学两节课连上，所以一周排课的次数为weekTime&#x2F;2</li></ul><h2 id="2-编码函数-coding"><a href="#2-编码函数-coding" class="headerlink" title="2.编码函数 coding"></a>2.编码函数 coding</h2><p>遗传算法需要将信息进行编码成“染色体”，然后才能对染色体中的每一段（每一段都是一个可以表示含义的单位）进行交叉、变异等操作。</p><h3 id="gene结构"><a href="#gene结构" class="headerlink" title="gene结构"></a>gene结构</h3><p><em><code>编码规则为：是否固定+年级编号+班级编号+教师编号+课程编号+课程属性+教室类型+上课时间</code></em></p><p>他们的位数如下</p><p><em>编码规则:</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* 固定时间：<span class="number">1</span></span><br><span class="line">* 年级编号：<span class="number">2</span></span><br><span class="line">* 班级编号：<span class="number">8</span></span><br><span class="line">* 讲师编号：<span class="number">5</span></span><br><span class="line">* 课程编号：<span class="number">6</span></span><br><span class="line">* 课程属性：<span class="number">1</span>     期望计算，进行优化</span><br><span class="line">* 教室类型：<span class="number">2</span>     教室选择</span><br><span class="line">* 上面共<span class="number">25</span>位</span><br><span class="line">* 上课时间：<span class="number">2</span></span><br><span class="line">* 教室编号：<span class="number">5</span></span><br><span class="line">* 共<span class="number">32</span>位</span><br></pre></td></tr></table></figure><h3 id="coding函数"><a href="#coding函数" class="headerlink" title="coding函数"></a>coding函数</h3><p>返回值是一个map，key有两个，分别是固定时间和没固定时间。list<String>存放结果，String就是gene片段</String></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> coursePlanList</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 根据课程计划生成染色体的编码过程，</span></span><br><span class="line"><span class="comment"> * 通过 coding方法，将课程计划信息编码为染色体，使用 Map&lt;String, List&lt;String&gt;&gt;作为返回值，其中键表示上课时间是否固定，值是对应的课程信息编码列表。</span></span><br><span class="line"><span class="comment"> * 编码规则：每个基因编码有32位。规则为：是否固定 + 年级编号 + 班级编号 + 讲师编号 + 课程编号 + 课程属性 +教室类型+上课时间。其中，如果不固定上课时间，默认填充为&quot;00&quot;。</span></span><br><span class="line"><span class="comment"> * 编码过程：对每门课程进行遍历，分别处理固定和不固定的上课时间方式。</span></span><br><span class="line"><span class="comment"> * 对于不固定时间，根据每周上课的节数生成对应数量的基因编码，使用默认的上课时间（&quot;00&quot;）。</span></span><br><span class="line"><span class="comment"> * 对于固定时间，根据每周上课的节数和设定的固定时间，生成对应数量的基因编码。</span></span><br><span class="line"><span class="comment"> * 课程信息获取：通过调用 courseInfoMapper 获取每门课程的讲师编号和课程属性。</span></span><br><span class="line"><span class="comment"> * 返回值：geneListMap包含两个键值对，分别对应不固定时间和固定时间的基因列表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">coding</span><span class="params">(List&lt;CoursePlan&gt; coursePlanList)</span> &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; geneListMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 不固定0</span></span><br><span class="line">    List&lt;String&gt; unFixedTimeGeneList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 固定1</span></span><br><span class="line">    List&lt;String&gt; fixedTimeGeneList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (CoursePlan coursePlan : coursePlanList) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中查询课程信息</span></span><br><span class="line">        <span class="type">CourseInfo</span> <span class="variable">courseInfo</span> <span class="operator">=</span> courseInfoMapper.selectOne(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;CourseInfo&gt;()</span><br><span class="line">                .select(<span class="string">&quot;teacher_no&quot;</span>, <span class="string">&quot;course_attribute&quot;</span>, <span class="string">&quot;classroom_type&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;course_no&quot;</span>, coursePlan.getCourseNo()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (courseInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">teacherNo</span> <span class="operator">=</span> courseInfo.getTeacherNo();</span><br><span class="line">            <span class="type">String</span> <span class="variable">courseAttribute</span> <span class="operator">=</span> courseInfo.getCourseAttribute();</span><br><span class="line">            <span class="type">String</span> <span class="variable">classroomType</span> <span class="operator">=</span> courseInfo.getClassroomType();</span><br><span class="line">            <span class="comment">// 不固定上课时间</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;0&quot;</span>.equals(coursePlan.getIsFix())) &#123;</span><br><span class="line">                <span class="comment">//得到每周上课的节数，设定2学时为一节课</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> coursePlan.getWeekTime() / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;    <span class="comment">//每周要上几节课就生成几个编码</span></span><br><span class="line">                    <span class="comment">// 编码:不固定时间的课程</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">gene</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span> + coursePlan.getGradeNo() + coursePlan.getClassNo()</span><br><span class="line">                            + teacherNo + coursePlan.getCourseNo() + courseAttribute + classroomType</span><br><span class="line">                            + ConstantInfo.DEFAULT_COURSE_TIME;</span><br><span class="line">                    unFixedTimeGeneList.add(gene);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 固定上课时间</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(coursePlan.getIsFix())) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> coursePlan.getWeekTime() / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                    <span class="comment">// 获得设定的固定时间、</span></span><br><span class="line">                    <span class="comment">//.substring(i * 2, (i + 1) * 2)：对上一步返回的字符串执行子串提取操作。i * 2 是起始索引，(i + 1) * 2 是结束索引（不包括结束索引的字符）。这样就提取了字符串中从索引 i * 2 到 (i + 1) * 2 - 1 的子串。</span></span><br><span class="line">                    <span class="comment">//这通常用于从表示时间的字符串中提取特定时间段的信息。例如，如果i为0，那么这将提取字符串的前两个字符，如果i为1，那么将提取字符串的第三和第四个字符，依此类推。这可以在循环中使用，逐步提取课程的不同时间段。</span></span><br><span class="line">                    <span class="comment">//即为：若一门课的周学时为2，只需输入一个时间，如：01，若周学时为4，则需要输入两个学时，如0506    以此类推</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">courseTime</span> <span class="operator">=</span> coursePlan.getCourseTime().substring(i * <span class="number">2</span>, (i + <span class="number">1</span>) * <span class="number">2</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">gene</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span> + coursePlan.getGradeNo() + coursePlan.getClassNo()</span><br><span class="line">                            + teacherNo + coursePlan.getCourseNo() + courseAttribute + classroomType</span><br><span class="line">                            + courseTime;</span><br><span class="line">                    fixedTimeGeneList.add(gene);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将两种上课时间的列表放入map中</span></span><br><span class="line">    geneListMap.put(UNFIXED_TIME, unFixedTimeGeneList);</span><br><span class="line">    geneListMap.put(IS_FIX_TIME, fixedTimeGeneList);</span><br><span class="line">    <span class="comment">// 进行返回</span></span><br><span class="line">    <span class="keyword">return</span> geneListMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-初始化种群"><a href="#3-初始化种群" class="headerlink" title="3.初始化种群"></a>3.初始化种群</h2><p>这一步是生成遗传算法的初始种群，为后续的进化（选择、交叉、变异）提供多样化的候选解（即排课方案）。</p><p>使用map进行存储，每个个体（<code>individual</code>）代表一种可能的排课方案，种群是多个个体的集合。</p><ul><li>注意这里最外层有一个循环，所以每一个individual对应的value应该是所有courseplan的集合，也就是一个种群。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化种群</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">initializePopulation</span><span class="params">(Map&lt;String, List&lt;String&gt;&gt; geneList)</span> &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; population = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ConstantInfo.POPULATION_SIZE; i++) &#123;</span><br><span class="line">        <span class="comment">// 产生一个个体</span></span><br><span class="line">        List&lt;String&gt; individual = codingTime(geneList);  <span class="comment">//随机产生时间</span></span><br><span class="line">        <span class="comment">//第一次消除冲突 ，为之后的进化作准备</span></span><br><span class="line">        List&lt;String&gt; noConflictList = conflictResolution(individual);</span><br><span class="line">        <span class="comment">//将个体加入到种群中</span></span><br><span class="line">        population.put(<span class="string">&quot;Individual&quot;</span> + i, noConflictList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> population;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的作用就是简单地对于没有指定时间的课程日期进行随机初始化的操作，剔除可能有的时间和教室、教室方面的冲突。</p><h3 id="初始化课程时间"><a href="#初始化课程时间" class="headerlink" title="初始化课程时间"></a>初始化课程时间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给初始基因编码随机分配时间(不固定上课时间的课程)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> geneList 固定时间与不固定时间的编码集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * 分离固定时间和不固定时间的基因列表：</span></span><br><span class="line"><span class="comment"> * 通过 geneList.get(IS_FIX_TIME) 获取固定时间的基因列表。</span></span><br><span class="line"><span class="comment"> * 通过 geneList.get(UNFIXED_TIME) 获取不固定时间的基因列表。</span></span><br><span class="line"><span class="comment"> * 遍历不固定时间的基因列表：</span></span><br><span class="line"><span class="comment"> * 对于每个不固定时间的基因编码，调用 CourseArrangementUtil.randomTime(gene, resultGeneList) 来分配一个随机的上课时间。</span></span><br><span class="line"><span class="comment"> * 将原基因编码的时间部分替换为随机分配的时间，得到分配好随机上课时间的基因编码。</span></span><br><span class="line"><span class="comment"> * 结果集合：将所有固定上课时间的基因编码集合isFixedTimeGeneList加入最终的结果集合 resultGeneList。将分配好上课时间的不固定时间的基因编码集合加入 resultGeneList。</span></span><br><span class="line"><span class="comment"> * 返回值：返回的是一个包含所有固定和不固定上课时间的基因编码的列表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; <span class="title function_">codingTime</span><span class="params">(Map&lt;String, List&lt;String&gt;&gt; geneList)</span> &#123;</span><br><span class="line">    List&lt;String&gt; resultGeneList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; isFixedTimeGeneList = geneList.get(IS_FIX_TIME);</span><br><span class="line">    List&lt;String&gt; unFixedTimeGeneList = geneList.get(UNFIXED_TIME);</span><br><span class="line">    <span class="comment">// 将固定上课时间的课程基因编码集合全部加入集合</span></span><br><span class="line">    resultGeneList.addAll(isFixedTimeGeneList);</span><br><span class="line">    <span class="comment">// 没有固定时间的课程</span></span><br><span class="line">    <span class="keyword">for</span> (String gene : unFixedTimeGeneList) &#123;</span><br><span class="line">        <span class="comment">// 获得一个随机时间</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">courseTime</span> <span class="operator">=</span> CourseArrangementUtil.randomTime();</span><br><span class="line">        <span class="comment">// 得到分配好随机上课时间的基因编码</span></span><br><span class="line">        gene = gene.substring(<span class="number">0</span>, <span class="number">25</span>) + courseTime;</span><br><span class="line">        <span class="comment">// 分配好上课时间的编码集合</span></span><br><span class="line">        resultGeneList.add(gene);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultGeneList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-遗传进化"><a href="#4-遗传进化" class="headerlink" title="4.遗传进化"></a>4.遗传进化</h2><p>通过遗传算法（Genetic Algorithm, GA）的迭代进化（选择、交叉、变异），从初始种群中逐步优化排课方案，最终找到适应度最高（冲突最少、分布最合理）的排课结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遗传进化</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">geneticEvolution</span><span class="params">(Map&lt;String, List&lt;String&gt;&gt; noConflictPopulation)</span> &#123;</span><br><span class="line">    <span class="comment">// 遗传代数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">generation</span> <span class="operator">=</span> ConstantInfo.GENERATION;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=generation;i++) &#123;</span><br><span class="line">        <span class="comment">//选择锦标赛选择法</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt;  selectPopulation =tournamentSelection(noConflictPopulation);</span><br><span class="line">        <span class="comment">//若选择出的种群大小为1直接退出</span></span><br><span class="line">        <span class="keyword">if</span>(selectPopulation.size()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//交叉</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; crossover = crossover(selectPopulation);</span><br><span class="line">        <span class="comment">//变异</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; mutate = mutate(crossover);</span><br><span class="line">        <span class="comment">// 遍历种群中的每一个个体，对其进行冲突解决</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : mutate.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">individualId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            List&lt;String&gt; individual = entry.getValue();</span><br><span class="line">            <span class="comment">// 解决冲突</span></span><br><span class="line">            List&lt;String&gt; noConflictList = conflictResolution(individual);</span><br><span class="line">            <span class="comment">// 将无冲突的个体放回种群中</span></span><br><span class="line">            mutate.put(individualId, noConflictList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//赋值回去，进行循环操作</span></span><br><span class="line">        noConflictPopulation=mutate;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">totalFintness</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String individualId : noConflictPopulation.keySet()) &#123;</span><br><span class="line">            List&lt;String&gt; individual = noConflictPopulation.get(individualId);</span><br><span class="line">            <span class="type">double</span> <span class="variable">fitness</span> <span class="operator">=</span> CourseArrangementUtil.calculateFitness(individual);</span><br><span class="line">            <span class="comment">// 记录最大适应度的个体的基因列表</span></span><br><span class="line">            totalFintness+=fitness;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> avgFitness=totalFintness/noConflictPopulation.size();</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;轮进化&quot;</span>+<span class="string">&quot;平均适应度&quot;</span>+avgFitness);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> noConflictPopulation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先使用锦标赛算法得到每一轮锦标赛中的胜者，然后进行交叉和变异，最后还要用<code>conflictResolution</code></li></ul><p>防止冲突的发生。</p><h3 id="锦标赛算法"><a href="#锦标赛算法" class="headerlink" title="锦标赛算法"></a>锦标赛算法</h3><p>传统锦标赛算法的思路如下。</p><ol><li>模拟锦标赛：<ol><li>把每个元素看作参赛者，进行两两对比，类似于比赛中的对战。</li><li>每一轮比赛，选出胜者（比如较大的值或较小的值）进入下一轮比赛。</li><li>这样逐轮减少参赛者，直到最后剩下一个赢家。</li></ol></li><li>多轮比较：<ol><li>比较会按照树的结构组织起来，通常是一个二叉树。每个叶子节点表示一个元素，父节点表示从两个子节点中选出的较大或较小的元素。</li><li>这个过程类似于“分组”比赛，直到最后一个节点（根节点）决定最终的胜者。</li></ol></li><li>最小化比较次数：<ol><li>相比传统的排序方法（如冒泡排序、快速排序等），锦标赛算法可以有效减少比较次数，尤其在查找最大值或最小值时，能够比其他排序方法更高效。</li></ol></li></ol><p>在这个代码中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Double&gt; fitnessMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String individualId : population.keySet()) &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">fitness</span> <span class="operator">=</span> CourseArrangementUtil.calculateFitness(individual);</span><br><span class="line">    fitnessMap.put(individualId, fitness);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为每个个体（排课方案）计算适应度值（<code>fitness</code>），衡量其优劣（如冲突少、分布均匀则适应度高）。</li></ul><p>然后</p><ul><li><code>tournamentSize</code>：每轮随机选取的个体数量（通常为2-5）。</li><li><code>numTournaments</code>：需生成的下一代个体数量（保持种群规模不变）。</li></ul><p>然后每轮随机选择<code>numTournaments</code>数量的individual，使用<code>CourseArrangementUtil.calculateFitness(individual)</code>计算这个种群的适应度。</p><p>然后循环找出适应度最大的胜者。</p><p>该函数总代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//锦标赛法选择</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">tournamentSelection</span><span class="params">(Map&lt;String, List&lt;String&gt;&gt; population)</span> &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; selectedPopulation = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    Map&lt;String, Double&gt; fitnessMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个个体的适应度值</span></span><br><span class="line">    <span class="keyword">for</span> (String individualId : population.keySet()) &#123;</span><br><span class="line">        List&lt;String&gt; individual = population.get(individualId);</span><br><span class="line">        <span class="type">double</span> <span class="variable">fitness</span> <span class="operator">=</span> CourseArrangementUtil.calculateFitness(individual);</span><br><span class="line">        fitnessMap.put(individualId, fitness);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 竞标赛的参数：锦标赛的个体数量和锦标赛的轮数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">tournamentSize</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">// 锦标赛的个体数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numTournaments</span> <span class="operator">=</span> ConstantInfo.POPULATION_SIZE; <span class="comment">// 锦标赛的轮数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行多轮锦标赛选择</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numTournaments; i++) &#123;</span><br><span class="line">        <span class="comment">// 选择本轮的竞标赛个体</span></span><br><span class="line">        List&lt;String&gt; tournamentIndividuals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; tournamentSize; j++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">randomIndividualId</span> <span class="operator">=</span> (String) population.keySet().toArray()[random.nextInt(population.size())];</span><br><span class="line">            tournamentIndividuals.add(randomIndividualId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选出本轮的锦标赛胜者</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">selectedIndividualId</span> <span class="operator">=</span> tournamentIndividuals.get(<span class="number">0</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">maxFitness</span> <span class="operator">=</span> fitnessMap.get(selectedIndividualId);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt; tournamentSize; k++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">individualId</span> <span class="operator">=</span> tournamentIndividuals.get(k);</span><br><span class="line">            <span class="type">double</span> <span class="variable">fitness</span> <span class="operator">=</span> fitnessMap.get(individualId);</span><br><span class="line">            <span class="keyword">if</span> (fitness &gt; maxFitness) &#123;</span><br><span class="line">                maxFitness = fitness;</span><br><span class="line">                selectedIndividualId = individualId;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将胜者添加到选中个体的集合中  由于键名不能重复，所以就会选择优良个体，淘汰不好个体但并不是都是最好的被选中，而是部分中的最好着被选中</span></span><br><span class="line">        selectedPopulation.put(selectedIndividualId, population.get(selectedIndividualId));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> selectedPopulation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交叉"><a href="#交叉" class="headerlink" title="交叉"></a>交叉</h3><p>交叉是对于一个个体的种群而言的。<em>准确来说每次应该只交换String中的时间字段，由于一个individual它的索引顺序是一致的，所以对应下标的课程一致，只是时间可能不一致，所以可以直接换。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交叉操作</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">crossover</span><span class="params">(Map&lt;String, List&lt;String&gt;&gt; population)</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">populationSize</span> <span class="operator">=</span> population.size();</span><br><span class="line">    <span class="type">int</span> <span class="variable">numIndividualsToCross</span> <span class="operator">=</span> populationSize / <span class="number">2</span>;  <span class="comment">// 交叉操作的个体数量为种群数量的一半</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的种群用于存储交叉后的个体</span></span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; crossedPopulation = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(population);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历进行交叉操作的个体对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numIndividualsToCross; i++) &#123;</span><br><span class="line">        <span class="comment">// 使用交叉率判断是否进行交叉操作</span></span><br><span class="line">        <span class="keyword">if</span> (random.nextDouble() &lt; ConstantInfo.CROSSOVER_RATE) &#123;</span><br><span class="line">            <span class="comment">// 随机选择两个不同的个体进行交叉</span></span><br><span class="line">            String[] individualIds = population.keySet().toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);   <span class="comment">// 种群中个体的键名列表</span></span><br><span class="line">            <span class="comment">// 随机选择两个个体</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">individualId1</span> <span class="operator">=</span> individualIds[random.nextInt(populationSize)];</span><br><span class="line">            <span class="type">String</span> <span class="variable">individualId2</span> <span class="operator">=</span> individualIds[random.nextInt(populationSize)];</span><br><span class="line">            List&lt;String&gt; parent1 = population.get(individualId1);</span><br><span class="line">            List&lt;String&gt; parent2 = population.get(individualId2);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 采用单点交叉方式，交叉相同课程编码的上课时间，由于每个个体中相同课程的索引相同，所以直接交换染色体（准确来说应该只交换String中的时间字段）</span></span><br><span class="line">            <span class="comment">// 随机选择交叉的染色体索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">chromosomeIndex</span> <span class="operator">=</span> random.nextInt(Math.min(parent1.size(), parent2.size()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建两个新的个体列表用于存储交叉后的个体</span></span><br><span class="line">            List&lt;String&gt; crossedParent1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(parent1);</span><br><span class="line">            List&lt;String&gt; crossedParent2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(parent2);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换两个个体的染色体</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> crossedParent1.get(chromosomeIndex);</span><br><span class="line">            crossedParent1.set(chromosomeIndex, crossedParent2.get(chromosomeIndex));</span><br><span class="line">            crossedParent2.set(chromosomeIndex, temp);</span><br><span class="line">            <span class="comment">//交叉操作也有可能将两个适应性高的个体替换为了适应性低的个体，所以，我们将交叉前后的个体都保存下来，在下次种群更新时再进行选择。</span></span><br><span class="line">            <span class="comment">// 将交叉后的个体添加到新种群中</span></span><br><span class="line">            crossedPopulation.put(<span class="string">&quot;CrossedIndividual&quot;</span> + i * <span class="number">2</span>, crossedParent1);</span><br><span class="line">            crossedPopulation.put(<span class="string">&quot;CrossedIndividual&quot;</span> + (i * <span class="number">2</span> + <span class="number">1</span>), crossedParent2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> crossedPopulation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变异"><a href="#变异" class="headerlink" title="变异"></a>变异</h3><ul><li>根据预设的变异率（<code>MUTATION_RATE</code>），计算需要变异的个体数量。</li><li>例如：种群大小&#x3D;100，变异率&#x3D;0.1 → 10个个体需要变异。</li><li>复制原始个体的基因列表（避免直接修改原数据）。</li><li>随机选中个体中的某一门课程（基因）。</li><li><strong>仅变异“不固定时间”的课程，仅修改时间部分（最后2位）。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变异操作</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">mutate</span><span class="params">(Map&lt;String, List&lt;String&gt;&gt; population)</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; mutatedPopulation = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算需要变异的个体数量</span></span><br><span class="line">    <span class="comment">/*通常在遗传算法进行的早期要设置较高的变异概率，这样可以快速搜索到新的性状，后期为了收敛速度，设置较小的变异概率。  </span></span><br><span class="line"><span class="comment">    由于进化后期，种群数量下降，所以需要进行变异操作的个体就少了</span></span><br><span class="line"><span class="comment">    为了避免进入局部最优，在实际应用中通常需要降低高适应性个体的变异概率，提高低适应性个体的变异概率*/</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numToMutate</span> <span class="operator">=</span> (<span class="type">int</span>) (population.size() * ConstantInfo.MUTATION_RATE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的种群对象，用于存储变异后的个体</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : population.entrySet()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">individualId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        List&lt;String&gt; individual = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(entry.getValue()); <span class="comment">// 复制原始个体的基因列表</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对个体进行变异操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numToMutate; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> individual.size();</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> random.nextInt(size);</span><br><span class="line">            <span class="type">String</span> <span class="variable">gene</span> <span class="operator">=</span> individual.get(temp);</span><br><span class="line">            <span class="keyword">if</span> (CourseArrangementUtil.cutGene(ConstantInfo.IS_FIX, gene).equals(<span class="string">&quot;0&quot;</span>)) &#123;  <span class="comment">//对上课时间不固定的进行变异操作</span></span><br><span class="line">                <span class="comment">// 随机给它一个上课时间</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">newCourseTime</span> <span class="operator">=</span> CourseArrangementUtil.randomTime();</span><br><span class="line">                <span class="comment">// 变异操作</span></span><br><span class="line">                gene = gene.substring(<span class="number">0</span>, <span class="number">25</span>) + newCourseTime;</span><br><span class="line">                <span class="comment">// 替换原来的基因</span></span><br><span class="line">                individual.set(temp, gene);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将个体添加到新的种群中，无论是否进行了变异操作</span></span><br><span class="line">        mutatedPopulation.put(individualId, individual);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mutatedPopulation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h4><p><strong>问题1：变异粒度过大</strong></p><ul><li>当前逻辑：直接替换整个时间字段（如 <code>&quot;01&quot;</code> → <code>&quot;05&quot;</code>）。</li><li>风险：可能破坏已优化的时间分配（例如教师时间均衡性）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小幅度变异（如仅调整上午/下午）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">newTime</span> <span class="operator">=</span> CourseArrangementUtil.adjustTime(gene, <span class="string">&quot;±1节&quot;</span>); </span><br></pre></td></tr></table></figure><p><strong>问题2：忽略适应性权重</strong></p><ul><li>当前逻辑：所有个体以相同概率变异。</li><li>更优策略：<ul><li>低适应度个体（冲突多的方案）应提高变异概率，加速淘汰。</li><li>高适应度个体（优质方案）应降低变异概率，保护优良基因。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">fitness</span> <span class="operator">=</span> calculateFitness(individual);</span><br><span class="line"><span class="type">double</span> <span class="variable">adaptiveMutationRate</span> <span class="operator">=</span> (<span class="number">1</span> - fitness) * baseMutationRate; <span class="comment">// 动态调整</span></span><br></pre></td></tr></table></figure><h3 id="冲突解决函数"><a href="#冲突解决函数" class="headerlink" title="冲突解决函数"></a>冲突解决函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冲突消除,若同一个班同一时间上多门课或同一个讲师同一时间上多门课</span></span><br><span class="line"><span class="comment"> * 解决：重新分配一个时间，直到所有的基因编码中不再存在上课时间冲突为止</span></span><br><span class="line"><span class="comment"> * 因素：讲师-课程-时间-教室</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resultGeneList 所有个体集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * 使用两层循环遍历所有基因编码：</span></span><br><span class="line"><span class="comment"> * 外层循环（i）遍历所有基因编码，获取基因编码的讲师编号、上课时间、班级编号。</span></span><br><span class="line"><span class="comment"> * 内层循环（j）从外层循环的下一个位置开始，遍历剩余的基因编码，获取当前循环基因编码的讲师编号、上课时间、班级编号。</span></span><br><span class="line"><span class="comment"> * 在内层循环中进行冲突检测：如果两个基因编码的上课时间相同，并且班级编号相同或讲师编号相同，表示发生了冲突。</span></span><br><span class="line"><span class="comment"> * 如果发生了冲突：</span></span><br><span class="line"><span class="comment"> * 输出提示信息，使用 CourseArrangementUtil.randomTime方法生成一个新的上课时间。</span></span><br><span class="line"><span class="comment"> * 循环结束后，输出冲突发生的次数。</span></span><br><span class="line"><span class="comment"> * 通过修改课程计划的上课时间，解决了同一个班同一时间上多门课或同一个讲师同一时间上多门课的问题，直到没有冲突为止。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; <span class="title function_">conflictResolution</span><span class="params">(List&lt;String&gt; resultGeneList)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">conflictTimes</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    List&lt;String&gt; newResultGeneList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(resultGeneList); <span class="comment">// 创建一个新的列表来存储替换后的基因序列</span></span><br><span class="line">    <span class="comment">//标签（label），用于在循环中实现跳转。</span></span><br><span class="line">    eitx:</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; newResultGeneList.size(); i++) &#123;</span><br><span class="line">        <span class="comment">//得到集合中每一条基因编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">gene</span> <span class="operator">=</span> newResultGeneList.get(i);</span><br><span class="line">        <span class="type">String</span> <span class="variable">isFix</span> <span class="operator">=</span> CourseArrangementUtil.cutGene(ConstantInfo.IS_FIX, gene);</span><br><span class="line">        <span class="type">String</span> <span class="variable">teacherNo</span> <span class="operator">=</span> CourseArrangementUtil.cutGene(ConstantInfo.TEACHER_NO, gene);</span><br><span class="line">        <span class="type">String</span> <span class="variable">courseTime</span> <span class="operator">=</span> CourseArrangementUtil.cutGene(ConstantInfo.CLASS_TIME, gene);</span><br><span class="line">        <span class="type">String</span> <span class="variable">classNo</span> <span class="operator">=</span> CourseArrangementUtil.cutGene(ConstantInfo.CLASS_NO, gene);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; newResultGeneList.size(); j++) &#123;</span><br><span class="line">            <span class="comment">// 再找剩余的基因编码对比</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">tempGene</span> <span class="operator">=</span> newResultGeneList.get(j);</span><br><span class="line">            <span class="type">String</span> <span class="variable">tempIsFix</span> <span class="operator">=</span> CourseArrangementUtil.cutGene(ConstantInfo.IS_FIX, tempGene);</span><br><span class="line">            <span class="type">String</span> <span class="variable">tempTeacherNo</span> <span class="operator">=</span> CourseArrangementUtil.cutGene(ConstantInfo.TEACHER_NO, tempGene);</span><br><span class="line">            <span class="type">String</span> <span class="variable">tempCourseTime</span> <span class="operator">=</span> CourseArrangementUtil.cutGene(ConstantInfo.CLASS_TIME, tempGene);</span><br><span class="line">            <span class="type">String</span> <span class="variable">tempClassNo</span> <span class="operator">=</span> CourseArrangementUtil.cutGene(ConstantInfo.CLASS_NO, tempGene);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (courseTime.equals(tempCourseTime)) &#123;  <span class="comment">//当上课时间相同                          //即同一时刻，一个班只能上一门课，一个老师，只能给一个班上课</span></span><br><span class="line">                <span class="keyword">if</span> (classNo.equals(tempClassNo) || teacherNo.equals(tempTeacherNo)) &#123;     <span class="comment">//出现相同班级或者教师，则产生冲突</span></span><br><span class="line">                    <span class="comment">//System.out.println(&quot;出现冲突情况&quot;);</span></span><br><span class="line">                    conflictTimes++;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">newCourseTime</span> <span class="operator">=</span> CourseArrangementUtil.randomTime();</span><br><span class="line"></span><br><span class="line">                    String newGene;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(tempIsFix.equals(<span class="string">&quot;1&quot;</span>))&#123;</span><br><span class="line">                        newGene = gene.substring(<span class="number">0</span>, <span class="number">25</span>) + newCourseTime;       <span class="comment">//若j对应的编码上课时间固定或者i，j的上课时间都固定  修改i对应的编码</span></span><br><span class="line">                        newResultGeneList.set(i, newGene);    <span class="comment">// 替换原基因序列中的基因</span></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        newGene = tempGene.substring(<span class="number">0</span>, <span class="number">25</span>) + newCourseTime;   <span class="comment">//若i对应的上课时间固定或者二者时间都不固定  修改j对应的编码</span></span><br><span class="line">                        newResultGeneList.set(j, newGene);    <span class="comment">// 替换原基因序列中的基因</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    i=-<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span> eitx;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//System.out.println(&quot;冲突发生次数:&quot; + conflictTimes);</span></span><br><span class="line">    <span class="keyword">return</span> newResultGeneList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次解决冲突后，重新从第一门课程开始检测，确保新修改的时间不会引发其他冲突。时间复杂度较高。</p><h2 id="5-找出适应度最高的个体"><a href="#5-找出适应度最高的个体" class="headerlink" title="5.找出适应度最高的个体"></a>5.找出适应度最高的个体</h2><p>这个很简单，就是遍历找最值即可，每次取种群中适应度最好的那一个方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选出适应度最高的个体</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; <span class="title function_">findBestIndividual</span><span class="params">(Map&lt;String, List&lt;String&gt;&gt; population)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">maxFitness</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    List&lt;String&gt; bestIndividual = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (population.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果种群中只有一个个体，直接返回该个体</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; individual : population.values()) &#123;</span><br><span class="line">            bestIndividual = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(individual); <span class="comment">// 复制基因列表</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历种群中的每一个个体，计算适应度并找出最大适应度的个体</span></span><br><span class="line">        <span class="keyword">for</span> (String individualId : population.keySet()) &#123;</span><br><span class="line">            List&lt;String&gt; individual = population.get(individualId);</span><br><span class="line">            <span class="type">double</span> <span class="variable">fitness</span> <span class="operator">=</span> CourseArrangementUtil.calculateFitness(individual);</span><br><span class="line">            <span class="comment">// 记录最大适应度的个体的基因列表</span></span><br><span class="line">            <span class="keyword">if</span> (fitness &gt; maxFitness) &#123;</span><br><span class="line">                maxFitness = fitness;</span><br><span class="line">                bestIndividual = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(individual); <span class="comment">// 复制基因列表</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;每轮进化的最佳适应度：&quot;</span>+maxFitness);</span><br><span class="line">    <span class="keyword">return</span> bestIndividual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-冲突检测并解码"><a href="#6-冲突检测并解码" class="headerlink" title="6.冲突检测并解码"></a>6.冲突检测并解码</h2><p>冲突检测如上，解码如下。怎么编码就怎么解码即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码染色体中的基因，按照之前的编码解码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultList 全部上课计划实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * 对基因编码的解码操作，将编码还原成上课计划实体（Schedule）的列表。</span></span><br><span class="line"><span class="comment">     * 解码的规则如下：</span></span><br><span class="line"><span class="comment">     * 是否固定（1位）</span></span><br><span class="line"><span class="comment">     * 年级编号（2位）</span></span><br><span class="line"><span class="comment">     * 班级编号（8位）</span></span><br><span class="line"><span class="comment">     * 讲师编号（5位）</span></span><br><span class="line"><span class="comment">     * 课程编号（6位）</span></span><br><span class="line"><span class="comment">     * 课程属性（1位）</span></span><br><span class="line"><span class="comment">     * 教室类型（2位）</span></span><br><span class="line"><span class="comment">     * 上课时间（2位）</span></span><br><span class="line"><span class="comment">     * 教室编号（5位）</span></span><br><span class="line"><span class="comment">     * 共32位</span></span><br><span class="line"><span class="comment">     * 编码规则为：是否固定+年级编号+班级编号+教师编号+课程编号+课程属性+教室类型+上课时间+教室编号(遗传算法执行完最后再分配教室,并判断是否存在冲突)</span></span><br><span class="line"><span class="comment">     * 使用 CourseArrangementUtil.cutGene方法根据编码规则提取各个字段的值。</span></span><br><span class="line"><span class="comment">     * 创建 Schedule 对象，并设置年级、班级、课程、讲师、教室、上课时间等属性。</span></span><br><span class="line"><span class="comment">     * 将每个解码后的 Schedule 对象添加到 scheduleList 中。</span></span><br><span class="line"><span class="comment">     * 返回解码后的 scheduleList。</span></span><br><span class="line"><span class="comment">     * 这段代码的作用是将基因编码还原为可读的上课计划实体，方便后续操作和展示。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Schedule&gt; <span class="title function_">decoding</span><span class="params">(List&lt;String&gt; resultList)</span> &#123;    <span class="comment">//解码操作</span></span><br><span class="line">        List&lt;Schedule&gt; scheduleList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String gene : resultList) &#123;</span><br><span class="line">            <span class="type">Schedule</span> <span class="variable">schedule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Schedule</span>();</span><br><span class="line">            <span class="comment">// 年级</span></span><br><span class="line">            schedule.setGradeNo(CourseArrangementUtil.cutGene(ConstantInfo.GRADE_NO, gene));</span><br><span class="line">            <span class="comment">// 班级</span></span><br><span class="line">            schedule.setClassNo(CourseArrangementUtil.cutGene(ConstantInfo.CLASS_NO, gene));</span><br><span class="line">            <span class="comment">// 课程</span></span><br><span class="line">            schedule.setCourseNo(CourseArrangementUtil.cutGene(ConstantInfo.COURSE_NO, gene));</span><br><span class="line">            <span class="comment">// 讲师</span></span><br><span class="line">            schedule.setTeacherNo(CourseArrangementUtil.cutGene(ConstantInfo.TEACHER_NO, gene));</span><br><span class="line">            <span class="comment">// 教室</span></span><br><span class="line">            schedule.setClassroomNo(CourseArrangementUtil.cutGene(ConstantInfo.CLASSROOM_NO, gene));</span><br><span class="line">            <span class="comment">// 上课时间</span></span><br><span class="line">            schedule.setCourseTime(CourseArrangementUtil.cutGene(ConstantInfo.CLASS_TIME, gene));</span><br><span class="line">            scheduleList.add(schedule);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> scheduleList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 遗传算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.4 路由算法与路由协议</title>
      <link href="/2025/04/08/4-4%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"/>
      <url>/2025/04/08/4-4%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p><img src="/2025/04/08/4-4%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/image-13.png"></p><p>画圈的这两种是用在自治系统内部的协议</p><ol><li><p>RIP (Routing Information Protocol) - 路由信息协议</p></li><li><p>OSPF (Open Shortest Path First) - 开放最短路径优先协议</p></li></ol><p>而BGP是在自治系统外部的协议。</p><p><img src="/2025/04/08/4-4%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/image-14.png"></p><p>如图所示，画圈的属于一个自治系统，边界网关之间的连接属于BGP协议。</p><h1 id="RIP-routing-information-protocal"><a href="#RIP-routing-information-protocal" class="headerlink" title="RIP(routing information protocal)"></a>RIP(routing information protocal)</h1><ul><li><p>采用<strong>距离-向量算法</strong></p></li><li><p>基于分布式的基于距离向量的路由选择协议，是因特网的协议标准，最大的优点是简单。</p></li><li><p>维护从他自己到每一个目的网络的唯一最佳举例记录。</p><ul><li><p>距离：指的是跳数</p></li><li><p>距离为1表示和路由器自己直接相连的网络</p></li></ul><p><img src="/2025/04/08/4-4%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/image-11.png"></p></li></ul><p>如图所示，rip对应的裸游表如图所示，直接交付说明路由器和目的网络直接相连。</p><ul><li>rip要求一条路由最多只能包含15个路由器，所以16不可达</li></ul><h2 id="rip路由表如何完善"><a href="#rip路由表如何完善" class="headerlink" title="rip路由表如何完善"></a>rip路由表如何完善</h2><ul><li><p>仅仅和相邻路由器交换信息</p></li><li><p>路由器交换的信息是自己的路由表</p></li><li><p><strong>每30秒</strong>交换一次信息，然后更新信息。</p><ul><li>如果超过30分钟没有邻居的信息通告，则判定邻居没了，并更新自己的路由表。</li></ul></li><li><p>路由表刚开始工作的时候，<strong>只知道直连的网络（距离为1）</strong>，接着每一个路由器（30秒一次）也只会<strong>和相邻的路由器交换信息并更新路由信息（只路由表中的所有信息）。</strong></p></li><li><p>经过若干次更新之后，所有路由器都会知道到达本自治系统的任何一个网络的最短距离和下一跳地址，即“<strong>收敛</strong>”。</p></li></ul><h2 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h2><ol><li><p>修改相邻路由器发来的RIP报文中所有表项</p><ol><li><p>对相邻路由器X，修改此报文的所有项目，把下一跳的地址改为X，并把所有字段的距离+1。</p></li><li><p>例如R1就是这么做的</p></li></ol></li></ol><p><img src="/2025/04/08/4-4%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/image.png"></p><ul><li><p>对修改之后RIP报文中的每一个项目：</p><ol><li><p><strong>R1路由表中若没有net3（不包含相同的目的网络），则把项目直接填入R1路由表</strong></p></li><li><p><strong>R1路由表汇总包含net3（包含相同的目的网络）</strong></p><ol><li><p><strong>若下一跳是X，则直接更新</strong></p></li><li><p><strong>若下一跳不是X，分两种情况（例如对于Net3 2 R3，更短，更新成新的路由R3；对于Net3 3 R3不是更短，不更新）</strong></p><ol><li><p><strong>原来距离比走X更短则更新</strong></p></li><li><p><strong>若大于等于原来距离则不做更新</strong></p></li></ol></li></ol></li></ol></li><li><p>如果180s还没有收到相邻路由表的信息更新路由表，则将X标记为不可达，即<strong>把距离记为16</strong></p></li><li><p>返回</p></li></ul><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>例题1：</p><p>首先要修改R4发来的路由信息表，即距离加一，并把下一条地址首先全置为R4</p><p>然后再进行进一步判断，如果没有的信息直接更新，目的网络相同且下一跳地址相同以新的为准，不同则采用短的那个。</p><p><img src="/2025/04/08/4-4%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/image-10.png"></p><p>例题2：</p><p>本质上距离-向量算法就是求最短的距离路径。</p><p><img src="/2025/04/08/4-4%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/image-9.png"></p><h2 id="RIP报文格式"><a href="#RIP报文格式" class="headerlink" title="RIP报文格式"></a>RIP报文格式</h2><p><strong>RIP是应用层协议</strong></p><p><img src="/2025/04/08/4-4%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/image-5.png"></p><h2 id="RIP特点"><a href="#RIP特点" class="headerlink" title="RIP特点"></a>RIP特点</h2><p><strong>好消息传得快，坏消息（故障消息）传递的慢（慢收敛）</strong></p><p>比如考虑以下这种情况：</p><ul><li><p>R1到网1的距离为16，但是此时R1收到了R2的RIP报文，该报文中包含目的网络为网1的表项</p></li><li><p>此时R1按照标准操作，发现目的网络相同，下一跳地址不同，于是选择距离较短的，也就是1,3,R2</p></li><li><p>然后R2也会受到R1的RIP报文执行类似操作，距离不断+1</p></li><li><p>直到距离&gt;&#x3D;16,才会标记为不可达&#x20;</p></li></ul><p><img src="/2025/04/08/4-4%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/image-12.png"></p><h1 id="OSPF-Open-Shortest-Path-First"><a href="#OSPF-Open-Shortest-Path-First" class="headerlink" title="OSPF(Open Shortest Path First)"></a>OSPF(Open Shortest Path First)</h1><p>Open指的是ospf协议是不是受某一个厂家控制，而是公开发表的。</p><p>Shortest path first指的是使用了dij算法。</p><p>opsf的最主要特征就是使用了分布式的链路状态协议。</p><h2 id="OSPF特点"><a href="#OSPF特点" class="headerlink" title="OSPF特点"></a>OSPF特点</h2><ul><li><p>和谁交换：类似广播形式，使用“洪泛法”，每一个路由器都通过端口向<strong>所有的路由器</strong>发送信息。</p></li><li><p>交换的信息：是本路由器相邻的所有路由器的链路状态（与哪些路由器相邻、链路的代价如费用、时延、距离、带宽等）</p><ul><li>而RIP是相邻路由器和距离。</li></ul></li><li><p>交换的时间：只有当链路状态发生变化的时候才会使用之前说过的“洪泛法”向所有的路由器发送信息。</p></li></ul><p>最后，所有的的路由器都可以建立一个<strong>链路状态数据库</strong>，即<strong>全网拓扑图</strong>。</p><h2 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h2><ol><li><p>每个路由器发现它的邻居结点【通过HELLO问候分组】，并了解各个邻居结点的网路地址</p></li><li><p>设置到他的每个邻居的<strong>成本度量metric</strong></p></li><li><p>构造【DD数据库描述分组】，向邻居结点发送自己的<strong>链路状态数据库（全网的拓扑结构图）</strong>&#x4E2D;的所有链路状态项目的摘要信息</p></li><li><p>如果邻站分组中的摘要自己都有，则不做处理；如果没有或者是新的，则发送【LSR链路状态请求分组】请求自己没有的和比自己新的信息。</p></li><li><p>收到邻站的LSR分组之后，发送【LSU链路状态更新分组】进行更新。</p></li><li><p>更新完毕之后，邻站返回一个【LSAck链路状态确认分组】进行确认。&#x20;</p></li></ol><p>当某个路由器的链路状态发生变化时：</p><ul><li><p>泛洪发送【LSU（链路状态更新）分组】进行全网更新。</p></li><li><p>其他路由器更新完毕后，返回【LSAck（链路状态确认）分组】进行确认。</p></li><li><p><em>使用Dijkstra根据自己的链路状态数据库构造到其他节点间的最短路径。</em></p></li></ul><h2 id="OSPF的区域"><a href="#OSPF的区域" class="headerlink" title="OSPF的区域"></a>OSPF的区域</h2><p><img src="/2025/04/08/4-4%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/image-4.png"></p><p>如图，ospf将一个自治系统继续划分，</p><h2 id="OSPF分组"><a href="#OSPF分组" class="headerlink" title="OSPF分组"></a>OSPF分组</h2><p>opsf直接使用ip数据报进行传送，是<strong>网络层协议</strong>。</p><p><img src="/2025/04/08/4-4%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/image-8.png"></p><h1 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h1><p>BGP协议是外部网关协议的一个代表</p><ul><li><p>和谁交换：与其他AS（Autonomous System（自治系统））的邻站BGP 发言人的交换信息</p></li><li><p>交换什么：交换的网络可达性的信息，即要到达某个网络所要经历的一系列AS</p></li><li><p>多久交换：发生变化时更新有变化的部分</p></li></ul><p><img src="/2025/04/08/4-4%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/image-6.png"></p><h2 id="BGP交换信息的过程"><a href="#BGP交换信息的过程" class="headerlink" title="BGP交换信息的过程"></a>BGP交换信息的过程</h2><p><img src="/2025/04/08/4-4%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/image-7.png"></p><p>边界路由器既要明确在AS内部应该如何走；到达其他AS应该如何走。</p><p>交换的信息是经过AS的路径</p><h2 id="BGP报文格式"><a href="#BGP报文格式" class="headerlink" title="BGP报文格式"></a>BGP报文格式</h2><p>BGP是应用层协议，使用TCP。</p><p><img src="/2025/04/08/4-4%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/image-2.png"></p><h2 id="BGP特点"><a href="#BGP特点" class="headerlink" title="BGP特点"></a>BGP特点</h2><p><img src="/2025/04/08/4-4%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/image-3.png"></p><h2 id="BGP-4的四种报文"><a href="#BGP-4的四种报文" class="headerlink" title="BGP-4的四种报文"></a>BGP-4的四种报文</h2><ol><li><p><strong>OPEN（打开）报文</strong>：用来和相邻的另一个BGP发言人进行连接，并认证发送方</p></li><li><p><strong>UPDATE（更新）报文</strong>：通告新路径或者撤销原路径</p></li><li><p><strong>KEEPALIVE（保活）报文</strong>：在无UPDATE时，周期性确定邻站的连接性；也作为OPEN的确认</p></li><li><p><strong>NOTIFICATION（通知）报文</strong>：报告先前报文的差错；也用于关闭TCP连接</p></li></ol><h1 id="总结比较"><a href="#总结比较" class="headerlink" title="总结比较"></a>总结比较</h1><p><img src="/2025/04/08/4-4%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/image-1.png"></p><p><img src="/2025/04/08/4-4%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/image-15.png"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.3 计算机的性能指标</title>
      <link href="/2025/04/07/1-3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/"/>
      <url>/2025/04/07/1-3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h1 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h1><p>根据MAR和MDR的大小来判断</p><p><img src="/2025/04/07/1-3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-2.png"></p><h2 id="2的次方大小速记"><a href="#2的次方大小速记" class="headerlink" title="2的次方大小速记"></a>2的次方大小速记</h2><p><img src="/2025/04/07/1-3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-3.png"></p><p><img src="/2025/04/07/1-3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-5.png"></p><h1 id="CPU的性能指标"><a href="#CPU的性能指标" class="headerlink" title="CPU的性能指标"></a>CPU的性能指标</h1><p><img src="/2025/04/07/1-3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-6.png"></p><h2 id="CPU主频"><a href="#CPU主频" class="headerlink" title="CPU主频"></a>CPU主频</h2><p>CPU内部数字脉冲信号的频率，单位HZ</p><h2 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h2><p>CPU主频 &#x3D; 1&#x2F;cCPU时钟周期</p><h2 id="CPI-Clock-cycle-per-Instruction"><a href="#CPI-Clock-cycle-per-Instruction" class="headerlink" title="CPI(Clock cycle per Instruction)"></a>CPI(Clock cycle per Instruction)</h2><p>每个指令执行所需的时钟周期</p><h2 id="IPS-Instructions-per-second"><a href="#IPS-Instructions-per-second" class="headerlink" title="IPS(Instructions per second)"></a>IPS(Instructions per second)</h2><p>每秒执行多少条指令，IPS &#x3D; 指令数&#x2F;秒</p><p>IPS &#x3D; (1&#x2F;时钟周期大小)&#x2F;(时钟周期数&#x2F;指令数) &#x3D; <strong>主频&#x2F;平均CPI</strong></p><h2 id="FLOPS-Floating-point-Operations-per-second"><a href="#FLOPS-Floating-point-Operations-per-second" class="headerlink" title="FLOPS(Floating-point Operations per second)"></a>FLOPS(Floating-point Operations per second)</h2><p>注意这里的K，M等是1000为一个阶级，和存储容量以1024为一个阶级不一样</p><p><img src="/2025/04/07/1-3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image.png"></p><h1 id="系统整体的性能指标"><a href="#系统整体的性能指标" class="headerlink" title="系统整体的性能指标"></a>系统整体的性能指标</h1><h2 id="静态指标"><a href="#静态指标" class="headerlink" title="静态指标"></a>静态指标</h2><p><img src="/2025/04/07/1-3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-1.png"></p><h3 id="数据通路带宽"><a href="#数据通路带宽" class="headerlink" title="数据通路带宽"></a>数据通路带宽</h3><p>总线并行一次传输的信息位数</p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>系统在单位时间内处理的请求数量（请求是比较宽泛的概念）</p><h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><p>用户发送请求到系统相应请求的时间</p><h2 id="动态测试（基准测序）"><a href="#动态测试（基准测序）" class="headerlink" title="动态测试（基准测序）"></a>动态测试（基准测序）</h2><p><img src="/2025/04/07/1-3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/image-4.png"></p><h1 id="本节问题"><a href="#本节问题" class="headerlink" title="本节问题"></a>本节问题</h1><h2 id="主频高的CPU一定比主频低的CPU快吗？"><a href="#主频高的CPU一定比主频低的CPU快吗？" class="headerlink" title="主频高的CPU一定比主频低的CPU快吗？"></a>主频高的CPU一定比主频低的CPU快吗？</h2><p>不是，快慢主要看CPU执行时间</p><p>CPU执行时间 &#x3D; CPU指令周期数&#x2F;主频 &#x3D; (指令条数*CPI)&#x2F;主频，可见还和CPI相关。</p><h2 id="如果平均CPI相同的CPU，那主频高的一定快吗？"><a href="#如果平均CPI相同的CPU，那主频高的一定快吗？" class="headerlink" title="如果平均CPI相同的CPU，那主频高的一定快吗？"></a>如果平均CPI相同的CPU，那主频高的一定快吗？</h2><p>不一定，还和计算机的结构有关。比如有的计算机不支持乘法指令，只能通过加法完成，那它就有可能慢。</p><h2 id="基准程序执行的越快说明机器性能越好吗？"><a href="#基准程序执行的越快说明机器性能越好吗？" class="headerlink" title="基准程序执行的越快说明机器性能越好吗？"></a>基准程序执行的越快说明机器性能越好吗？</h2><p>不一定， 基准程序中的<strong>语句存在频度差异</strong>，运行结果不能完全说明问题。</p><ul><li>比如有的计算机用于图像处理，它的显卡方面的测试语句频度会更高，但不能证明它的其他方面性能更好。</li></ul><h2 id="解释：字、字长、机器字长、指令字长、存储字长的区别和联系？"><a href="#解释：字、字长、机器字长、指令字长、存储字长的区别和联系？" class="headerlink" title="解释：字、字长、机器字长、指令字长、存储字长的区别和联系？"></a>解释：字、字长、机器字长、指令字长、存储字长的区别和联系？</h2><ul><li><p>字长：CPU内部进行<strong>整数运算的数据通路的宽度</strong>，因此字长等于CPU内部用于<strong>整数运算的运算器位数</strong>和<strong>通用计算器宽度</strong>，反应计算机处理信息能力。</p></li><li><p>字：字用来表示<strong>被处理信息的单位</strong>，用来<strong>度量数据类型的宽度</strong>，如x86定义一个字为16位。</p></li><li><p>指令字长：一个指令中包含的二进制代码的位数。</p><ul><li><p>一字节的整数倍</p></li><li><p>一般取存储字长的整数倍，比如若是存储字长的两倍，则需要2个访存周期来去取出一条指令或一个数据。</p></li></ul></li><li><p>存储字长：一个存储单元的二进制代码的位数。</p><ul><li>一字节的整数倍</li></ul></li></ul><h1 id="本节习题"><a href="#本节习题" class="headerlink" title="本节习题"></a>本节习题</h1><p>磁盘可以永久性的存放数据恩惠程序</p><p>寄存器是由触发器构成的。</p><p><strong>机器字长与MDR的位数与指令字长的位数：不同</strong></p><p>机器字长</p><ul><li><p>是CPU中定点运算的数据通路宽度</p></li><li><p>一般与CPU中通用寄存器的位数有关</p></li></ul><p>存储字长</p><ul><li>等于MDR的位数</li></ul><p>指令字长：可以是单字长、双字长、半字长</p><p>寄存器的透明性</p><ul><li><p>可以用JMP指令设置PC的值，可见状态寄存器PSW，通用寄存器。</p></li><li><p>IR、MAR、MDR是CPU内部的工作寄存器，对程序员不可见。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.2 计算机系统层次结构</title>
      <link href="/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/"/>
      <url>/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p><img src="/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/image.png"></p><h1 id="冯诺依曼计算机"><a href="#冯诺依曼计算机" class="headerlink" title="冯诺依曼计算机"></a>冯诺依曼计算机</h1><p><img src="/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/image-1.png"></p><h2 id="传统冯诺依曼机（运算器为中心）"><a href="#传统冯诺依曼机（运算器为中心）" class="headerlink" title="传统冯诺依曼机（运算器为中心）"></a>传统冯诺依曼机（运算器为中心）</h2><p><img src="/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/image-2.png"></p><p><strong>对于特点4，可以看本章笔记中的计算机运行过程，但是要注意有可能一条指令可以包含多个地址码，比如二地址指令。</strong></p><p>特点5指的是指令和数据都会被提前存到主存里面。</p><p>类比以下这张图，可以发现<strong>以运算器为中心会导致效率低下</strong>。</p><p><img src="/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/image-3.png"></p><h2 id="现代计算机结构（存储器为中心）"><a href="#现代计算机结构（存储器为中心）" class="headerlink" title="现代计算机结构（存储器为中心）"></a>现代计算机结构（存储器为中心）</h2><p><img src="/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/image-4.png"></p><h3 id="现代计算机结构划分"><a href="#现代计算机结构划分" class="headerlink" title="现代计算机结构划分"></a>现代计算机结构划分</h3><p><img src="/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/image-5.png"></p><p>重点看画圈部分</p><ul><li><p>现代计算机由存储器为中心</p></li><li><p>cpu由运算器和控制器组成</p></li><li><p>主机包括cpu和主存</p><ul><li><p>主机不是台式电脑的主机，而是由cpu和主存储器组成的</p></li><li><p>主存储器，又称主存（实际上就是<strong>内存</strong>）</p></li></ul></li><li><p>I&#x2F;O设备除了包括输入和输出还包括<strong>辅存（例如磁盘这些）</strong></p></li><li><p>存储器包括主存和辅存。</p></li></ul><h1 id="计算机各硬件部件工作原理"><a href="#计算机各硬件部件工作原理" class="headerlink" title="计算机各硬件部件工作原理"></a>计算机各硬件部件工作原理</h1><p><img src="/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/image-6.png"></p><h2 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h2><p><img src="/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/image-7.png"></p><h3 id="MAR-memory-address-register"><a href="#MAR-memory-address-register" class="headerlink" title="MAR(memory address register)"></a>MAR(memory address register)</h3><ul><li><p>用于指明要读&#x2F;写哪个存储单元。</p></li><li><p><strong>其位数反映存储单元数量</strong>。</p></li></ul><h3 id="MDR-memory-data-register"><a href="#MDR-memory-data-register" class="headerlink" title="MDR(memory data register)"></a>MDR(memory data register)</h3><ul><li><p>用于暂存要读&#x2F;写的数据。</p></li><li><p><strong>其位数 &#x3D; 存储字长</strong>。</p></li></ul><p><strong>注意，现代计算机中MAR和MDR可能被集合到CPU中！</strong></p><h3 id="存储单元、存储字、存储字长"><a href="#存储单元、存储字、存储字长" class="headerlink" title="存储单元、存储字、存储字长"></a>存储单元、存储字、存储字长</h3><ol><li><strong>存储单元（Storage Unit）​</strong></li></ol><ul><li><p><strong>定义</strong>：主存储器（内存）中可独立寻址的<strong>最小存储单位</strong>。</p></li><li><p><strong>特点</strong>：</p><ul><li><p>每个存储单元有唯一地址（由MAR寄存器指向）。</p></li><li><p>可存储一个固定长度的二进制数据（即存储字）。</p></li></ul></li><li><p><strong>示例</strong>：若内存容量为4GB，按字节寻址，则有约42亿个存储单元（每个单元1字节）。</p></li></ul><ul><li><strong>存储字（Storage Word）​</strong></li></ul><ul><li><p><strong>定义</strong>：一个<strong>存储单元</strong>中存储的<strong>二进制数据组合</strong>。</p></li><li><p><strong>关键点</strong>：</p><ul><li><p>是CPU一次读写操作的基本单位。</p></li><li><p>长度由硬件设计决定（如32位系统的存储字常为4字节）。</p></li></ul></li><li><p><strong>作用</strong>：可能包含指令、数据或地址信息。</p></li></ul><ul><li><strong>存储字长（Word Length）​</strong></li></ul><ul><li><p><strong>定义</strong>：一个存储字包含的二进制位数。</p></li><li><p><strong>关联硬件</strong>：</p><ul><li><p>等于MDR（数据寄存器）的位数。</p></li><li><p>直接影响数据处理效率（如64位字长比32位处理更快）。</p></li></ul></li><li><p><strong>典型值</strong>：现代计算机通常为32位或64位。</p></li></ul><h2 id="运算器（ACC-MQ-X-ALU-PSW）"><a href="#运算器（ACC-MQ-X-ALU-PSW）" class="headerlink" title="运算器（ACC,MQ,X,ALU,PSW）"></a>运算器（ACC,MQ,X,ALU,PSW）</h2><p><img src="/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/image-8.png"></p><p>注意图中没有画的，运算器中还有程序<strong>状态寄存器（PSW）</strong>，也称<strong>标志寄存器</strong>，用于存放ALU运算得到的一些标志信息或处理机的信息。如是否溢出、进位、错位、结果为负等。</p><h2 id="控制器-CU-IR-PC"><a href="#控制器-CU-IR-PC" class="headerlink" title="控制器(CU,IR,PC)"></a>控制器(CU,IR,PC)</h2><p><img src="/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/image-9.png"></p><h2 id="计算机运行过程"><a href="#计算机运行过程" class="headerlink" title="计算机运行过程"></a>计算机运行过程</h2><p><img src="/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/image-10.png"></p><h3 id="执行第一个取数过程-重要"><a href="#执行第一个取数过程-重要" class="headerlink" title="执行第一个取数过程(重要)"></a>执行第一个取数过程(重要)</h3><p>取数a到ACC分为以下9步</p><p><img src="/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/image-11.png"></p><ul><li><p>执行取数命令时</p><ul><li>取数的结果（运算结果）放到ACC（<strong>ACC存放操作数或运算结果</strong>）</li></ul></li></ul><h3 id="执行第二个乘法过程-重要"><a href="#执行第二个乘法过程-重要" class="headerlink" title="执行第二个乘法过程(重要)"></a>执行第二个乘法过程(重要)</h3><p><img src="/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/image-12.png"></p><ul><li><p>第一步执行完之后PC+1（字节编址）</p></li><li><p>当CU分析为当前是惩乘法指令之后，后面有一些不同，其余内容都相同。</p></li><li><p>执行乘法的时候</p><ul><li><p>X（<strong>通用操作数寄存器，存放操作数</strong>）中存放被乘数a（原来位于ACC）</p></li><li><p>MQ中存放乘数b（操作数）（<strong>MQ是乘商寄存器，在乘、除运算时存放操作数或结果</strong>）</p></li><li><p>最后还是用ACC存放结果（注意如果乘积过大则用MQ辅助存储）</p></li></ul></li></ul><h3 id="执行第三个加法过程-重要"><a href="#执行第三个加法过程-重要" class="headerlink" title="执行第三个加法过程(重要)"></a>执行第三个加法过程(重要)</h3><p><img src="/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/image-13.png"></p><ul><li><p>X中存操作数c &#x3D; 1</p></li><li><p>ACC存操作数ab &#x3D; 6</p></li><li><p>随后结果依旧放到ACC</p></li></ul><h3 id="执行第四个存数过程-重要"><a href="#执行第四个存数过程-重要" class="headerlink" title="执行第四个存数过程(重要)"></a>执行第四个存数过程(重要)</h3><p><img src="/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/image-14.png"></p><p>将ACC的值存到主存地址为8的位置</p><h3 id="执行第五个停机过程-重要"><a href="#执行第五个停机过程-重要" class="headerlink" title="执行第五个停机过程(重要)"></a>执行第五个停机过程(重要)</h3><p><img src="/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/image-15.png"></p><p>注意停机指令之后调用操作系统的指令，不再是以上表格中的指令了。</p><h3 id="总结（重要）"><a href="#总结（重要）" class="headerlink" title="总结（重要）"></a>总结（重要）</h3><p><img src="/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/image-16.png"></p><ol><li><p><strong>初始状态</strong>：</p><ul><li><p>指令、数据存入主存。</p></li><li><p>PC指向第一条指令。</p></li></ul></li><li><p><strong>执行过程</strong>：</p><ul><li><p>从主存中取指令放入IR。</p></li><li><p>PC自动加1。</p></li><li><p>CU分析指令。</p></li><li><p>CU指挥其他部件执行指令。</p></li></ul></li></ol><p><strong>取指令：PC-&gt;MAR-&gt;M-&gt;MDR-&gt;IR</strong></p><p><strong>分析指令：OP(IR)-&gt;CU</strong></p><p><strong>执行指令：Ad(IR)-&gt;MAR-&gt;M-&gt;MDR-&gt;ACC</strong></p><ul><li>这里从MDR取得是操作数，将运行之后的结果存在ACC中</li></ul><h1 id="计算机软件"><a href="#计算机软件" class="headerlink" title="计算机软件"></a>计算机软件</h1><p><img src="/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/image-17.png"></p><h2 id="三种级别的语言"><a href="#三种级别的语言" class="headerlink" title="三种级别的语言"></a>三种级别的语言</h2><p><img src="/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/image-18.png"></p><ul><li><p>高级语言</p></li><li><p>汇编语言</p></li><li><p>机器语言</p></li></ul><p>有的高级语言可以直接翻译成机器语言，有的则要先翻译成汇编语言，再翻译成机器语言。</p><h1 id="计算机系统层次结构"><a href="#计算机系统层次结构" class="headerlink" title="计算机系统层次结构"></a>计算机系统层次结构</h1><p><img src="/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/image-19.png"></p><p>注意以上的颜色对应关系，如LOAD对应的二进制就是下方的000001，黄色相同</p><h1 id="计算机系统的工作原理"><a href="#计算机系统的工作原理" class="headerlink" title="计算机系统的工作原理"></a>计算机系统的工作原理</h1><p><img src="/2025/04/07/1-2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/image-20.png"></p><p>注意有一个预处理的过程，如图中红笔写的例子，如c中将#define定义的数据覆盖到变量。</p><h1 id="习题精选"><a href="#习题精选" class="headerlink" title="习题精选"></a>习题精选</h1><p>软件功能与硬件功能在逻辑上是等价的（04）</p><p>汇编语言与机器结构有关（16），机器语言也同样相关</p><p>编译程序可以直接翻译成机器语言（生成机器级目标代码文件），虽然解释程序也可以宜家宜居翻译成机器语言，但是不会生成机器级目标代码文件。</p><h2 id="冯诺依曼机的特点"><a href="#冯诺依曼机的特点" class="headerlink" title="冯诺依曼机的特点"></a>冯诺依曼机的特点</h2><ul><li><p>基本工作方式是“控制流驱动”方式，也就是按照指令的执行序列，以此读取指令，然后根据指令所含的控制信息，调用数据信息进行处理。</p></li><li><p>功能部件包括输入设备、输出设备、存储器、运算器和我控制器。</p></li><li><p>通过中央处理器（运算器+控制器）执行指令。</p></li><li><p>指令和数据以同等地位存放在存储器内，形式上并无差别，只是在程序执行的时候有特殊的含义。</p></li><li><p>指令按地址访问，数据有指令的地址码指出，除去立即寻址之外，数据都存放在存储器内。</p></li><li><p>程序执行前，指令和数据都需预先放在存储器中，中央处理器可以从存储器取代码。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 408 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化nested loop</title>
      <link href="/2025/04/02/%E4%BC%98%E5%8C%96nested-loop/"/>
      <url>/2025/04/02/%E4%BC%98%E5%8C%96nested-loop/</url>
      
        <content type="html"><![CDATA[<h1 id="优化-nested-loop"><a href="#优化-nested-loop" class="headerlink" title="优化 nested loop"></a>优化 nested loop</h1><p>首先看一道题目</p><p><a href="https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-i/description/?envType=daily-question&envId=2025-04-02">2873. 有序三元组中的最大值 I - 力扣（LeetCode）</a></p><h2 id="暴力循环"><a href="#暴力循环" class="headerlink" title="暴力循环"></a>暴力循环</h2><p>使用3层循环。</p><p>这种做法容易想到，唯一要注意：<code>(long)(nums[i] - nums[j]) * nums[k]</code>要加上<code>(long)</code>进行强转，否则右侧默认为int，会溢出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maximumTripletValue</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">maxValue</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 初始化为0，如果所有三元组的值都是负数，则直接返回0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j + <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    <span class="comment">// 右侧加上long，进行强转。否则右侧全是int类型会溢出</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">currentValue</span> <span class="operator">=</span> (<span class="type">long</span>)(nums[i] - nums[j]) * nums[k];</span><br><span class="line">                    <span class="keyword">if</span> (currentValue &gt; maxValue) &#123;</span><br><span class="line">                        maxValue = currentValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><h3 id="前缀or后缀（预处理nums-i-和nums-k-，即遍历j）"><a href="#前缀or后缀（预处理nums-i-和nums-k-，即遍历j）" class="headerlink" title="前缀or后缀（预处理nums[i]和nums[k]，即遍历j）"></a>前缀or后缀（预处理nums[i]和nums[k]，即遍历j）</h3><p>这种思路是提前计算出多层循环中需要的一些内容。比如在本题目中，提前记录某一个下标的前缀的最大值和后缀的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maximumTripletValue</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] leftMax = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] rightMax = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            leftMax[i] = Math.max(leftMax[i - <span class="number">1</span>], nums[i - <span class="number">1</span>]);</span><br><span class="line">            rightMax[n - <span class="number">1</span> - i] = Math.max(rightMax[n - i], nums[n - i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            res = Math.max(res, (<span class="type">long</span>)(leftMax[j] - nums[j]) * rightMax[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="预处理nums-j-nums-i-即-遍历k"><a href="#预处理nums-j-nums-i-即-遍历k" class="headerlink" title="预处理nums[j]-nums[i]即(遍历k)"></a>预处理nums[j]-nums[i]即(遍历k)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maximumTripletValue</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预处理 maxPrefix[i] = max(nums[0..i])</span></span><br><span class="line">        <span class="type">int</span>[] maxPrefix = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        maxPrefix[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            maxPrefix[i] = Math.max(maxPrefix[i - <span class="number">1</span>], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预处理 maxDiff[j] = max(nums[i] - nums[j])，其中 i &lt; j</span></span><br><span class="line">        <span class="type">int</span>[] maxDiff = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            maxDiff[j] = maxPrefix[j - <span class="number">1</span>] - nums[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预处理 maxTriplet[k] = max(maxDiff[j] * nums[k])，其中 j &lt; k</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">maxValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDiffSoFar</span> <span class="operator">=</span> Integer.MIN_VALUE; <span class="comment">// 记录 j &lt; k 时的 maxDiff[j] 最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>; k &lt; n; k++) &#123;</span><br><span class="line">            maxDiffSoFar = Math.max(maxDiffSoFar, maxDiff[k - <span class="number">1</span>]); <span class="comment">// 更新 maxDiff[j] 的最大值（j &lt; k）</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">currentValue</span> <span class="operator">=</span> (<span class="type">long</span>) maxDiffSoFar * nums[k];</span><br><span class="line">            maxValue = Math.max(maxValue, currentValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面进行优化</p><p>在遍历k的过程中：</p><ul><li>维护 nums[i] 的最大值 preMax。</li><li>维护 preMax−nums[j] 的最大值 maxDiff。</li><li>计算 maxDiff⋅nums[k]，更新答案的最大值。</li></ul><p>代码实现时，要先更新 ans，再更新 maxDiff，最后更新 preMax。为什么？</p><p>这个顺序是精心设置的：</p><ul><li><p>首先更新 ans，此时 maxDiff 还没有更新，表示在当前元素左边的两个数的最大差值。</p></li><li><p>后更新 maxDiff，此时 preMax 还没有更新，表示在当前元素左边的最大值。</p></li><li><p>最后更新 preMax。</p></li></ul><p>能否修改更新顺序？</p><p>ans 依赖 maxDiff，maxDiff 依赖 preMax。如果修改更新顺序，那么 maxDiff 或者 preMax 会包含当前元素，就不是左边元素的计算结果了，这违反了题目 i&lt;j&lt;k 的规定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maximumTripletValue</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cha</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ez : nums) &#123;</span><br><span class="line">            res = Math.max(res, (<span class="type">long</span>) cha * ez);</span><br><span class="line">            cha = Math.max(cha, pre - ez);</span><br><span class="line">            pre = Math.max(pre, ez);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>习题补充（死锁）</title>
      <link href="/2025/03/31/%E4%B9%A0%E9%A2%98%E8%A1%A5%E5%85%85%EF%BC%88%E6%AD%BB%E9%94%81%EF%BC%89/"/>
      <url>/2025/03/31/%E4%B9%A0%E9%A2%98%E8%A1%A5%E5%85%85%EF%BC%88%E6%AD%BB%E9%94%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="死锁公式（重要）"><a href="#死锁公式（重要）" class="headerlink" title="死锁公式（重要）"></a>死锁公式（重要）</h1><p><strong>确保没有死锁的最小资源数计算：</strong>&#x8BA1;算系统在固定进程数和资源需求下，避免死锁所需的最少资源数量。</p><p><strong>公式</strong>：</p><p>​                                                                                 <strong><em>m</em>&#x3D;<em>n</em>×(<em>k</em>−1)+1</strong></p><ul><li><p><em>m</em>: 系统所需的最小资源数（避免死锁的临界值）。</p></li><li><p><em>n</em>: 进程数量。</p></li><li><p><em>k</em>: 每个进程需要的最大资源数（假设所有进程需求相同）。</p></li></ul><p><strong>示例</strong>：</p><ul><li>系统有 4 个进程，每个进程最多需要 2 个资源：<em>m</em>&#x3D;4×(2−1)+1&#x3D;5（至少需要 5 个资源）</li></ul><hr><p>要注意区分以下这些概念——<strong>死锁预防、死锁避免、死锁检测、死锁解除。</strong></p><h1 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h1><p><strong>破坏死锁产生的4个必要条件之一就一定可以预防死锁</strong></p><h2 id="死锁预防方法（破坏四个必要条件之一）"><a href="#死锁预防方法（破坏四个必要条件之一）" class="headerlink" title="死锁预防方法（破坏四个必要条件之一）"></a>死锁预防方法（破坏四个必要条件之一）</h2><ul><li><p><strong>破坏互斥条件</strong>：允许资源共享（如只读文件），但某些资源（如打印机）无法完全破坏互斥性，实际应用有限</p></li><li><p><strong>破坏占有并等待</strong>：</p><ul><li><p><strong>静态分配</strong>：进程启动前申请所有所需资源（可能降低资源利用率，可能导致<strong>饥饿</strong>）</p></li><li><p><strong>动态释放</strong>：请求新资源前必须释放已持有资源</p></li></ul></li><li><p><strong>破坏非抢占条件</strong>：允许系统强制回收资源（如CPU寄存器），但可能引发数据不一致</p></li><li><p><strong>破坏循环等待</strong>：<strong>资源有序分配法</strong>（如按编号顺序申请资源），这是<strong>最常用</strong>的预防策略</p></li></ul><h2 id="唯一无法的必要条件"><a href="#唯一无法的必要条件" class="headerlink" title="唯一无法的必要条件"></a>唯一无法的必要条件</h2><p>互斥使用资源——因为他难以破坏。比如说打印机资源无论如何都不可以共享。</p><h1 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h1><p><strong>死锁避免不涉及破坏破坏死锁的4个必要条件之一！</strong></p><h2 id="系统安全状态"><a href="#系统安全状态" class="headerlink" title="系统安全状态"></a>系统安全状态</h2><p>安全状态与安全序列</p><ul><li><p>系统处于安全状态时，一同一定没有死锁进程</p></li><li><p>系统处于不安全状态时，系统不一定会出现死锁进程。</p></li></ul><h2 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h2><h3 id="银行家算法与顺序分配算法"><a href="#银行家算法与顺序分配算法" class="headerlink" title="银行家算法与顺序分配算法"></a>银行家算法与顺序分配算法</h3><p>顺序分配算法是破坏了循环等待条件，但是银行家算法不可以说<strong>限制用户的申请资源的顺序（因为一方面这种说法应该是死锁预防中破环循环等待的内容，另一方面安全序列不是唯一的）</strong></p><h2 id="银行家算法vs其他死锁策略"><a href="#银行家算法vs其他死锁策略" class="headerlink" title="银行家算法vs其他死锁策略"></a>银行家算法vs其他死锁策略</h2><table><thead><tr><th>策略</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>死锁预防（Prevention）</td><td>破坏死锁的4个必要条件（如静态分配、资源有序分配）</td><td>适用于资源需求固定的系统</td></tr><tr><td>死锁避免（Avoidance）</td><td>动态检查资源分配（银行家算法）</td><td>适用于资源需求可预测的系统</td></tr><tr><td>死锁检测与恢复（Detection &amp; Recovery）</td><td>允许死锁发生，但检测后恢复（如终止进程）</td><td>适用于死锁概率低的系统</td></tr></tbody></table><h1 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h1><h2 id="死锁定理（重要）"><a href="#死锁定理（重要）" class="headerlink" title="死锁定理（重要）"></a>死锁定理（重要）</h2><p>死锁定理是用于<strong>判断系统是否发生死锁</strong>的理论依据，它基于<strong>资源分配图（Resource Allocation Graph, RAG）</strong>，提供了一种形式化的判定方法。</p><p><strong>关键结论</strong>：</p><ul><li><p><strong>如果 RAG 可完全化简 → 无死锁</strong>。</p></li><li><p><strong>如果 RAG 不可化简且存在环路 → 死锁发生</strong>。</p></li></ul><h1 id="死锁解除"><a href="#死锁解除" class="headerlink" title="死锁解除"></a>死锁解除</h1><ol><li><p><strong>资源剥夺法</strong></p><ul><li><p>挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。</p></li><li><p><strong>注意</strong>：需防止被挂起的进程长时间得不到资源而处于资源匮乏的状态。</p></li></ul></li><li><p><strong>撤销进程法</strong></p><ul><li><p>强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。</p></li><li><p><strong>特点</strong>：</p><ul><li><p>可以按进程优先级和撤销进程代价的高低进行选择。</p></li><li><p>实现简单，但代价可能很大（如某些进程已接近结束，被终止后需从头执行）。</p></li></ul></li></ul></li><li><p><strong>进程回退法</strong></p><ul><li><p>让一个或多个死锁进程回退到足以回避死锁的地步，进程回退时自愿释放资源。</p></li><li><p><strong>要求</strong>：系统需保持进程的历史信息，设置还原点。</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 死锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java创建大根堆与小根堆</title>
      <link href="/2025/03/26/java%E5%88%9B%E5%BB%BA%E5%A4%A7%E6%A0%B9%E5%A0%86%E4%B8%8E%E5%B0%8F%E6%A0%B9%E5%A0%86/"/>
      <url>/2025/03/26/java%E5%88%9B%E5%BB%BA%E5%A4%A7%E6%A0%B9%E5%A0%86%E4%B8%8E%E5%B0%8F%E6%A0%B9%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h3 id="二叉树结点关系公式"><a href="#二叉树结点关系公式" class="headerlink" title="二叉树结点关系公式"></a>二叉树结点关系公式</h3><h4 id="1-二叉树节点关系公式"><a href="#1-二叉树节点关系公式" class="headerlink" title="1.二叉树节点关系公式"></a>1.二叉树节点关系公式</h4><ol><li><p><strong>父节点索引计算</strong><br>• 已知子节点索引为 <code>i</code>，其父节点索引为 **<code>(i-1)/2</code>**（向下取整）。<br>• <strong>示例</strong>：子节点索引为 5，父节点为 <code>(5-1)/2=2</code>。</p></li><li><p><strong>子节点索引计算</strong><br>• 已知父节点索引为 <code>i</code>，其左子节点索引为 **<code>2i+1</code>**，右子节点索引为 **<code>2i+2</code>**。<br>• <strong>示例</strong>：父节点索引为 2，左子节点为 <code>2*2+1=5</code>，右子节点为 <code>2*2+2=6</code>。</p></li><li><p><strong>最后一个非叶子节点索引</strong><br>• 对含 <code>n</code> 个节点的完全二叉树，最后一个非叶子节点索引为 **<code>n/2-1</code>**（适用于数组存储）。<br>• <strong>示例</strong>：数组长度为 10，则最后一个非叶子节点索引为 <code>10/2-1=4</code>。</p></li></ol><h4 id="2-完全二叉树特性与存储"><a href="#2-完全二叉树特性与存储" class="headerlink" title="2.完全二叉树特性与存储"></a>2.完全二叉树特性与存储</h4><ol><li><p><strong>顺序存储规则</strong><br>• 完全二叉树的数组存储中，节点按层序从左到右依次存放，索引关系严格满足上述公式。<br>• <strong>应用场景</strong>：堆（大根堆&#x2F;小根堆）、优先队列的实现。</p></li><li><p><strong>完全二叉树判定条件</strong><br>• 除最后一层外，其他层节点数达到最大值，且最后一层节点从左向右连续排列。</p></li><li><p><strong>节点数量与深度关系</strong><br>• 深度为 <code>h</code> 的完全二叉树最多有 <strong><code>2^h-1</code></strong> 个节点，最少有 <strong><code>2^(h-1)</code></strong> 个节点。</p></li></ol><h4 id="3-其他关键关系"><a href="#3-其他关键关系" class="headerlink" title="3.其他关键关系"></a>3.其他关键关系</h4><ol><li><p><strong>层序与索引关系</strong><br>• 根节点位于第 <strong>1 层</strong>（部分定义中为第 0 层），子节点层数比父节点大 1。<br>• 层序为 <code>L</code> 的节点最大索引为 **<code>2^L-2</code>**（若根为第 1 层）。</p></li><li><p><strong>叶子节点判定</strong><br>• 若节点索引 <code>i</code> 满足 **<code>i &gt;= n/2</code>**（<code>n</code> 为总节点数），则该节点为叶子节点。</p></li><li><p><strong>树的度与高度</strong><br>• 树的度：所有节点中最大的子节点数（二叉树度为 2）。<br>• 树的高度：从根到最远叶子节点的路径长度。</p></li></ol><h4 id="4-应用场景中的特殊计算"><a href="#4-应用场景中的特殊计算" class="headerlink" title="4.应用场景中的特殊计算"></a>4.应用场景中的特殊计算</h4><ol><li><p><strong>堆结构调整</strong><br>• 构建堆时，从最后一个非叶子节点（<code>n/2-1</code>）开始依次向上调整。<br>• <strong>示例</strong>：堆排序中，通过 <code>sink()</code> 或 <code>swim()</code> 操作维护堆性质。</p></li><li><p><strong>二叉搜索树（BST）</strong><br>• 左子树所有节点值小于根，右子树所有节点值大于根。<br>• 中序遍历结果为有序序列。</p></li></ol><h4 id="5-总结对比表"><a href="#5-总结对比表" class="headerlink" title="5.总结对比表"></a>5.总结对比表</h4><table><thead><tr><th><strong>关系类型</strong></th><th><strong>公式&#x2F;规则</strong></th><th><strong>适用场景</strong></th><th>来源</th></tr></thead><tbody><tr><td>父节点索引</td><td><code>(i-1)/2</code></td><td>堆、完全二叉树数组存储</td><td></td></tr><tr><td>子节点索引</td><td>左：<code>2i+1</code>，右：<code>2i+2</code></td><td>完全二叉树、堆调整</td><td></td></tr><tr><td>最后一个非叶子节点</td><td><code>n/2-1</code></td><td>堆初始化</td><td></td></tr><tr><td>完全二叉树层序</td><td>层 <code>L</code> 最大索引 <code>2^L-2</code>（根为第 1 层）</td><td>树深度计算</td><td></td></tr></tbody></table><p>通过以上规则，可以高效实现二叉树的遍历、堆操作及存储结构转换。具体代码实现时需注意数组索引从 0 还是 1 开始（如堆的某些实现会从索引 1 开始以简化计算）。</p><h3 id="Java-手动实现大根堆（Max-Heap）"><a href="#Java-手动实现大根堆（Max-Heap）" class="headerlink" title="Java 手动实现大根堆（Max Heap）"></a>Java 手动实现大根堆（Max Heap）</h3><p>大根堆是一种完全二叉树，其中每个节点的值都 <strong>大于或等于</strong> 其子节点的值。以下是手动构建大根堆的完整实现：</p><h4 id="1-核心方法"><a href="#1-核心方法" class="headerlink" title="1. 核心方法"></a>1. <strong>核心方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxHeap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] heap;  <span class="comment">// 存储堆元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;    <span class="comment">// 当前堆的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity; <span class="comment">// 堆的最大容量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxHeap</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.heap = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取父节点索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">parent</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取左子节点索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">leftChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取右子节点索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">rightChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换两个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> heap[i];</span><br><span class="line">        heap[i] = heap[j];</span><br><span class="line">        heap[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt;= capacity) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Heap is full&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        heap[size] = value;  <span class="comment">// 先放到末尾</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> size;</span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上浮操作：如果当前节点比父节点大，则交换</span></span><br><span class="line">        <span class="keyword">while</span> (current &gt; <span class="number">0</span> &amp;&amp; heap[current] &gt; heap[parent(current)]) &#123;</span><br><span class="line">            swap(current, parent(current));</span><br><span class="line">            current = parent(current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取最大值（堆顶）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">extractMax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Heap is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> heap[<span class="number">0</span>];  <span class="comment">// 堆顶是最大值</span></span><br><span class="line">        heap[<span class="number">0</span>] = heap[size - <span class="number">1</span>];  <span class="comment">// 将最后一个元素移到堆顶</span></span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下沉操作：调整堆结构</span></span><br><span class="line">        heapify(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 堆化（下沉操作）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> leftChild(i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> rightChild(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出当前节点、左子节点、右子节点中的最大值</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; size &amp;&amp; heap[left] &gt; heap[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; heap[right] &gt; heap[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果最大值不是当前节点，则交换并继续堆化</span></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(i, largest);</span><br><span class="line">            heapify(largest);  <span class="comment">// 递归调整</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建堆（从无序数组构建大根堆）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildHeap</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &gt; capacity) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Array exceeds heap capacity&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, heap, <span class="number">0</span>, arr.length);</span><br><span class="line">        size = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从最后一个非叶子节点开始堆化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapify(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印堆</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printHeap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            System.out.print(heap[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-测试代码"><a href="#2-测试代码" class="headerlink" title="2. 测试代码"></a>2. <strong>测试代码</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MaxHeap</span> <span class="variable">maxHeap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MaxHeap</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入元素</span></span><br><span class="line">        maxHeap.insert(<span class="number">5</span>);</span><br><span class="line">        maxHeap.insert(<span class="number">3</span>);</span><br><span class="line">        maxHeap.insert(<span class="number">8</span>);</span><br><span class="line">        maxHeap.insert(<span class="number">1</span>);</span><br><span class="line">        maxHeap.insert(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;堆结构: &quot;</span>);</span><br><span class="line">        maxHeap.printHeap();  <span class="comment">// 输出: 10 5 8 1 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提取最大值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最大值: &quot;</span> + maxHeap.extractMax());  <span class="comment">// 输出: 10</span></span><br><span class="line">        System.out.print(<span class="string">&quot;提取后的堆: &quot;</span>);</span><br><span class="line">        maxHeap.printHeap();  <span class="comment">// 输出: 8 5 3 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接从数组构建堆</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">MaxHeap</span> <span class="variable">heapFromArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MaxHeap</span>(<span class="number">10</span>);</span><br><span class="line">        heapFromArray.buildHeap(arr);</span><br><span class="line">        System.out.print(<span class="string">&quot;从数组构建的堆: &quot;</span>);</span><br><span class="line">        heapFromArray.printHeap();  <span class="comment">// 输出: 9 7 2 4 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-关键点解析"><a href="#3-关键点解析" class="headerlink" title="3. 关键点解析"></a>3. <strong>关键点解析</strong></h4><ol><li><p><strong>插入操作 (<code>insert</code>)</strong><br>• 新元素放到末尾，通过 <strong>上浮</strong> 调整位置。<br>• 时间复杂度：O(log n)。</p></li><li><p><strong>提取最大值 (<code>extractMax</code>)</strong><br>• 取出堆顶后，将末尾元素移到堆顶，通过 <strong>下沉 (<code>heapify</code>)</strong> 调整。<br>• 时间复杂度：O(log n)。</p></li><li><p><strong>构建堆 (<code>buildHeap</code>)</strong><br>• 从 <strong>最后一个非叶子节点</strong> 开始向前遍历，对每个节点执行 <code>heapify</code>。<br>• 时间复杂度：O(n)（比逐个插入的 O(n log n) 更高效）。</p></li><li><p><strong>堆化 (<code>heapify</code>)</strong><br>• 递归或迭代地比较当前节点与子节点，确保父节点始终最大。</p></li></ol><h3 id="Java-小根堆（Min-Heap）完整实现"><a href="#Java-小根堆（Min-Heap）完整实现" class="headerlink" title="Java 小根堆（Min Heap）完整实现"></a>Java 小根堆（Min Heap）完整实现</h3><p>以下是手动实现小根堆的完整代码，包含插入、删除堆顶、堆化等核心操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinHeap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] heap;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinHeap</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.heap = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取父节点索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">parent</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取左子节点索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">leftChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取右子节点索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">rightChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换两个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> heap[i];</span><br><span class="line">        heap[i] = heap[j];</span><br><span class="line">        heap[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt;= capacity) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Heap is full&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        heap[size] = value;</span><br><span class="line">        heapifyUp(size);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上浮操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapifyUp</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; heap[i] &lt; heap[parent(i)]) &#123;</span><br><span class="line">            swap(i, parent(i));</span><br><span class="line">            i = parent(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取最小值（堆顶）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">extractMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Heap is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> heap[<span class="number">0</span>];</span><br><span class="line">        heap[<span class="number">0</span>] = heap[size - <span class="number">1</span>];</span><br><span class="line">        size--;</span><br><span class="line">        heapifyDown(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下沉操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapifyDown</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">smallest</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> leftChild(i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> rightChild(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; size &amp;&amp; heap[left] &lt; heap[smallest]) &#123;</span><br><span class="line">            smallest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; heap[right] &lt; heap[smallest]) &#123;</span><br><span class="line">            smallest = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (smallest != i) &#123;</span><br><span class="line">            swap(i, smallest);</span><br><span class="line">            heapifyDown(smallest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取堆顶元素（不删除）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Heap is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印堆</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printHeap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            System.out.print(heap[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-测试示例"><a href="#1-测试示例" class="headerlink" title="1.测试示例"></a>1.测试示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MinHeap</span> <span class="variable">minHeap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MinHeap</span>(<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        minHeap.insert(<span class="number">5</span>);</span><br><span class="line">        minHeap.insert(<span class="number">3</span>);</span><br><span class="line">        minHeap.insert(<span class="number">8</span>);</span><br><span class="line">        minHeap.insert(<span class="number">1</span>);</span><br><span class="line">        minHeap.insert(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;堆内容: &quot;</span>);</span><br><span class="line">        minHeap.printHeap();  <span class="comment">// 输出: 1 2 8 5 3</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最小值: &quot;</span> + minHeap.extractMin());  <span class="comment">// 输出: 1</span></span><br><span class="line">        System.out.print(<span class="string">&quot;提取后的堆: &quot;</span>);</span><br><span class="line">        minHeap.printHeap();  <span class="comment">// 输出: 2 3 8 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-关键区别（与大根堆对比）"><a href="#2-关键区别（与大根堆对比）" class="headerlink" title="2.关键区别（与大根堆对比）"></a>2.关键区别（与大根堆对比）</h4><table><thead><tr><th>操作</th><th>大根堆实现</th><th>小根堆实现</th></tr></thead><tbody><tr><td>比较条件</td><td><code>heap[child] &gt; heap[i]</code></td><td><code>heap[child] &lt; heap[i]</code></td></tr><tr><td>堆顶元素</td><td>最大值</td><td>最小值</td></tr><tr><td>典型应用</td><td>找前K大元素</td><td>找前K小元素</td></tr></tbody></table><h4 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3.复杂度分析"></a>3.复杂度分析</h4><p>• 插入（<code>insert</code>）：O(log n)<br>• 删除堆顶（<code>extractMin</code>）：O(log n)<br>• 获取堆顶（<code>peek</code>）：O(1)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射常见类型</title>
      <link href="/2025/03/19/%E5%8F%8D%E5%B0%84%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B/"/>
      <url>/2025/03/19/%E5%8F%8D%E5%B0%84%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.FIELD,ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例类</span></span><br><span class="line"><span class="meta">@MyAnnotation()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation(&quot;annotatedField&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">secret</span> <span class="operator">=</span> <span class="string">&quot;hidden&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation(&quot;annotatedMethod&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">(<span class="meta">@Deprecated</span> String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Private method called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;, age=&quot;</span> + age + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// ----------------------- 1. 获取 Class 对象 -----------------------</span></span><br><span class="line">        Class&lt;?&gt; personClass = Person.class;  <span class="comment">// 方式1: 通过类字面量</span></span><br><span class="line">        <span class="comment">// Class&lt;?&gt; personClass = Class.forName(&quot;Person&quot;); // 方式2: 通过全限定类名</span></span><br><span class="line">        <span class="comment">// Class&lt;?&gt; personClass = new Person().getClass(); // 方式3: 通过对象实例</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Class Name: &quot;</span> + personClass.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ----------------------- 2. 操作字段 -----------------------</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\nFields:&quot;</span>);</span><br><span class="line">        Field[] fields = personClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Field: &quot;</span> + field.getName() + <span class="string">&quot; (Type: &quot;</span> + field.getType() + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (field.isAnnotationPresent(MyAnnotation.class)) &#123;</span><br><span class="line">                <span class="type">MyAnnotation</span> <span class="variable">anno</span> <span class="operator">=</span> field.getAnnotation(MyAnnotation.class);</span><br><span class="line">                System.out.println(<span class="string">&quot;  Has MyAnnotation with value: &quot;</span> + anno.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问私有字段</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">secretField</span> <span class="operator">=</span> personClass.getDeclaredField(<span class="string">&quot;secret&quot;</span>);</span><br><span class="line">        secretField.setAccessible(<span class="literal">true</span>); <span class="comment">// 突破封装</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Original secret: &quot;</span> + secretField.get(p));</span><br><span class="line">        secretField.set(p, <span class="string">&quot;newSecret&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Modified secret: &quot;</span> + secretField.get(p));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ----------------------- 3. 操作方法 -----------------------</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\nMethods:&quot;</span>);</span><br><span class="line">        Method[] methods = personClass.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Method: &quot;</span> + method.getName() +</span><br><span class="line">                    <span class="string">&quot; (Return: &quot;</span> + method.getReturnType() + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取参数信息</span></span><br><span class="line">            Parameter[] params = method.getParameters();</span><br><span class="line">            <span class="keyword">for</span> (Parameter param : params) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;  Param: &quot;</span> + param.getType() +</span><br><span class="line">                        <span class="string">&quot; (Name: &quot;</span> + param.getName() + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (param.isAnnotationPresent(Deprecated.class)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;    Has @Deprecated annotation&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查方法注解</span></span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(MyAnnotation.class)) &#123;</span><br><span class="line">                <span class="type">MyAnnotation</span> <span class="variable">anno</span> <span class="operator">=</span> method.getAnnotation(MyAnnotation.class);</span><br><span class="line">                System.out.println(<span class="string">&quot;  Has MyAnnotation: &quot;</span> + anno.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">greetMethod</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;greet&quot;</span>, String.class);</span><br><span class="line">        greetMethod.invoke(p, <span class="string">&quot;World&quot;</span>); <span class="comment">// 调用实例方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用私有方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">privateMethod</span> <span class="operator">=</span> personClass.getDeclaredMethod(<span class="string">&quot;privateMethod&quot;</span>);</span><br><span class="line">        privateMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        privateMethod.invoke(p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ----------------------- 4. 操作构造器 -----------------------</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\nConstructors:&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt;[] constructors = personClass.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Constructor with &quot;</span> +</span><br><span class="line">                    constructor.getParameterCount() + <span class="string">&quot; parameters&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射创建实例</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = personClass.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> (Person) constructor.newInstance(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Created instance: &quot;</span> + p2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ----------------------- 5. 注解操作 -----------------------</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\nAnnotations:&quot;</span>);</span><br><span class="line">        Annotation[] classAnnotations = personClass.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation anno : classAnnotations) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Class annotation: &quot;</span> + anno.annotationType());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查字段注解</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">annotatedField</span> <span class="operator">=</span> personClass.getDeclaredField(<span class="string">&quot;secret&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (annotatedField.isAnnotationPresent(MyAnnotation.class)) &#123;</span><br><span class="line">            <span class="type">MyAnnotation</span> <span class="variable">anno</span> <span class="operator">=</span> annotatedField.getAnnotation(MyAnnotation.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;Field annotation value: &quot;</span> + anno.value());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>创建BeanDefiniton</title>
      <link href="/2025/03/16/%E5%88%9B%E5%BB%BABeanDefiniton/"/>
      <url>/2025/03/16/%E5%88%9B%E5%BB%BABeanDefiniton/</url>
      
        <content type="html"><![CDATA[<h1 id="创建BeanDefiniton"><a href="#创建BeanDefiniton" class="headerlink" title="创建BeanDefiniton"></a>创建BeanDefiniton</h1><h2 id="本章概述"><a href="#本章概述" class="headerlink" title="本章概述"></a>本章概述</h2><p>本章实现的是Bean的结构定义</p><p>主要实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationConfigApplicationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> PropertyResolver propertyResolver;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt; configClass, PropertyResolver propertyResolver)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.propertyResolver = propertyResolver;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扫描获取所有Bean的Class类型:</span></span><br><span class="line">        <span class="keyword">final</span> Set&lt;String&gt; beanClassNames = scanForClassNames(configClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Bean的定义:</span></span><br><span class="line">        <span class="built_in">this</span>.beans = createBeanDefinitions(beanClassNames);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....略</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="扫描获取所有Bean的Class类型"><a href="#扫描获取所有Bean的Class类型" class="headerlink" title="扫描获取所有Bean的Class类型"></a>扫描获取所有Bean的Class类型</h3><p>注释 <code>// 扫描获取所有Bean的Class类型</code> 的意思是：<strong>通过扫描</strong> <code>configClass</code> <strong>中</strong> <code>@ComponentScan</code> <strong>注解指定的包路径，获取所有标注了 Spring 注解（如</strong> <code>@Component</code><strong>、</strong><code>@Service</code><strong>、</strong><code>@Repository</code><strong>、</strong><code>@Controller</code> <strong>等）的类名</strong>。这些类名通常是类的全限定名（fully qualified name），例如 <code>com.example.MyService</code>。</p><ol><li><strong>扫描包路径</strong>：<ol><li><code>scanForClassNames(configClass)</code> 方法会查找 <code>configClass</code> 上的 <code>@ComponentScan</code> 注解。</li><li>如果 <code>@ComponentScan</code> 注解指定了包路径，则扫描这些包路径下的所有类。</li><li>如果未指定包路径，则默认扫描 <code>configClass</code> 所在的包路径。</li></ol></li><li><strong>获取类名</strong>：<ol><li>扫描到的类名会被收集到一个 <code>Set&lt;String&gt;</code> 中。</li><li>这些类名是类的全限定名，例如 <code>com.example.MyService</code>。</li></ol></li><li><strong>Bean 的 Class 类型</strong>：<ol><li>这些类名对应的类通常标注了 Spring 的注解（如 <code>@Component</code>、<code>@Service</code> 等），因此它们是 Spring 容器需要管理的 Bean。</li></ol></li></ol><p>章的测试用例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.scan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itranswarp.imported.LocalDateConfiguration;</span><br><span class="line"><span class="keyword">import</span> com.itranswarp.imported.ZonedDateConfiguration;</span><br><span class="line"><span class="keyword">import</span> com.itranswarp.summer.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> com.itranswarp.summer.annotation.Import;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@Import(&#123; LocalDateConfiguration.class, ZonedDateConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScanApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean的定义方式"><a href="#Bean的定义方式" class="headerlink" title="Bean的定义方式"></a>Bean的定义方式</h2><h3 id="Bean的结构体BeanDefinition"><a href="#Bean的结构体BeanDefinition" class="headerlink" title="Bean的结构体BeanDefinition"></a>Bean的结构体BeanDefinition</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinition</span> &#123;</span><br><span class="line">    <span class="comment">// 全局唯一的Bean Name:</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bean的声明类型:</span></span><br><span class="line">    Class&lt;?&gt; beanClass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bean的实例:Object instance = null;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法/null:</span></span><br><span class="line">    Constructor&lt;?&gt; constructor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工厂方法名称/null:</span></span><br><span class="line">    String factoryName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工厂方法/null:（反射）</span></span><br><span class="line">    Method factoryMethod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bean的顺序:int order;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否标识@Primary:boolean primary;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// init/destroy方法名称:</span></span><br><span class="line">    String initMethodName;</span><br><span class="line">    String destroyMethodName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init/destroy方法:（反射）</span></span><br><span class="line">    Method initMethod;</span><br><span class="line">    Method destroyMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bean的申明类型"><a href="#bean的申明类型" class="headerlink" title="bean的申明类型"></a>bean的申明类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bean的声明类型:</span></span><br><span class="line">    Class&lt;?&gt; beanClass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bean的实例:Object instance = null;</span></span><br></pre></td></tr></table></figure><p>这里我们要特别注意一点，就是Bean的声明类型。对于<code>@Component</code>定义的Bean，它的声明类型就是其Class本身。然而，对于用<code>@Bean</code>工厂方法创建的Bean，它的声明类型与实际类型不一定是同一类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinition</span> &#123;</span><br><span class="line">    <span class="comment">// Bean的声明类型:</span></span><br><span class="line">    Class&lt;?&gt; beanClass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bean的实例:Object instance = null;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述<code>createDataSource()</code>定义的Bean，声明类型是<code>DataSource</code>，实际类型却是某个子类，例如<code>HikariDataSource</code>，因此要特别注意，我们在<code>BeanDefinition</code>中，存储的<code>beanClass</code>是<strong>声明类型</strong>，实际类型不必存储，因为可以通过<code>instance.getClass()</code>获得。</p><p>所以由此可以引出以下两种获得bean的形式。</p><h3 id="通过bean名称查询"><a href="#通过bean名称查询" class="headerlink" title="通过bean名称查询"></a>通过bean名称查询</h3><p>如果我们按照名字查找Bean或BeanDefinition，要么拿到唯一实例，要么不存在，即通过查询<code>Map&lt;String, BeanDefinition&gt;</code>即可完成：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationConfigApplicationContext</span> &#123;</span><br><span class="line">    <span class="title class_">Map</span>&lt;<span class="title class_">String</span>, <span class="title class_">BeanDefinition</span>&gt; beans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据Name查找BeanDefinition，如果Name不存在，返回null@Nullablepublic BeanDefinition findBeanDefinition(String name) &#123;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">beans</span>.<span class="title function_">get</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过bean类型查询"><a href="#通过bean类型查询" class="headerlink" title="通过bean类型查询"></a>通过bean类型查询</h3><p>但是通过类型查找Bean或BeanDefinition，我们<strong>没法定义</strong>一个<code>Map&lt;Class, BeanDefinition&gt;</code>，原因就是Bean的声明类型与实际类型不一定相符，举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    AtomicInteger <span class="title function_">counter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Number <span class="title function_">bigInt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1000000000&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用<code>getBean(AtomicInteger.class)</code>时，我们会获得<code>counter()</code>方法创建的唯一实例，但是，当我们调用<code>getBean(Number.class)</code>时，<code>counter()</code>方法和<code>bigInt()</code>方法创建的实例均符合要求，此时，如果有且仅有一个标注了<code>@Primary</code>，就返回标注了<code>@Primary</code>的Bean，否则，直接报<code>NoUniqueBeanDefinitionException</code>错误。</p><p>因此，对于<code>getBean(Class)</code>方法，必须遍历找出所有符合类型的Bean，如果不唯一，再判断<code>@Primary</code>，才能返回唯一Bean或报错。</p><p>我们编写一个找出所有类型的<code>findBeanDefinitions(Class)</code>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据Type查找若干个BeanDefinition，返回0个或多个:</span></span><br><span class="line">List&lt;BeanDefinition&gt; <span class="title function_">findBeanDefinitions</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.beans.values().stream()</span><br><span class="line">        <span class="comment">// 按类型过滤:</span></span><br><span class="line">        .filter(def -&gt; type.isAssignableFrom(def.getBeanClass()))</span><br><span class="line">        <span class="comment">// 排序:</span></span><br><span class="line">        .sorted().collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再编写一个<code>findBeanDefinition(Class)</code>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据Type查找某个BeanDefinition，如果不存在返回null，如果存在多个返回@Primary标注的一个:</span></span><br><span class="line"><span class="meta">@Nullablepublic</span> </span><br><span class="line">BeanDefinition <span class="title function_">findBeanDefinition</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">    List&lt;BeanDefinition&gt; defs = findBeanDefinitions(type);</span><br><span class="line">    <span class="keyword">if</span> (defs.isEmpty()) &#123; <span class="comment">// 没有找到任何BeanDefinition</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (defs.size() == <span class="number">1</span>) &#123; <span class="comment">// 找到唯一一个</span></span><br><span class="line">        <span class="keyword">return</span> defs.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 多于一个时，查找@Primary:</span></span><br><span class="line">    List&lt;BeanDefinition&gt; primaryDefs = defs.stream().filter(def -&gt; def.isPrimary()).collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">if</span> (primaryDefs.size() == <span class="number">1</span>) &#123; <span class="comment">// @Primary唯一</span></span><br><span class="line">        <span class="keyword">return</span> primaryDefs.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (primaryDefs.isEmpty()) &#123; <span class="comment">// 不存在@Primary</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoUniqueBeanDefinitionException</span>(String.format(<span class="string">&quot;Multiple bean with type &#x27;%s&#x27; found, but no @Primary specified.&quot;</span>, type.getName()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// @Primary不唯一</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoUniqueBeanDefinitionException</span>(String.format(<span class="string">&quot;Multiple bean with type &#x27;%s&#x27; found, and multiple @Primary specified.&quot;</span>, type.getName()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取BeanDefinition信息"><a href="#获取BeanDefinition信息" class="headerlink" title="获取BeanDefinition信息"></a>获取<code>BeanDefinition</code>信息</h2><p>分为以下两步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationConfigApplicationContext</span> &#123;</span><br><span class="line">    Map&lt;String, BeanDefinition&gt; beans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt; configClass, PropertyResolver propertyResolver)</span> &#123;</span><br><span class="line">        <span class="comment">// 扫描获取所有Bean的Class类型:</span></span><br><span class="line">        Set&lt;String&gt; beanClassNames = scanForClassNames(configClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Bean的定义:this.beans = createBeanDefinitions(beanClassNames);</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-扫描所有Bean的Class类型，返回Class类名"><a href="#1-扫描所有Bean的Class类型，返回Class类名" class="headerlink" title="1.扫描所有Bean的Class类型，返回Class类名"></a>1.扫描所有Bean的Class类型，返回Class类名</h3><p>这个 <code>scanForClassNames</code> 方法的作用是 <strong>扫描指定包下的所有类名，并返回这些类名的集合</strong>。它主要用于在 Spring 框架中实现组件扫描（Component Scan）的功能，扫描 <code>@ComponentScan</code> 注解指定的包路径(如果没有就<code>configClass.getPackage().getName()</code>默认路径)，并收集这些包下的所有类名。同时，它还会处理 <code>@Import</code> 注解，将导入的类名也添加到结果中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; <span class="title function_">scanForClassNames</span><span class="params">(Class&lt;?&gt; configClass)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取@ComponentScan注解:</span></span><br><span class="line">    <span class="type">ComponentScan</span> <span class="variable">scan</span> <span class="operator">=</span> ClassUtils.findAnnotation(configClass, ComponentScan.class);</span><br><span class="line">    <span class="comment">// 获取注解配置的package名字,未配置则默认当前类所在包:</span></span><br><span class="line">    String[] scanPackages = scan == <span class="literal">null</span> || scan.value().length == <span class="number">0</span> ? <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; configClass.getPackage().getName() &#125; : scan.value();</span><br><span class="line">    </span><br><span class="line">    Set&lt;String&gt; classNameSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 依次扫描所有包:for (String pkg : scanPackages) &#123;</span></span><br><span class="line">        logger.atDebug().log(<span class="string">&quot;scan package: &#123;&#125;&quot;</span>, pkg);</span><br><span class="line">        <span class="comment">// 扫描一个包:var rr = new ResourceResolver(pkg);</span></span><br><span class="line">        <span class="comment">// 这里使用了之前按编写的ResourceResolver扫描某一个包下面的所有class</span></span><br><span class="line">        List&lt;String&gt; classList = rr.scan(res -&gt; &#123;</span><br><span class="line">            <span class="comment">// 遇到以.class结尾的文件，就将其转换为Class全名:String name = res.name();</span></span><br><span class="line">            <span class="keyword">if</span> (name.endsWith(<span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> name.substring(<span class="number">0</span>, name.length() - <span class="number">6</span>).replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;.&quot;</span>).replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 扫描结果添加到Set:</span></span><br><span class="line">        classNameSet.addAll(classList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续查找@Import(Xyz.class)导入的Class配置:Import importConfig = configClass.getAnnotation(Import.class);</span></span><br><span class="line">    <span class="keyword">if</span> (importConfig != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; importConfigClass : importConfig.value()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">importClassName</span> <span class="operator">=</span> importConfigClass.getName();</span><br><span class="line">            classNameSet.add(importClassName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classNameSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-根据类名提取-Bean-的定义信息，并构建-BeanDefinition-对象"><a href="#2-根据类名提取-Bean-的定义信息，并构建-BeanDefinition-对象" class="headerlink" title="2.根据类名提取 Bean 的定义信息，并构建 BeanDefinition 对象"></a>2.根据类名提取 Bean 的定义信息，并构建 <code>BeanDefinition</code> 对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, BeanDefinition&gt; <span class="title function_">createBeanDefinitions</span><span class="params">(Set&lt;String&gt; classNameSet)</span> &#123;</span><br><span class="line">    Map&lt;String, BeanDefinition&gt; defs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String className : classNameSet) &#123;</span><br><span class="line">        <span class="comment">// 获取Class:</span></span><br><span class="line">        Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//使用反射获取·class</span></span><br><span class="line">            clazz = Class.forName(className);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断当前clazz是否标注@Component?</span></span><br><span class="line">        <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> ClassUtils.findAnnotation(clazz, Component.class);</span><br><span class="line">        <span class="keyword">if</span> (component != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取Bean的名称:</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> ClassUtils.getBeanName(clazz);</span><br><span class="line">            <span class="type">var</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>(</span><br><span class="line">                beanName, clazz, getSuitableConstructor(clazz),</span><br><span class="line">                getOrder(clazz), clazz.isAnnotationPresent(Primary.class),</span><br><span class="line">                <span class="comment">// init/destroy方法名称:null, null,</span></span><br><span class="line">                <span class="comment">// 查找@PostConstruct方法:</span></span><br><span class="line">                ClassUtils.findAnnotationMethod(clazz, PostConstruct.class),</span><br><span class="line">                <span class="comment">// 查找@PreDestroy方法:</span></span><br><span class="line">                ClassUtils.findAnnotationMethod(clazz, PreDestroy.class));</span><br><span class="line">            addBeanDefinitions(defs, def);</span><br><span class="line">            <span class="comment">// 查找是否有@Configuration:</span></span><br><span class="line">            <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> ClassUtils.findAnnotation(clazz, Configuration.class);</span><br><span class="line">            <span class="keyword">if</span> (configuration != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 查找@Bean方法:</span></span><br><span class="line">                scanFactoryMethods(beanName, clazz, defs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> defs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getBeanName方法（获取-Component）"><a href="#getBeanName方法（获取-Component）" class="headerlink" title="getBeanName方法（获取@Component）"></a>getBeanName方法（获取@Component）</h4><p>判断clazz是否使用@component注解。注意还要拆线呢是否像@controller中也包含了@component注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get bean name by:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;code&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Component</span></span></span><br><span class="line"><span class="comment"> * public class Hello &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &lt;/code&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getBeanName</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 查找@Component:</span></span><br><span class="line">    <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> clazz.getAnnotation(Component.class);</span><br><span class="line">    <span class="keyword">if</span> (component != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// @Component exist:</span></span><br><span class="line">        name = component.value();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未找到 @Component，继续在其他注解中查找@Component:</span></span><br><span class="line">        <span class="keyword">for</span> (Annotation anno : clazz.getAnnotations()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (findAnnotation(anno.annotationType(), Component.class) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    name = (String) anno.annotationType().getMethod(<span class="string">&quot;value&quot;</span>).invoke(anno);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ReflectiveOperationException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionException</span>(<span class="string">&quot;Cannot get annotation value.&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// default name: &quot;HelloWorld&quot; =&gt; &quot;helloWorld&quot;</span></span><br><span class="line">        name = clazz.getSimpleName();</span><br><span class="line">        name = Character.toLowerCase(name.charAt(<span class="number">0</span>)) + name.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="findAnnotation递归查找是否包含有annoclass"><a href="#findAnnotation递归查找是否包含有annoclass" class="headerlink" title="findAnnotation递归查找是否包含有annoclass"></a>findAnnotation递归查找是否包含有annoclass</h4><ul><li><code>target</code>: 要查找注解的目标类。</li><li><code>annoClass</code>: 要查找的注解类型。</li></ul><p><strong>方法逻辑</strong></p><ol><li><strong>直接查找注解</strong>：<ol><li><p>使用 <code>target.getAnnotation(annoClass)</code> 查找目标类上直接标注的注解。</p></li><li><p>如果找到，直接返回<strong>目标注解的实例（当你使用自定义注解标注一个类、方法或字段时，Java会为该注解生成一个实例，这个实例包含了你在使用注解时指定的属性值（.value()获取））</strong>。</p></li><li><p>例如</p></li><li><pre><code class="java">@Retention(RetentionPolicy.RUNTIME) // 表示注解在运行时可用public @interface MyAnnotation &#123;    String value(); // 定义一个属性&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">2. **递归****查找元注解**：</span><br><span class="line">   1. 遍历目标类上的所有注解（`target.getAnnotations()`）。</span><br><span class="line">   2. 对于每个注解，检查其注解类型（`annoType`）。</span><br><span class="line">   3. 如果注解类型不是 `java.lang.annotation` 包中的注解（即非JDK内置注解），递归调用 `findAnnotation` 查找该注解类型上是否标注了目标注解（`annoClass`）。</span><br><span class="line">3. **处理重复注解**：</span><br><span class="line">   1. 如果在递归查找过程中发现多个符合条件的注解，抛出 `BeanDefinitionException` 异常，提示存在重复注解。</span><br><span class="line">4. **返回结果**：</span><br><span class="line">   1. 返回找到的注解实例，如果未找到则返回 `null`。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static &lt;A extends Annotation&gt; A findAnnotation(Class&lt;?&gt; target, Class&lt;A&gt; annoClass) &#123;</span><br><span class="line">    A a = target.getAnnotation(annoClass);</span><br><span class="line">    for (Annotation anno : target.getAnnotations()) &#123;</span><br><span class="line">        Class&lt;? extends Annotation&gt; annoType = anno.annotationType();</span><br><span class="line">        if (!annoType.getPackageName().equals(&quot;java.lang.annotation&quot;)) &#123;</span><br><span class="line">            A found = findAnnotation(annoType, annoClass);</span><br><span class="line">            if (found != null) &#123;</span><br><span class="line">                if (a != null) &#123;</span><br><span class="line">                    throw new BeanDefinitionException(&quot;Duplicate @&quot; + annoClass.getSimpleName() + &quot; found on class &quot; + target.getSimpleName());</span><br><span class="line">                &#125;</span><br><span class="line">                a = found;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol></li></ol><h4 id="获取bean-name"><a href="#获取bean-name" class="headerlink" title="获取bean name"></a>获取bean name</h4><p>对应语句</p><p> <code>name = (String) anno.annotationType().getMethod(&quot;value&quot;).invoke(anno);</code></p><p>使用示例（通过反射获取value值，也就是component中的name，也就是bean的名称）</p><ol><li><strong><code>clazz.getAnnotations()</code></strong>:<ol><li>这行代码用于获取指定类（<code>clazz</code>）上声明的所有注解。<code>clazz</code> 是一个类的 <code>Class</code> 对象，<code>getAnnotations()</code> 方法返回该类上所有注解的数组，返回的是一个 <code>Annotation[]</code> 数组。</li></ol></li><li><strong><code>for (Annotation anno : clazz.getAnnotations())</code></strong>:<ol><li>通过遍历所有的注解实例，逐个处理每个注解。</li></ol></li><li><strong><code>anno.annotationType()</code></strong>:<ol><li>通过调用 <code>anno.annotationType()</code> 获取注解的类型（<code>Class&lt;? extends Annotation&gt;</code>）。这一步相当于获取该注解的 <code>Class</code> 对象。</li></ol></li><li><strong><code>getMethod(&quot;value&quot;)</code></strong>:<ol><li>通过调用注解的 <code>Class</code> 对象的 <code>getMethod(&quot;value&quot;)</code> 方法，反射获取注解中的名为 <code>&quot;value&quot;</code> 的方法。这里假设注解中有一个名为 <code>value</code> 的方法。</li></ol></li><li><strong><code>invoke(anno)</code></strong>:<ol><li>通过反射调用 <code>value</code> 方法，从注解实例 <code>anno</code> 中获取 <code>value</code> 属性的值。返回值是 <code>Object</code> 类型，需要通过强制转换转换为 <code>String</code> 类型。</li></ol></li><li><strong><code>(String)</code></strong>:<ol><li>将返回的 <code>Object</code> 类型的值强制转换为 <code>String</code> 类型。</li></ol></li><li><strong><code>name = (String) anno.annotationType().getMethod(&quot;value&quot;).invoke(anno);</code></strong>:<ol><li>这一行代码完成了通过反射调用注解的 <code>value</code> 方法，获取注解属性值，并将其赋值给变量 <code>name</code>。</li></ol></li><li>定义注解：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 注解在运行时可用</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>; <span class="comment">// 定义一个 String 类型的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这段代码定义了一个自定义注解 <code>MyAnnotation</code>，它有一个 <code>String</code> 类型的属性 <code>value</code>，并且注解保留策略是 <code>RUNTIME</code>，意味着该注解在运行时可以通过反射获取。</li><li>使用注解：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value = &quot;Hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 类体为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里的 <code>MyClass</code> 类被 <code>@MyAnnotation</code> 注解修饰，注解的 <code>value</code> 属性值是 <code>&quot;Hello&quot;</code>。</li><li>通过反射获取注解属性值：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 MyClass 类上的所有注解</span></span><br><span class="line">            Annotation[] annotations = MyClass.class.getAnnotations();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 遍历注解</span></span><br><span class="line">            <span class="keyword">for</span> (Annotation anno : annotations) &#123;</span><br><span class="line">                <span class="comment">// 获取注解类型</span></span><br><span class="line">                Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annoType = anno.annotationType();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 检查是否是 MyAnnotation 注解</span></span><br><span class="line">                <span class="keyword">if</span> (annoType == MyAnnotation.class) &#123;</span><br><span class="line">                    <span class="comment">// 通过反射获取注解的 value 属性值</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) annoType.getMethod(<span class="string">&quot;value&quot;</span>).invoke(anno);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Annotation value: &quot;</span> + value); <span class="comment">// 输出: Hello</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Annotation value: Hello</span><br></pre></td></tr></table></figure><ul><li><code>Main</code> 类通过反射获取 <code>MyClass</code> 类上的注解 <code>MyAnnotation</code>，并打印出注解的 <code>value</code> 属性的值 <code>&quot;Hello&quot;</code>。</li></ul><h4 id="获取-configuration中的-Bean"><a href="#获取-configuration中的-Bean" class="headerlink" title="获取@configuration中的@Bean"></a>获取@configuration中的@Bean</h4><p><strong>扫描带有</strong> <code>@Configuration</code> <strong>注解的类中的</strong> <code>@Bean</code> <strong>方法，并将这些方法作为<strong><strong>工厂方法</strong></strong>创建</strong> <code>BeanDefinition</code> <strong>对象</strong>。这些 <code>BeanDefinition</code> 对象会被添加到 <code>defs</code> 中，供后续的 Bean 创建和管理使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">scanFactoryMethods</span><span class="params">(String factoryBeanName, Class&lt;?&gt; clazz, Map&lt;String, BeanDefinition&gt; defs)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Method method : clazz.getDeclaredMethods()) &#123;</span><br><span class="line">        <span class="comment">// 是否带有@Bean标注:</span></span><br><span class="line">        <span class="type">Bean</span> <span class="variable">bean</span> <span class="operator">=</span> method.getAnnotation(Bean.class);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Bean的声明类型是方法返回类型:</span></span><br><span class="line">            Class&lt;?&gt; beanClass = method.getReturnType();</span><br><span class="line">            <span class="type">var</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>(</span><br><span class="line">                ClassUtils.getBeanName(method), beanClass,</span><br><span class="line">                factoryBeanName,</span><br><span class="line">                <span class="comment">// 创建Bean的工厂方法:</span></span><br><span class="line">                method,</span><br><span class="line">                <span class="comment">// @Order</span></span><br><span class="line">                getOrder(method),</span><br><span class="line">                <span class="comment">// 是否存在@Primary标注?</span></span><br><span class="line">                method.isAnnotationPresent(Primary.class),</span><br><span class="line">                <span class="comment">// init方法名称:</span></span><br><span class="line">                bean.initMethod().isEmpty() ? <span class="literal">null</span> : bean.initMethod(),</span><br><span class="line">                <span class="comment">// destroy方法名称:</span></span><br><span class="line">                bean.destroyMethod().isEmpty() ? <span class="literal">null</span> : bean.destroyMethod(),</span><br><span class="line">                <span class="comment">// @PostConstruct / @PreDestroy方法:null, null);</span></span><br><span class="line">            addBeanDefinitions(defs, def);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 手写spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ioc </tag>
            
            <tag> 廖雪峰 </tag>
            
            <tag> properties </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.3 树形查找</title>
      <link href="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/"/>
      <url>/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树 AVL树"></a>平衡二叉树 AVL树</h1><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-12.png"></p><h2 id="AVL定义"><a href="#AVL定义" class="headerlink" title="AVL定义"></a>AVL定义</h2><p>取发明者的姓名开头字母——AVL。</p><p>结点的平衡因子&#x3D; 左子树高-右子树高。</p><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-14.png"></p><h2 id="AVL数的插入"><a href="#AVL数的插入" class="headerlink" title="AVL数的插入"></a>AVL数的插入</h2><p>每次调整最小不平衡子树。</p><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-11.png"></p><p>有以下4种形式</p><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-8.png"></p><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-7.png"></p><h3 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h3><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-13.png"></p><h3 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h3><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-5.png"></p><h3 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h3><p>和LR名称一致，将A左孩子的右孩子先左上旋再右上旋。</p><p>（A是最小不平衡字树的的根节点）</p><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-4.png"></p><h3 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h3><p>和RL名称一致，将A右孩子的左孩子先右上旋再左上旋。</p><p>（A是最小不平衡字树的的根节点）</p><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-9.png"></p><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-10.png"></p><h2 id="AVL树的查找效率"><a href="#AVL树的查找效率" class="headerlink" title="AVL树的查找效率"></a>AVL树的查找效率</h2><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-3.png"></p><ul><li><p><strong>含有n个结点的平衡二叉树的最大深度为O(log2n)，平衡二叉树的查找长度为O(log2n)</strong></p><ul><li>对于前者的证明较为复杂</li></ul></li></ul><h2 id="树的前驱与后继结点"><a href="#树的前驱与后继结点" class="headerlink" title="树的前驱与后继结点"></a>树的前驱与后继结点</h2><p>前驱节点就是中序遍历位于前面的结点。</p><p>可以这么记忆：因为二叉搜索树中序遍历是从小到大的，因此前驱与后继都是对于中序遍历而言的。</p><h2 id="AVL树的删除"><a href="#AVL树的删除" class="headerlink" title="AVL树的删除"></a>AVL树的删除</h2><h3 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h3><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-2.png"></p><h3 id="相关例子（重要）"><a href="#相关例子（重要）" class="headerlink" title="相关例子（重要）"></a>相关例子（重要）</h3><h4 id="删除9"><a href="#删除9" class="headerlink" title="删除9"></a><strong>删除9</strong></h4><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-6.png"></p><ul><li>可以看到9为叶子结点，直接删除，并且向上查找并没有找到最小不平衡子树，于是结束。</li></ul><h4 id="删除55"><a href="#删除55" class="headerlink" title="删除55"></a><strong>删除55</strong></h4><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-1.png"></p><ul><li><p>删除55之后，发现找到了最小不平衡子树，根节点为75</p></li><li><p>个头最高的儿子和孙子分别分别为80和90</p></li><li><p>根据孙子的位置调整平衡（LL&#x2F;RR&#x2F;LR&#x2F;RL）</p></li><li><p>可以看到在这个例子中是一种RR，进行下图中的相关关操作</p></li></ul><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image.png"></p><ul><li>注意5，有可能会导致祖先节点不平衡，所以<strong>还得继续判断祖先是否平衡</strong>。在本题中并没有这种情况。</li></ul><h4 id="删除32"><a href="#删除32" class="headerlink" title="删除32"></a>删除32</h4><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-26.png"></p><ul><li><p>发现最小不平衡子树以44为根结点。</p></li><li><p>最高儿子为78，最高孙子为50，RL。</p></li></ul><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-29.png"></p><h3 id="继续调整父节点"><a href="#继续调整父节点" class="headerlink" title="继续调整父节点"></a>继续调整父节点</h3><p>将例3中的例子作为右子树中的一部分，造成el不平衡</p><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-28.png"></p><p>发现根节点此时变成了最小的不平衡子树</p><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-27.png"></p><p>发现此时平衡了。</p><p>例5：</p><p>本例体现<strong>二叉排序树的删除规则删除结点（删除的节点有两颗子树的情况）</strong></p><p>以下以前驱结点（中序遍历的前一个结点）为例进行替换（其实也可以使用后继节点，这里就是77）</p><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-24.png"></p><p>以上，首先变成了之前删除叶节点的情况，再执行上文中类似的操作</p><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-25.png"></p><h2 id="一些结论"><a href="#一些结论" class="headerlink" title="一些结论"></a>一些结论</h2><ul><li><p>只有左孩子才能右上旋，之后右孩子才能左上旋。</p></li><li><p>插入操作中，只需要调整最小不平衡子树，之后其他结点都平衡。</p></li></ul><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="为什么要发明红黑树？"><a href="#为什么要发明红黑树？" class="headerlink" title="为什么要发明红黑树？"></a>为什么要发明红黑树？</h2><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-23.png"></p><h2 id="红黑树的定义（口诀）"><a href="#红黑树的定义（口诀）" class="headerlink" title="红黑树的定义（口诀）"></a>红黑树的定义（口诀）</h2><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-19.png"></p><ul><li><p>左根右表明这个是一个二叉排序树</p></li><li><p>根叶黑：根和叶子节点都是黑色的</p></li><li><p>不红红：不存在<strong>父子结点</strong>均是是红色的</p></li><li><p>黑路同：每一个结点从它到任意一个2叶节点的简单路径上所含黑结点的数目相同</p></li></ul><h3 id="外部结点、null结点、失败结点"><a href="#外部结点、null结点、失败结点" class="headerlink" title="外部结点、null结点、失败结点"></a>外部结点、null结点、失败结点</h3><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-22.png"></p><p>主题红黑树中，叶子节点、失败节点、外部节点、null结点指的都是同一个东西。</p><h2 id="黑高"><a href="#黑高" class="headerlink" title="黑高"></a>黑高</h2><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-17.png"></p><h2 id="红黑树性质"><a href="#红黑树性质" class="headerlink" title="红黑树性质"></a>红黑树性质</h2><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-16.png"></p><h2 id="红黑树查找"><a href="#红黑树查找" class="headerlink" title="红黑树查找"></a>红黑树查找</h2><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-18.png"></p><h2 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h2><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-21.png"></p><ul><li><p>为什么插入不是根的新节点要先把他染为红色的呢？</p><ul><li>因为他不会违反黑路同的结论</li></ul></li><li><p>黑叔的情况中的LL……这些是针对哪个结点来说的？</p><ul><li>针对爷结点</li></ul></li><li><p>每次插入新的结点破坏的特性只有“不红红”这条特性，所以2判断是不是符合条件的红黑树的时候只需要判断“不红红”这个条件就可以了。</p></li><li><p>染色可以理解为将交换的结点颜色直接红黑取反</p></li></ul><h3 id="例子（逐步插入节点构建一个红黑树）"><a href="#例子（逐步插入节点构建一个红黑树）" class="headerlink" title="例子（逐步插入节点构建一个红黑树）"></a>例子（逐步插入节点构建一个红黑树）</h3><h4 id="首先插入20，10，5（插入根，符合要求，以及叔黑）"><a href="#首先插入20，10，5（插入根，符合要求，以及叔黑）" class="headerlink" title="首先插入20，10，5（插入根，符合要求，以及叔黑）"></a>首先插入20，10，5（插入根，符合要求，以及叔黑）</h4><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-15.png"></p><p>上图中左下角的染色可以理解为“颜色取反——黑色变成红色，红色变成黑色”。</p><h4 id="继续插入30（叔红）"><a href="#继续插入30（叔红）" class="headerlink" title="继续插入30（叔红）"></a>继续插入30（叔红）</h4><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-20.png"></p><p>如上图，发现叔叔结点是红色的，符合叔红的情况。</p><p>染色指的是给“爷叔父”一共3个结点染色。</p><p>爷变为新结点指的是此时将新结点看做是新插入的结点，用同样的逻辑进行判断。此时发现爷结点是根节点，所以把他染为黑色，结束。</p><h4 id="插入40"><a href="#插入40" class="headerlink" title="插入40"></a>插入40</h4><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-31.png"></p><h4 id="中间略"><a href="#中间略" class="headerlink" title="中间略"></a>中间略</h4><p>后面发现当红黑树逐渐变大的时候很少会再调整数的结构，很多情况下可以直接插入。</p><h4 id="插入22（两个红叔）"><a href="#插入22（两个红叔）" class="headerlink" title="插入22（两个红叔）"></a>插入22（两个红叔）</h4><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-35.png"></p><h4 id="插入23（LR型、黑叔）"><a href="#插入23（LR型、黑叔）" class="headerlink" title="插入23（LR型、黑叔）"></a>插入23（LR型、黑叔）</h4><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-34.png"></p><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-30.png"></p><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-33.png"></p><p><img src="/2025/03/15/7-3%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE/image-32.png"></p><p>注意是原来的爷和儿染色，如图23，25结点。</p><h4 id="后面略"><a href="#后面略" class="headerlink" title="后面略"></a>后面略</h4>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> AVL </tag>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现PropertyResolver</title>
      <link href="/2025/03/14/%E5%AE%9E%E7%8E%B0PropertyResolver/"/>
      <url>/2025/03/14/%E5%AE%9E%E7%8E%B0PropertyResolver/</url>
      
        <content type="html"><![CDATA[<h1 id="实现PropertyResolver"><a href="#实现PropertyResolver" class="headerlink" title="实现PropertyResolver"></a>实现PropertyResolver</h1><p><a href="https://liaoxuefeng.com/books/summerframework/ioc/property-resolver/index.html">https://liaoxuefeng.com/books/summerframework/ioc/property-resolver/index.html</a></p><p>Spring的注入分为<code>@Autowired</code>和<code>@Value</code>两种。对于<code>@Autowired</code>，涉及到Bean的依赖，而对于<code>@Value</code>，则仅仅是将对应的配置注入，不涉及Bean的依赖，相对比较简单。为了注入配置，我们用<code>PropertyResolver</code>保存所有配置项，对外提供查询功能。</p><p>本节我们来实现<code>PropertyResolver</code>，它支持3种查询方式：</p><ol><li>按配置的key查询，例如：<code>getProperty(&quot;app.title&quot;)</code>;</li><li>以<code>$&#123;abc.xyz&#125;</code>形式的查询，例如，<code>getProperty(&quot;$&#123;app.title&#125;&quot;)</code>，常用于<code>@Value(&quot;$&#123;app.title&#125;&quot;)</code>注入；</li><li>带默认值的，以<code>$&#123;abc.xyz:defaultValue&#125;</code>形式的查询，例如，<code>getProperty(&quot;$&#123;app.title:Summer&#125;&quot;)</code>，常用于<code>@Value(&quot;$&#123;app.title:Summer&#125;&quot;)</code>注入。</li></ol><p>Java本身提供了按key-value查询的<code>Properties</code>，传入<code>Properties</code>，内部按key-value存储。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PropertyResolver</span><span class="params">(Properties props)</span> &#123;</span><br><span class="line">    <span class="comment">// 存入环境变量</span></span><br><span class="line">    <span class="built_in">this</span>.properties.putAll(System.getenv());</span><br><span class="line">    <span class="comment">// 获取props中的所有的key，成为一个set</span></span><br><span class="line">    Set&lt;String&gt; names = props.stringPropertyNames();</span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">        <span class="comment">// 将props中的所有键值对存储到properties中</span></span><br><span class="line">        <span class="comment">//props.getProperty获取value</span></span><br><span class="line">        <span class="built_in">this</span>.properties.put(name, props.getProperty(name));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果开启了调试日志模式</span></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="comment">// 对key按照字典序进行排序</span></span><br><span class="line">        List&lt;String&gt; keys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.properties.keySet());</span><br><span class="line">        Collections.sort(keys);</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;PropertyResolver: &#123;&#125; = &#123;&#125;&quot;</span>, key, <span class="built_in">this</span>.properties.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// register converters:</span></span><br><span class="line">    converters.put(String.class, s -&gt; s);</span><br><span class="line">    converters.put(<span class="type">boolean</span>.class, s -&gt; Boolean.parseBoolean(s));</span><br><span class="line">    converters.put(Boolean.class, s -&gt; Boolean.valueOf(s));</span><br><span class="line">    .....<span class="comment">//略</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="关于Java提供的Properties"><a href="#关于Java提供的Properties" class="headerlink" title="关于Java提供的Properties"></a>关于Java提供的<code>Properties</code></h2><p><code>Properties</code> 是 Java 中的一个类，位于 <code>java.util</code> 包中，用于管理键值对（key-value pairs）形式的配置数据。它继承自 <code>Hashtable&lt;Object, Object&gt;</code>，但通常用于处理字符串类型的键和值。<code>Properties</code> 类常用于读取和写入配置文件（如 <code>.properties</code> 文件）。</p><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=NDBmYTc0NDkyZGM4NzgxZmNkYjEzMjEwNDhlZWQxYWJfbVRpOW5BQkp4cVlCNW92WU5hZ25JQVVsRmFpTVUzMW9fVG9rZW46UzFoOGIxMjlNb21HMHh4Q0lJaWNxbWRrbkFmXzE3NDE5NTUwMjM6MTc0MTk1ODYyM19WNA" alt="img"></p><h3 id="properties特点"><a href="#properties特点" class="headerlink" title="properties特点"></a>properties特点</h3><ol><li><strong>配置文件支持</strong>：</li></ol><p>可以从 <code>.properties</code> 文件加载数据，或将数据保存到 <code>.properties</code> 文件。<code>Properties</code> 是 Java 中专门用于处理键值对配置数据的类，它继承自 <code>Hashtable</code>，但在设计上有一些特定的优势，使其在处理配置文件时比 <code>Hashtable</code> 或其他键值对集合（如 <code>HashMap</code>）更合适。以下是 <code>Properties</code> 的优势和使用场景：</p><ol><li><strong>专为配置设计</strong></li></ol><p><code>Properties</code> 是为管理配置数据而设计的，它的 API 更加简洁和直观，适合处理字符串类型的键值对。例如：</p><ul><li><code>setProperty(String key, String value)</code>：设置键值对。</li><li><code>getProperty(String key)</code>：获取键对应的值。</li><li><code>getProperty(String key, String defaultValue)</code>：获取值，如果键不存在，返回默认值。</li></ul><p> 这些方法专门为配置场景设计，比 <code>Hashtable</code> 的通用方法（如 <code>put()</code> 和 <code>get()</code>）更符合配置管理的需求。</p><ol><li><strong>配置文件支持</strong></li></ol><p><code>Properties</code> 提供了直接读写配置文件的功能，这是它最大的优势之一：</p><ul><li><strong>加载配置文件</strong>：通过 <code>load(InputStream in)</code> 方法，可以从 <code>.properties</code> 文件或输入流中加载配置。</li><li><strong>保存配置文件</strong>：通过 <code>store(OutputStream out, String comments)</code> 方法，可以将配置保存到文件或输出流中。</li></ul><p> 这种功能是 <code>Hashtable</code> 和其他键值对集合所不具备的。</p><p> 示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Map</span>&lt;<span class="title class_">String</span>, <span class="title class_">String</span>&gt; env = <span class="title class_">System</span>.<span class="title function_">getenv</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="title class_">Map</span>.<span class="property">Entry</span>&lt;<span class="title class_">String</span>, <span class="title class_">String</span>&gt; entry : env.<span class="title function_">entrySet</span>()) &#123;</span><br><span class="line">    <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(entry.<span class="title function_">getKey</span>() + <span class="string">&quot; = &quot;</span> + entry.<span class="title function_">getValue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 以上代码通过<code>System.getenv();</code>获得环境变量。环境变量应是如JAVA_HOME&#x3D;’xxx&#x2F;bin’的形式，他会自动将&#x3D;分割，前面的作为key，后面的作为value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载配置文件（此时config.properties与test在同一文件夹中）</span></span><br><span class="line">        <span class="comment">// 如果想通过classloader进行加载，可以这样写</span></span><br><span class="line">        <span class="comment">// test.class.getClassLoader().getResourceAsStream(&quot;com/propertyResolver/config.properties&quot;))</span></span><br><span class="line">        <span class="comment">// 注意用的是/而不是.</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> test.class.getResourceAsStream(<span class="string">&quot;config.properties&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;抱歉，找不到配置文件!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加载配置文件</span></span><br><span class="line">            props.load(input);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 显示配置文件内容</span></span><br><span class="line">            System.out.println(<span class="string">&quot;配置文件加载成功！&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;配置内容：&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String key : props.stringPropertyNames()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> props.getProperty(key);</span><br><span class="line">                System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储配置文件</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.properties&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 将属性存储到文件中</span></span><br><span class="line">            props.store(output, <span class="string">&quot;这是存储的配置文件&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;配置文件存储成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码会输出和test在同一个文件夹中的config.properties的内容。</p><ol><li><strong>继承****自</strong> <code>Hashtable</code>：可以使用 <code>Hashtable</code> 的方法，如 <code>put()</code>、<code>get()</code> 等。</li><li><strong>线程安全</strong>：由于继承自 <code>Hashtable</code>，<code>Properties</code> 是线程安全的。</li><li><strong>键值对存储</strong>：存储的数据是字符串类型的键值对。</li></ol><h2 id="Map-作用"><a href="#Map-作用" class="headerlink" title="Map&lt;Class&lt;?&gt;, Function&lt;String, Object&gt;&gt; 作用"></a>Map&lt;Class&lt;?&gt;, Function&lt;String, Object&gt;&gt; 作用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Class&lt;?&gt;, Function&lt;String, Object&gt;&gt; converters = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>key是.class（作用是后续value函数式接口返回值的类型），value是函数式接口function接收一个String参数，返回一个结果Object。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a><strong>使用方式</strong></h3><p>首先注册以下转换方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">converters.put(String.class, s -&gt; s);</span><br><span class="line">converters.put(<span class="type">boolean</span>.class, s -&gt; Boolean.parseBoolean(s));</span><br><span class="line">converters.put(Boolean.class, s -&gt; Boolean.valueOf(s));</span><br></pre></td></tr></table></figure><p>假设你有一个配置文件，其中包含以下内容：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name</span>=<span class="string">John</span></span><br><span class="line"><span class="attr">isAdmin</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>你可以使用 <code>converters</code> 来将这些字符串值转换为对应的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) converters.get(String.class).apply(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isAdmin</span> <span class="operator">=</span> (<span class="type">boolean</span>) converters.get(<span class="type">boolean</span>.class).apply(<span class="string">&quot;true&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样，<code>name</code> 会被转换为 <code>String</code> 类型，<code>isAdmin</code> 会被转换为 <code>boolean</code> 类型。</p><p>在这个项目中，他对外提供的接口是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">convert</span><span class="params">(Class&lt;?&gt; clazz, String value)</span> &#123;</span><br><span class="line">    Function&lt;String, Object&gt; fn = <span class="built_in">this</span>.converters.get(clazz);</span><br><span class="line">    <span class="keyword">if</span> (fn == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unsupported value type: &quot;</span> + clazz.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// apply使用function接口中的方法</span></span><br><span class="line">    <span class="keyword">return</span> (T) fn.apply(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 手写spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ioc </tag>
            
            <tag> 廖雪峰 </tag>
            
            <tag> properties </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口求子数组个数</title>
      <link href="/2025/03/13/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2025/03/13/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>参考视屏：<a href="https://www.bilibili.com/video/BV1TqxCeZEmb/?spm_id_from=333.999.0.0&vd_source=437305a32a44e4b125d70c120e4ebb01">恰好型滑动窗口【力扣周赛 417】_哔哩哔哩_bilibili</a></p><h3 id="3306-元音辅音字符串技术2"><a href="#3306-元音辅音字符串技术2" class="headerlink" title="3306.元音辅音字符串技术2"></a>3306.元音辅音字符串技术2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countOfSubstrings</span><span class="params">(String word, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = word.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> f(s, k) - f(s, k + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">f</span><span class="params">(<span class="type">char</span>[] word, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 这里用哈希表实现，替换成数组会更快</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; cnt1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// 每种元音的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt2</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 辅音个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> b : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;aeiou&quot;</span>.indexOf(b) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                cnt1.merge(b, <span class="number">1</span>, Integer::sum); <span class="comment">// ++cnt1[b]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cnt1.size() == <span class="number">5</span> &amp;&amp; cnt2 &gt;= k) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">out</span> <span class="operator">=</span> word[left];</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;aeiou&quot;</span>.indexOf(out) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cnt1.merge(out, -<span class="number">1</span>, Integer::sum) == <span class="number">0</span>) &#123; <span class="comment">// --cnt1[out] == 0</span></span><br><span class="line">                        cnt1.remove(out);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cnt2--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="越长越合法"><a href="#越长越合法" class="headerlink" title="越长越合法"></a>越长越合法</h2><p><code>res += left;</code></p><h3 id="1358-包含有3种字符的子字符串数目"><a href="#1358-包含有3种字符的子字符串数目" class="headerlink" title="1358.包含有3种字符的子字符串数目"></a>1358.包含有3种字符的子字符串数目</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 滑动窗口，至少类问题</span></span><br><span class="line">        <span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            hash[s.charAt(right) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="comment">// 符合条件直到不符合</span></span><br><span class="line">            <span class="keyword">while</span> (isValid(hash)) &#123;</span><br><span class="line">                hash[s.charAt(left) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意这里，由于题目中是“至少”，此时算出的left是第一个不合法的字符串下标。0,1..left-1一共left个子字符串都是合法的。</span></span><br><span class="line">            <span class="comment">// 前提是right是确定的，所以right每次向右移动重新从0,1..left-1都可以再加一次因为“至少”代表着它的字字符串都符合，比他大的自然也符合。</span></span><br><span class="line">            res += left;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span>[] hash)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> h : hash) &#123;</span><br><span class="line">            <span class="keyword">if</span> (h &lt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2962-包含三种字符的子字符串数目"><a href="#2962-包含三种字符的子字符串数目" class="headerlink" title="2962.包含三种字符的子字符串数目"></a>2962.包含三种字符的子字符串数目</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countSubarrays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 求子数组个数至少出现的个数，滑动窗口</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">            maxNum = Math.max(maxNum, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] == maxNum) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断符合要求</span></span><br><span class="line">            <span class="keyword">while</span> (cnt &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] == maxNum)</span><br><span class="line">                    cnt--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            res += left;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="越短越合法"><a href="#越短越合法" class="headerlink" title="越短越合法"></a>越短越合法</h2><p><code> res += right - left + 1;</code></p><h3 id="713-乘积小于k的子数组"><a href="#713-乘积小于k的子数组" class="headerlink" title="713.乘积小于k的子数组"></a>713.乘积小于k的子数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubarrayProductLessThanK</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 和至少（大于）相反，这是小于操作</span></span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            tmp *= nums[right];</span><br><span class="line">            <span class="comment">//不符合条件直到符合</span></span><br><span class="line">            <span class="keyword">while</span> (tmp &gt;= k) &#123;</span><br><span class="line">                tmp /= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            res += right - left + <span class="number">1</span>;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 子数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用反射调用自定义classloader方法</title>
      <link href="/2025/03/12/%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89classloader%E6%96%B9%E6%B3%95/"/>
      <url>/2025/03/12/%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89classloader%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>自定义classloader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ResourceResolver.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据类名从指定路径加载类文件。若找不到，则通过父类加载器加载。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 类的全名（包括包名）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加载的类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException 如果无法找到类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> getClassName(name);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path, className);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">             <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取类文件内容</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] classData = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用字节数据定义类</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 如果文件读取失败，委托父类去加载</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载类，如果找不到会委托父类加载器加载类。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 类的全名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resolve 是否解析类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加载的类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException 如果无法找到类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// @Override</span></span><br><span class="line">    <span class="comment">// protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123;</span></span><br><span class="line">    <span class="comment">//     // 优先使用自定义的加载方式</span></span><br><span class="line">    <span class="comment">//     try &#123;</span></span><br><span class="line">    <span class="comment">//         return findClass(name);</span></span><br><span class="line">    <span class="comment">//     &#125; catch (ClassNotFoundException e) &#123;</span></span><br><span class="line">    <span class="comment">//         // 如果找不到类，则委托给父类加载器</span></span><br><span class="line">    <span class="comment">//         return super.loadClass(name, resolve);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取给定类名的简短形式并附加 &quot;.class&quot; 后缀。</span></span><br><span class="line"><span class="comment">     * 如果输入的类名包含包名，方法会提取类名部分并返回；</span></span><br><span class="line"><span class="comment">     * 如果类名没有包名，则直接返回类名并附加 &quot;.class&quot; 后缀。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 完整的类名（可以包含包名），例如 &quot;com.example.MyClass&quot; 或 &quot;MyClass&quot;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 仅包含类名并附加 &quot;.class&quot; 后缀的字符串，例如 &quot;MyClass.class&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getClassName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> name + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name.substring(index + <span class="number">1</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试用例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义的 java.lang.Object 类</span></span><br><span class="line"><span class="keyword">package</span> com.ResourceResolver.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// getPropertyTest();</span></span><br><span class="line">        <span class="comment">// getclassLoaderTest();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用自定义classloader</span></span><br><span class="line">        <span class="comment">//这里使用绝对路径让自定义的classloader找到了已经编译好的HelloWorld.class文件</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;E:\\java-learning\\src\\com\\classloader&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加载 MyClass 类</span></span><br><span class="line">            Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">&quot;com.ResourceResolver.classloader.HelloWorld&quot;</span>);</span><br><span class="line">            <span class="comment">// 使用反射</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">sayMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.getConstructor().newInstance();</span><br><span class="line">            sayMethod.invoke(instance);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;类加载成功: &quot;</span> + clazz.getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> classloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.4.2可靠传输协议</title>
      <link href="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/"/>
      <url>/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="可靠传输机制"><a href="#可靠传输机制" class="headerlink" title="可靠传输机制"></a>可靠传输机制</h1><h2 id="1-停止等待协议-S-W"><a href="#1-停止等待协议-S-W" class="headerlink" title="1.停止等待协议 S-W"></a>1.停止等待协议 S-W</h2><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-13.png"></p><p>几个关键点</p><ul><li><p>发送窗口长度为1，接收窗口长度为1</p></li><li><p>有确认机制</p></li><li><p>有超时重传机制</p></li><li><p>有帧编号，且帧编号长度为1bit，要求发送窗口和接收窗口的长度之和小于等于2的n次方</p></li></ul><p>注意超时重传是对于<strong>发送方</strong>而言的。</p><h3 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h3><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-14.png"></p><p>上图中描述的是每一次发送方发送数据帧，接收方如果接受之后就会立刻返回一个ack，并且会将接收窗口向右移动一位。</p><ul><li>注意图中ack1中的1代表的是帧序号（之前说了s-w协议帧序号为1bit，只能表示0或1）。</li></ul><p>一旦发送方接收到这个ack，就会同样将发送窗口向右移用一位（上图中应该是B-&gt;C）。</p><p>所以我们发现，只有发送方接受到接收方发送的请求的时候他才会向右移动发送窗口，否则就会阻塞，最后超时重传，可以看下面这个例子。</p><h3 id="返回的确认帧ack丢失"><a href="#返回的确认帧ack丢失" class="headerlink" title="返回的确认帧ack丢失"></a>返回的确认帧ack丢失</h3><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-12.png"></p><p>可以看到此时接受由于已经接收到了数据帧，所以接收窗口已经向右移动了，但是它返回的ack帧丢失了。</p><p>对于发送方，他就会触发超时重传机制重发data1这个数据（这里的1也是编号）。</p><p>接受方此时就会发现这个这个帧落在了接受窗口的外面（<strong>发现编号不一致，由于窗口大小为1，所以1bit就够了</strong>），于是重新返回确认帧ack1，让发送方的窗口向右移动。</p><h3 id="数据帧丢失"><a href="#数据帧丢失" class="headerlink" title="数据帧丢失"></a>数据帧丢失</h3><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-10.png"></p><p>发送方发送的帧丢失了，发送方触发超时重传机制重传。</p><h3 id="数据帧有差错"><a href="#数据帧有差错" class="headerlink" title="数据帧有差错"></a>数据帧有差错</h3><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-9.png"></p><p>数据帧有差错，接受方直接丢弃，发送方超时重传。</p><h2 id="2-后退N帧协议-GBN"><a href="#2-后退N帧协议-GBN" class="headerlink" title="2.后退N帧协议 GBN"></a>2.后退N帧协议 GBN</h2><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-11.png"></p><h3 id="正常情况-1"><a href="#正常情况-1" class="headerlink" title="正常情况"></a>正常情况</h3><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-4.png"></p><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-7.png"></p><p>如图，正常情况下，接受窗口每次接受一个数据帧后向右滑动一次，当接受到最后的那个数据帧的时候才会返回一个ack2（2是帧序号），然后发送方的滑动窗口向右移动到发送窗口的大小继续上述流程。</p><h3 id="数据帧丢失或错误"><a href="#数据帧丢失或错误" class="headerlink" title="数据帧丢失或错误"></a>数据帧丢失或错误</h3><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-8.png"></p><p>假设data0中途丢失或者除了差错导致接收方主动丢弃。会发生以下处理方式：</p><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-5.png"></p><p>对于之前的data3，正常接受并返回ack3。所以此时接受方的窗口向右移动了一格。</p><p>但是在接收data1的时候发现data1落在了滑动窗口的外面，因为此时没有成功接收data0使滑动窗口右移一格，于是直接丢弃data1。</p><p>与此同时，接收方会返回ack3，表示ack3前的帧都引进正常接收了。发送方发现和自己预期接收到的数据帧ack1不同，于是从data3的下一个位置开始重传。</p><p><strong>后退指的是“之前发送的帧”后退重新发。</strong></p><h3 id="ack帧丢失"><a href="#ack帧丢失" class="headerlink" title="ack帧丢失"></a>ack帧丢失</h3><p>如下图确认帧ack2丢失。</p><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-6.png"></p><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-3.png"></p><p>重传data0~data2，然后发现落在了滑动窗口之外全被丢弃并返回最后一个已经就收到的ack。如图就是Ack2。</p><h2 id="3-选择重传协议-SR"><a href="#3-选择重传协议-SR" class="headerlink" title="3.选择重传协议 SR"></a>3.选择重传协议 SR</h2><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-1.png"></p><h3 id="窗口大小限制"><a href="#窗口大小限制" class="headerlink" title="窗口大小限制"></a>窗口大小限制</h3><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-2.png"></p><p>接收窗口≤发送窗口，是为了增加利用率。</p><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image.png"></p><p>如图，接收窗口小于发送窗口的话，接收窗口在接收到帧之后可以向右滑动继续接受之后的帧。但是如果反过来。</p><p>可以看到下图中的D是无法接受发送方的，因为此时发送窗口没有右移。</p><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-26.png"></p><h3 id="正常情况-2"><a href="#正常情况-2" class="headerlink" title="正常情况"></a>正常情况</h3><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-27.png"></p><h3 id="数据帧丢失-1"><a href="#数据帧丢失-1" class="headerlink" title="数据帧丢失"></a>数据帧丢失</h3><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-25.png"></p><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-23.png"></p><p>如图可以知道<strong>对于SR协议，可以接受乱序的帧。但是对于s-w和GBN则不可以。</strong></p><h3 id="数据帧因为差错而丢弃"><a href="#数据帧因为差错而丢弃" class="headerlink" title="数据帧因为差错而丢弃"></a>数据帧因为差错而丢弃</h3><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-22.png"></p><p>接受方会主动发送NAK5（否认帧）代表帧的错误。</p><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-18.png"></p><h3 id="确认帧丢失"><a href="#确认帧丢失" class="headerlink" title="确认帧丢失"></a>确认帧丢失</h3><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-20.png"></p><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-24.png"></p><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-19.png"></p><h3 id="4-信道利用率分析"><a href="#4-信道利用率分析" class="headerlink" title="4.信道利用率分析"></a>4.信道利用率分析</h3><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-21.png"></p><h2 id="本节问题"><a href="#本节问题" class="headerlink" title="本节问题"></a>本节问题</h2><h3 id="为什么发送-接收窗口大小≤-2-n-n为帧序号的bit数"><a href="#为什么发送-接收窗口大小≤-2-n-n为帧序号的bit数" class="headerlink" title="为什么发送+接收窗口大小≤ 2^n(n为帧序号的bit数)"></a>为什么发送+接收窗口大小≤ 2^n(n为帧序号的bit数)</h3><p>以GBN为例</p><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-16.png"></p><p>以SR为例</p><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-15.png"></p><h3 id="s-w相关问题"><a href="#s-w相关问题" class="headerlink" title="s-w相关问题"></a>s-w相关问题</h3><p><img src="/2025/03/09/3-4-2%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/image-17.png"></p><p><strong>1. 在什么情况下发送窗口、接收窗口会“滑动”？</strong></p><p><strong>2. 如果数据帧丢失，收&#x2F;发双方会发生什么？</strong></p><p><strong>3. 如果接收方检测出数据帧有“差错”并将其丢弃，会发生什么？</strong></p><p><strong>4. 如果收到重复数据帧，收&#x2F;发双方会怎么做？</strong></p><p><strong>5. 为什么S-W不存在“数据帧失序”问题？</strong></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络体系结构问题补充</title>
      <link href="/2025/03/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%97%AE%E9%A2%98%E8%A1%A5%E5%85%85/"/>
      <url>/2025/03/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%97%AE%E9%A2%98%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="1-1-计算机网络概述"><a href="#1-1-计算机网络概述" class="headerlink" title="1.1 计算机网络概述"></a>1.1 计算机网络概述</h2><h3 id="1-计算机网络可以被理解为"><a href="#1-计算机网络可以被理解为" class="headerlink" title="1.计算机网络可以被理解为"></a>1.计算机网络可以被理解为</h3><p>答：由<strong>自治</strong> 的计算机互联起来的<strong>集合体</strong> 。</p><ul><li>自治计算机由软件和硬件组成，完整实现计算机公共能；互连值计算机之间相互通信；集合体质资质计算机的集合。</li></ul><h3 id="2-计算机网络最基本的功能"><a href="#2-计算机网络最基本的功能" class="headerlink" title="2.计算机网络最基本的功能"></a>2.计算机网络最基本的功能</h3><p>答：计算机网络的功能包括：</p><ul><li>数据通信</li><li>资源共享</li><li>分布式处理</li><li>信息综合处理</li><li>负载均衡</li><li>提高可靠性</li></ul><p>其中最基本的数据通信。</p><h2 id="3-数据报方式的特点以下哪些是正确的？"><a href="#3-数据报方式的特点以下哪些是正确的？" class="headerlink" title="3.数据报方式的特点以下哪些是正确的？"></a>3.数据报方式的特点以下哪些是正确的？</h2><p>首先我们应该明确“数据报”是一种无连接的分组交换技术。</p><ul><li>适用于短报文（X）<ul><li>这个不是绝对的。</li></ul></li><li>同一报文的不同分组可以经过不同的传输路径通过同行子网。（√）<ul><li>网络会为每一个分组独立的选择路由，所以转发的路径可能不同，所以分组不一定按照顺序到大目标节点，所以以下就都是错的。</li></ul></li><li>同一报文的不同分组到目的节点时顺序确定（X）</li><li>同一报文的不同分组在路由选择时只需要选择一次（X）</li></ul><h2 id="1-2-计算机网络体系结构与参考模型"><a href="#1-2-计算机网络体系结构与参考模型" class="headerlink" title="1.2 计算机网络体系结构与参考模型"></a>1.2 计算机网络体系结构与参考模型</h2><h3 id="1-对网络模型进行分层的目标是："><a href="#1-对网络模型进行分层的目标是：" class="headerlink" title="1.对网络模型进行分层的目标是："></a>1.对网络模型进行分层的目标是：</h3><ul><li>每层都实现一种相对独立的功能，降低系统复杂度</li><li>各层之间的接口清晰自然清晰，相互交流尽可能少</li><li>各层功能的精确定义独立于具体的实现方法，可以采用最合适的技术实现<ul><li>如果说“定义功能执行的方法”那就是错的。因为不用定义具体的方法。</li><li>提供<strong>标准语言（√）</strong>：通过定义标准语言，每一层可以使用统一的术语和协议进行通信，简化了设计和实现过程。开发人员只需关注特定层的功能，而不需要理解整个网络的复杂性。</li><li>定义<strong>标准页面（√）</strong>：标准页面（如协议数据单元PDU）定义了每一层之间传递数据的格式和结构，确保数据在不同层之间能够正确传递和处理。</li></ul></li><li>保持下层对上层的独立性，上层单向使用下层提供的服务</li><li>整个分层结构能进行独立的工作</li></ul><h3 id="2-OSI模型中的实体指的是"><a href="#2-OSI模型中的实体指的是" class="headerlink" title="2.OSI模型中的实体指的是"></a>2.OSI模型中的实体指的是</h3><p>答：各层中实现该层的软件或硬件，可以是“程序、模块、子程序或设备”。</p><h3 id="3-网络协议3要素指的是什么，举一些例子"><a href="#3-网络协议3要素指的是什么，举一些例子" class="headerlink" title="3.网络协议3要素指的是什么，举一些例子"></a>3.网络协议3要素指的是什么，举一些例子</h3><p><strong>1. 语法（<strong><strong>Syntax</strong></strong>）</strong></p><ul><li><strong>定义</strong>：语法规定了数据的<strong>格式</strong>和<strong>结构</strong>，即数据应该如何组织和表示。它定义了数据包、消息或帧的字段、类型、长度、顺序等。</li><li><strong>例子</strong>：<ul><li><strong>HTTP协议</strong>：HTTP请求的语法规定了请求行的格式，例如： <code>GET /index.html HTTP/1.1</code> 其中，<code>GET</code>是方法，<code>/index.html</code>是URI，<code>HTTP/1.1</code>是协议版本。</li><li><strong>IP****数据包格式</strong>：IP数据包的语法规定了头部字段的顺序和长度，如版本号、头部长度、总长度、生存时间（TTL）等。</li></ul></li></ul><p><strong>2. 语义（Semantics）</strong></p><ul><li><strong>定义</strong>：语义规定了数据的<strong>含义</strong>和<strong>操作</strong>，即每个字段或命令的具体意义以及接收方应该如何理解和处理这些信息。</li><li><strong>例子</strong>：<ul><li><strong>HTTP协议</strong>：在HTTP请求中，<code>GET</code>表示客户端请求获取资源，<code>POST</code>表示客户端提交数据到服务器。</li><li><strong>TCP协议</strong>：在TCP头部中，<code>SYN</code>标志表示请求建立连接，<code>ACK</code>标志表示确认收到数据。</li><li><strong>DNS****协议</strong>：DNS查询中的<code>A</code>记录表示查询域名的IPv4地址，<code>AAAA</code>记录表示查询域名的IPv6地址。</li></ul></li></ul><p><strong>3. 同步（Synchronization）</strong></p><ul><li><strong>定义</strong>：同步规定了通信的<strong>时序</strong>和<strong>顺序</strong>，即通信双方在什么时间发送和接收数据，以及如何处理事件顺序和超时等问题。</li><li><strong>例子</strong>：<ul><li><strong>TCP****三次握手</strong>：TCP连接的建立需要经过三次握手：<ul><li>客户端发送<code>SYN</code>到服务器。</li><li>服务器回复<code>SYN-ACK</code>。</li><li>客户端发送<code>ACK</code>确认。 这个过程体现了同步的重要性。</li></ul></li><li><strong>滑动窗口协议</strong>：在TCP中，滑动窗口机制用于控制数据发送和接收的顺序，确保数据按正确顺序到达。</li><li><strong>超时重传</strong>：如果发送方未收到确认（ACK），会在超时后重传数据，确保数据的可靠传输。</li></ul></li></ul><h3 id="4-OSI模型中数据链路层具有拥塞控制功能吗？"><a href="#4-OSI模型中数据链路层具有拥塞控制功能吗？" class="headerlink" title="4.OSI模型中数据链路层具有拥塞控制功能吗？"></a>4.OSI模型中数据链路层具有拥塞控制功能吗？</h3><p>答：不具有。</p><p>数据链路层在不可靠的物理介质上提供可靠的传输，作用包括：</p><ul><li><strong>物理寻址</strong>：以太网MAC地址；WIFI（802.11）的MAC地址</li><li>组帧：Ethernet v2；802.3</li><li>流量控制：滑动窗口</li><li>差错检验：奇偶检验码、CRC码、海明码</li><li>数据重发：停止等待、后退N帧、选择重传</li></ul><h3 id="5-说明以下功能分别是那一层的？"><a href="#5-说明以下功能分别是那一层的？" class="headerlink" title="5.说明以下功能分别是那一层的？"></a>5.说明以下功能分别是那一层的？</h3><ul><li>提供用户和网络接口（应用层）</li><li>处理信号通过介质的传输（物理层）</li><li>控制报文通过网络的路由选择（网络层）</li><li>保证数据正确的顺序和完整性（数据链路层）</li></ul><h3 id="6-端到端？点对点？检查点、同步点？"><a href="#6-端到端？点对点？检查点、同步点？" class="headerlink" title="6.端到端？点对点？检查点、同步点？"></a>6.端到端？点对点？检查点、同步点？</h3><ul><li>端到端（传输层）</li><li>点对点（数据链路层）</li><li>检查点、同步点（会话层）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物理层问题补充</title>
      <link href="/2025/03/09/%E7%89%A9%E7%90%86%E5%B1%82%E9%97%AE%E9%A2%98%E8%A1%A5%E5%85%85/"/>
      <url>/2025/03/09/%E7%89%A9%E7%90%86%E5%B1%82%E9%97%AE%E9%A2%98%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-通信基础"><a href="#2-1-通信基础" class="headerlink" title="2.1 通信基础"></a>2.1 通信基础</h2><h3 id="1-计算机内部的数据传输是什么传输？"><a href="#1-计算机内部的数据传输是什么传输？" class="headerlink" title="1.计算机内部的数据传输是什么传输？"></a>1.计算机内部的数据传输是什么传输？</h3><p>计算机内部的数据传输通常采用<strong>并行传输</strong>方式。并行传输是指数据的多个位同时通过多条传输线路进行传输，这种方式能够显著提高数据传输速度。例如，CPU与内存之间的数据传输就是通过总线进行的，常见的数据总线宽度有8位、16位、32位和64位等。</p><p><strong>串行传输与并行传输</strong></p><ul><li><strong>串行传输</strong>：数据按位依次传输，只需一条传输信道。该方式节省线路和设备，适合远程传输，广泛应用于通信网和计算机网络中。</li><li><strong>并行传输</strong>：数据在多条信道上同时传输，传输速率高，但需要多条传输线路，成本较高，通常用于短距离传输，如计算机内部的总线传输。</li></ul><p><strong>单工、半双工与全双工通信</strong></p><ul><li><strong>单工通信</strong>：数据只能单向传输。例如无线广播。</li><li><strong>半双工通信</strong>：数据可以双向传输，但不能同时进行。例如对讲机。</li><li><strong>全双工通信</strong>：数据可以同时双向传输。例如电话通信。</li></ul><p><strong>同步传输与异步传输</strong></p><ul><li><strong>同步传输</strong>：数据以稳定的比特流传输，字节之间没有间隔，要求收发双方的时钟同步。</li><li><strong>异步传输</strong>：以字节为单位传输，字节之间时间间隔不固定，每个字节前后有起始位和结束位。</li></ul><p><strong>基带传输、频带传输与数字数据传输</strong></p><ul><li><strong>基带传输</strong>：基带信号直接在信道上传输，不进行频谱搬移。</li><li><strong>频带传输</strong>：基带信号经过调制后传输，适用于模拟信号。</li><li><strong>数字数据传输</strong>：利用PCM（脉冲编码调制）信道传输数据信号。</li></ul><p><strong>其他传输方式</strong></p><ul><li><strong>光纤传输</strong>：利用光通信技术，传输速度快，但成本较高。</li><li><strong>无线传输</strong>：方便灵活，但受传输距离和干扰限制。</li></ul><h3 id="2-曼彻斯特编码的叙述正确的是？说明原因"><a href="#2-曼彻斯特编码的叙述正确的是？说明原因" class="headerlink" title="2.曼彻斯特编码的叙述正确的是？说明原因"></a>2.曼彻斯特编码的叙述正确的是？说明原因</h3><ol><li>每个信号的起始边界作为时钟信号有利于信号同步（X）<strong>中间的跳变作为时钟信号。</strong></li><li>将时钟信号和数据取值包含在信号中（√）<strong>码元的和中间跳变作为时钟信号；不同的跳变方式“上0下1”作为数据信号。</strong></li><li>适合传输模拟数据（X）<strong>具体来说应该是二进制数据。</strong></li></ol><h3 id="3-使用曼彻斯特编码作为数据通信的主要原因是："><a href="#3-使用曼彻斯特编码作为数据通信的主要原因是：" class="headerlink" title="3.使用曼彻斯特编码作为数据通信的主要原因是："></a>3.使用曼彻斯特编码作为数据通信的主要原因是：</h3><p>答：实现对通信过程中收发双方的数据同步。（跳变表示bit，双发根据跳变来同步时钟，不需要额外时钟信号）</p><h3 id="4-不含同步信息的编码"><a href="#4-不含同步信息的编码" class="headerlink" title="4.不含同步信息的编码"></a>4.不含同步信息的编码</h3><p>非零编码NR不包括同步信息（因为各个码元之间没有间隔标志，他的同步信息由时钟线来同步）</p><h3 id="5-采样率带宽之间有什么关系？"><a href="#5-采样率带宽之间有什么关系？" class="headerlink" title="5.采样率带宽之间有什么关系？"></a>5.采样率带宽之间有什么关系？</h3><p>采样率&gt;&#x3D;2*带宽(Hz)</p><p>别忘了带宽如果以Hz为单位的话，它的定义是带宽的频率，就是那高带宽-低带宽。</p><h3 id="6-香农定理的局限性"><a href="#6-香农定理的局限性" class="headerlink" title="6.香农定理的局限性"></a>6.香农定理的局限性</h3><p>如果告诉你这个是二进制信号，那在使用香农定理的时候还要计算奈氏准则（限制了码元可以携带bit位数），取两者的最小值。</p><h2 id="2-2-传输介质"><a href="#2-2-传输介质" class="headerlink" title="2.2 传输介质"></a>2.2 传输介质</h2><p>传输介质可以分为</p><ul><li>导向传输介质：电磁波沿固体介质传播。</li><li>非导向传输介质：沿自由空间传播。</li></ul><h3 id="1-双绞线"><a href="#1-双绞线" class="headerlink" title="1.双绞线"></a>1.双绞线</h3><h4 id="绞合的作用？"><a href="#绞合的作用？" class="headerlink" title="绞合的作用？"></a>绞合的作用？</h4><p>减少电磁干扰。</p><h4 id="如何进一步提高电磁干扰能力？"><a href="#如何进一步提高电磁干扰能力？" class="headerlink" title="如何进一步提高电磁干扰能力？"></a>如何进一步提高电磁干扰能力？</h4><p>在双绞线外面加上一层屏蔽层：</p><ul><li>屏蔽双绞线（STP）</li><li>非屏蔽双绞线（UTP）</li></ul><h4 id="双绞线带宽取决于什么？"><a href="#双绞线带宽取决于什么？" class="headerlink" title="双绞线带宽取决于什么？"></a>双绞线带宽取决于什么？</h4><p>双绞线的带宽取决于铜线的粗细和传输的距离。</p><ul><li>距离太远。<ul><li>对于模拟信号要使用放大器。</li><li>对于数字信号使用中继器进行整形。</li></ul></li></ul><h3 id="2-同轴电缆"><a href="#2-同轴电缆" class="headerlink" title="2.同轴电缆"></a>2.同轴电缆</h3><h4 id="同轴电缆组成？"><a href="#同轴电缆组成？" class="headerlink" title="同轴电缆组成？"></a>同轴电缆组成？</h4><p>由内导体、绝缘层、外导体屏蔽层和绝缘保护套层构成。</p><h4 id="同轴电缆为什么比双绞线传输速率更快？"><a href="#同轴电缆为什么比双绞线传输速率更快？" class="headerlink" title="同轴电缆为什么比双绞线传输速率更快？"></a>同轴电缆为什么比双绞线传输速率更快？</h4><p>同轴电缆具有更高的屏蔽性，同时具有更高的抗噪声性。</p><h3 id="3-光纤"><a href="#3-光纤" class="headerlink" title="3.光纤"></a>3.光纤</h3><h4 id="光纤的组成？"><a href="#光纤的组成？" class="headerlink" title="光纤的组成？"></a>光纤的组成？</h4><p>由纤芯和包层构成。</p><h4 id="光纤利用光的什么特性？"><a href="#光纤利用光的什么特性？" class="headerlink" title="光纤利用光的什么特性？"></a>光纤利用光的什么特性？</h4><p>全反射特性。</p><h4 id="光纤的特点？"><a href="#光纤的特点？" class="headerlink" title="光纤的特点？"></a>光纤的特点？</h4><ul><li>传输损耗小，中继距离长，远距离传输经济。</li><li>抗雷电和电磁干扰性能好。</li><li>无串音干扰，保密性好，不易被窃听。</li><li>体积小重量轻。</li></ul><h3 id="2-2-2-物理层接口的特性"><a href="#2-2-2-物理层接口的特性" class="headerlink" title="2.2.2 物理层接口的特性"></a>2.2.2 物理层接口的特性</h3><ul><li>机械特性：接口所用接线器的<strong>形状与尺寸</strong>、<strong>引脚****数量和排列</strong>、<strong>固定和锁定装置</strong>等</li><li>电气特性：某接口电缆在各条线上的<strong>电压范围</strong>、纯属速率和距离限制等。</li><li>功能特性：某条线上某一电平的<strong>电压意义</strong>。</li><li>过程特性：也成为规律特性，置不同功能的各种可能时间当出现顺序</li></ul><p>举个例子，信号电平用10V到15V表示二进制0是——电气特性；但是11V表示二进制0就是功能特性。</p><h2 id="2-3-物理层设备"><a href="#2-3-物理层设备" class="headerlink" title="2.3 物理层设备"></a>2.3 物理层设备</h2><h3 id="2-3-1-中继器"><a href="#2-3-1-中继器" class="headerlink" title="2.3.1 中继器"></a>2.3.1 中继器</h3><h4 id="中继器功能"><a href="#中继器功能" class="headerlink" title="中继器功能"></a>中继器功能</h4><p>放大、整形并转发信号。消除信号经过一长段电缆后产生的失真和衰减。</p><p><strong>注意其是信号再生，而不是简单的放大信号！</strong></p><h4 id="中继器不可以无限串联"><a href="#中继器不可以无限串联" class="headerlink" title="中继器不可以无限串联"></a>中继器不可以无限串联</h4><p>根据10BASE5以太网规范中，遵循5-4-3原则：互相串联的中继器的个数不超过4个，且其串联起来的5段通信介质中只有3段可以挂载计算机。</p><h4 id="中继器与放大器的区别？"><a href="#中继器与放大器的区别？" class="headerlink" title="中继器与放大器的区别？"></a>中继器与放大器的区别？</h4><p>中继器（Repeater）是一种用于<strong>放大和再生****数字信号</strong>的设备，主要用于在长距离传输中保持信号的完整性和强度。中继器通过接收信号、放大信号并重新发送信号来克服信号衰减和噪声的影响，但它只适用于数字信号，因为数字信号可以被精确地重建。</p><p>对于<strong>模拟信号</strong>，通常使用<strong>放大器<strong><strong>（</strong></strong>Amplifier****）</strong>来放大信号。放大器会增强模拟信号的幅度，但<strong>同时也会放大信号中的噪声和失真</strong>。与中继器不同，放大器不会对信号进行重建，而是直接增强信号的强度。</p><p>总结：</p><ul><li><strong>中继器</strong>：用于放大和再生<strong>数字信号</strong>。</li><li><strong>放大器</strong>：用于放大<strong>模拟信号</strong>，但不会重建信号。</li></ul><h3 id="2-3-2-集线器"><a href="#2-3-2-集线器" class="headerlink" title="2.3.2 集线器"></a>2.3.2 集线器</h3><h4 id="什么是集线器"><a href="#什么是集线器" class="headerlink" title="什么是集线器"></a>什么是集线器</h4><p>集线器本质上是一个多端口的中继器。</p><p>总结一下：中继器通常只有2个端口，而集线器通常由四个或更多。</p><h4 id="集线器与中继器所在的层？"><a href="#集线器与中继器所在的层？" class="headerlink" title="集线器与中继器所在的层？"></a>集线器与中继器所在的层？</h4><p>都是物理层。</p><h4 id="集线器与冲突域和广播域"><a href="#集线器与冲突域和广播域" class="headerlink" title="集线器与冲突域和广播域"></a>集线器与冲突域和广播域</h4><p>集线器连接的工作站集合同属于一个冲突域和一个广播域。</p><h4 id="集线器可以连接两个怎样的局域网？"><a href="#集线器可以连接两个怎样的局域网？" class="headerlink" title="集线器可以连接两个怎样的局域网？"></a>集线器可以连接两个怎样的局域网？</h4><p>集线器可以连接两个不同介质的局域网。如一个是双绞线，另一个是光纤。</p><p><strong>但是不能连接两个速率不同，或者是协议不同的局域网。</strong></p><ul><li>速率不同，数据包可能会因为速率不匹配而发生冲突或丢失。</li><li>不同协议可能使用不同的信号编码方式（如曼彻斯特编码、NRZ编码等）。即使集线器将信号传递到目标设备，目标设备也可能无法正确解码这些信号。</li></ul><h4 id="五台机器连接10Mb-s的集线器上，每台计算机分的的平均带宽至多为多少？"><a href="#五台机器连接10Mb-s的集线器上，每台计算机分的的平均带宽至多为多少？" class="headerlink" title="五台机器连接10Mb&#x2F;s的集线器上，每台计算机分的的平均带宽至多为多少？"></a>五台机器连接10Mb&#x2F;s的集线器上，每台计算机分的的平均带宽至多为多少？</h4><p>由于集线器是通过广播的形式发送信号的，所以要平分，也就是10Mb&#x2F;s&#x2F;5 &#x3D; 2Mb&#x2F;s。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 计算机系统概述习题补充</title>
      <link href="/2025/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E4%B9%A0%E9%A2%98%E8%A1%A5%E5%85%85/"/>
      <url>/2025/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E4%B9%A0%E9%A2%98%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h1><h2 id="1-1-操作系统的基本概念"><a href="#1-1-操作系统的基本概念" class="headerlink" title="1.1 操作系统的基本概念"></a>1.1 操作系统的基本概念</h2><h3 id="操作系统是对什么管理的软件？"><a href="#操作系统是对什么管理的软件？" class="headerlink" title="操作系统是对什么管理的软件？"></a>操作系统是对什么管理的软件？</h3><p>操作系统是对<strong>计算机资源</strong> 管理的软件</p><ul><li>计算机资源包括软件和硬件</li></ul><h3 id="操作系统提供给编程人员的接口是？"><a href="#操作系统提供给编程人员的接口是？" class="headerlink" title="操作系统提供给编程人员的接口是？"></a>操作系统提供给编程人员的接口是？</h3><p><strong>系统调用。</strong></p><p>这里复习一下：操作系统作为用户和计算机硬件系统之间的接口，一共提供两种接口</p><ul><li><p>命令接口（命令行）</p><ul><li><p>联机命令接口（交互式命令接口）如命令行</p></li><li><p>脱机命令接口（批处理命令接口）如windows中光电bat</p></li></ul></li><li><p>程序接口（GUI）：由一组系统调用（广义指令组成。GUI就是通过调用程序接口实现的）</p></li></ul><h3 id="系统调用和库函数关联？"><a href="#系统调用和库函数关联？" class="headerlink" title="系统调用和库函数关联？"></a>系统调用和库函数关联？</h3><p>库函数位于用户控件；系统调用位于内核空间，库函数使用系统调用。</p><p>有的库函数会提供系统调用。如mmap之类的。</p><h2 id="1-2-操作系统发展历程"><a href="#1-2-操作系统发展历程" class="headerlink" title="1.2 操作系统发展历程"></a>1.2 操作系统发展历程</h2><h3 id="1-2-1-手工操作阶段（无操作系统）"><a href="#1-2-1-手工操作阶段（无操作系统）" class="headerlink" title="1.2.1 手工操作阶段（无操作系统）"></a>1.2.1 手工操作阶段（无操作系统）</h3><p>计算机所有的工作都需要人工干预，如装入、运行、输出等。</p><p>缺点：</p><ul><li><p>用户独占全机，不会出现资源被其他用户占用而等待（因为独占，只能运行一个），但是资源利用率低。</p></li><li><p>CPU等待手工操作，CPU利用不充分</p></li></ul><h3 id="1-2-2-批处理阶段（操作系统出现）"><a href="#1-2-2-批处理阶段（操作系统出现）" class="headerlink" title="1.2.2 批处理阶段（操作系统出现）"></a>1.2.2 批处理阶段（操作系统出现）</h3><ol><li><p>单道批处理</p><p>将一批作业机脱机的方式输入磁带，并使用系统中的Mointor控制使得这批作业可以一个接一个地连续处理。</p><p>特点：</p><ul><li><p>自动性。mointor监督逐个运行</p></li><li><p>顺序性。fcfs</p></li><li><p>单道性。内存中只有一道程序运行。</p></li></ul><p>由弹道性可知单道批处理会造成“高速的cpu和低速的IO”。因此为了提升IO的效率，设计了躲到批处理。</p></li><li><p>多道批处理</p></li></ol><p>所有的作业首先在外存上排成一个队列，作业调度在按照一定的算法从后备队列中选择若干作业调入程序。</p><p>在管理程序安排下交替运行。</p><p><strong>特点：宏观上并行、微观上串行。</strong></p><p>可见，要实现多道批处理系统需要解决以下问题：</p><p>优点：</p><p>缺点：</p><h3 id="1-2-3-分时操作系统"><a href="#1-2-3-分时操作系统" class="headerlink" title="1.2.3 分时操作系统"></a>1.2.3 分时操作系统</h3><p>分时操作系统是一种允许多个用户通过终端同时使用计算机资源的操作系统。它的核心特点是通过<strong>时间片轮转</strong>的方式，将处理器时间分配给多个用户或任务，从而实现多用户共享系统资源的目标。</p><p>特点：</p><p>虽然分时操作系统较好的解决了人机交互问题，但是有些时候要求做出反映的时间要比时间片更短。——实时操作系统。</p><h3 id="1-2-4-实时操作系统"><a href="#1-2-4-实时操作系统" class="headerlink" title="1.2.4 实时操作系统"></a>1.2.4 实时操作系统</h3><h3 id="实时操作系统的主要追求目标是什么？"><a href="#实时操作系统的主要追求目标是什么？" class="headerlink" title="实时操作系统的主要追求目标是什么？"></a>实时操作系统的主要追求目标是什么？</h3><p>实时操作系统的主要追求目标是：</p><ul><li><p><strong>实时性</strong>：确保任务在规定的时间内完成。</p></li><li><p><strong>可靠性</strong>：保证系统在关键任务中的稳定性和安全性。</p></li></ul><p>资源利用率并不是实时操作系统的主要目标，因为实时操作系统可能会通过任务抢占和资源预留来保证实时性和可靠性，这可能导致资源利用率的降低。</p><h3 id="作业的几种形式？"><a href="#作业的几种形式？" class="headerlink" title="作业的几种形式？"></a>作业的几种形式？</h3><p>作业的几种形式和操作系统的种类对应。</p><h3 id="多道程序技术的前提是系统具有？"><a href="#多道程序技术的前提是系统具有？" class="headerlink" title="多道程序技术的前提是系统具有？"></a>多道程序技术的前提是系统具有？</h3><p>中断功能。</p><p>多道城西技术要求进程间能实现并发，并发需要中断功能的支持。</p><h3 id="下列关于多道程序系统的叙述中，判断正确与否。"><a href="#下列关于多道程序系统的叙述中，判断正确与否。" class="headerlink" title="下列关于多道程序系统的叙述中，判断正确与否。"></a>下列关于多道程序系统的叙述中，判断正确与否。</h3><ol><li><p>支持进程的并发运行（√）</p></li><li><p>不必支持虚拟存储技术（√）</p></li><li><p>需要实现对共享资源的管理（√）</p></li><li><p>进程数越多CPU利用率越高（X）（因为进程越多，竞争越激烈，容易发生死锁。）</p></li></ol><p>其实这道题是用来判断操作系统的基本特点：并发、共享、虚拟、异步。（<strong>并发和共享是最基础的特征，两者相互依存</strong>）因此1和3是必须的，<strong>不用虚拟存储也可以实现，那么如何实现呢？</strong></p><h3 id="不用虚拟存储技术如何实现多道程序系统？（见第三章）"><a href="#不用虚拟存储技术如何实现多道程序系统？（见第三章）" class="headerlink" title="不用虚拟存储技术如何实现多道程序系统？（见第三章）"></a>不用虚拟存储技术如何实现多道程序系统？（见第三章）</h3><p>虚拟存储技术（如分页、分段）是为了解决内存管理问题（内存碎片、内存利用绿豆）而引入的，但多道程序系统可以通过以下方式实现内存管理，而无需虚拟存储技术：</p><ol><li><p><strong>固定分区</strong>：</p><ul><li><p>将内存划分为固定大小的分区，每个作业分配到适合的分区中。</p></li><li><p>优点是实现简单，缺点是可能造成内存浪费（内部碎片）。</p></li></ul></li><li><p><strong>动态分区</strong>：</p><ul><li><p>根据作业的大小动态分配内存。</p></li><li><p>优点是内存利用率高，缺点是可能产生外部碎片，需要定期进行内存整理（压缩）。</p></li></ul></li><li><p><strong>覆盖技术</strong>：</p><ul><li><p>将程序分为多个模块，只有当前需要的模块加载到内存中，其他模块存储在磁盘上，需要时再加载。</p></li><li><p>适用于内存有限的系统。</p></li></ul></li><li><p><strong>交换技术</strong>：</p><ul><li><p>将暂时不运行的作业从内存换出到磁盘，腾出内存空间给其他作业。</p></li><li><p>需要时再将作业从磁盘换入内存。</p></li></ul></li></ol><h2 id="1-3-操作系统的运行环境"><a href="#1-3-操作系统的运行环境" class="headerlink" title="1.3 操作系统的运行环境"></a>1.3 操作系统的运行环境</h2><h3 id="在内核态运行的特权指令有哪些？"><a href="#在内核态运行的特权指令有哪些？" class="headerlink" title="在内核态运行的特权指令有哪些？"></a>在内核态运行的特权指令有哪些？</h3><ul><li><p>直接管理系统资源的指令</p><ul><li><p>设置时钟</p></li><li><p>启动&#x2F;关闭硬件设备</p></li><li><p>切换进程</p></li><li><p>设置中断</p></li></ul></li><li><p>系统状态修改指令</p><ul><li><p>修改中断向量表</p></li><li><p>切换CPU的运行模式</p></li></ul></li><li><p>系统控制指令</p><ul><li><p>停机指令</p></li><li><p>重启指令</p></li></ul></li></ul><h3 id="在用户态运行的指令有哪些？"><a href="#在用户态运行的指令有哪些？" class="headerlink" title="在用户态运行的指令有哪些？"></a>在用户态运行的指令有哪些？</h3><ul><li><p>普通的数据处理指令</p><ul><li><p>算术运算</p></li><li><p>逻辑运算</p></li><li><p>数据移动</p></li></ul></li><li><p>流式控制指令</p><ul><li><p>跳转指令</p></li><li><p>函数调用指令</p></li><li><p>循环控制指令</p></li></ul></li><li><p>读操作指令</p><ul><li><p>内存读取指令</p></li><li><p>寄存器读取指令</p></li></ul></li></ul><p>&#x20;</p><h3 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h3><h3 id="发生中断的整体流程"><a href="#发生中断的整体流程" class="headerlink" title="发生中断的整体流程"></a>发生中断的整体流程</h3><ol><li><strong>中断触发（硬件操作）</strong></li></ol><ul><li><p><strong>事件发生</strong>：外设（如键盘、硬盘、网卡等）完成操作或需要CPU介入时，向CPU发送中断信号。此信号通过中断控制器（如APIC或8259A PIC）传送。</p></li><li><p><strong>硬件检测</strong>：CPU在每条指令执行完毕后，检查是否有未被屏蔽的中断请求，查看中断引脚的电平或中断控制器的状态。</p></li><li><p><strong>中断响应（硬件操作）</strong></p></li></ul><ul><li><p><strong>中断优先级判断</strong>：如果有多个中断请求，硬件中的中断控制器会根据中断的优先级选择最高优先级的中断。</p></li><li><p><strong>保存关键现场（硬件自动完成）</strong>：</p><ul><li><p>保存程序计数器（PC）的值，也就是下一条待执行指令的地址。</p></li><li><p>保存状态寄存器（如Flags&#x2F;PSW）的值，记录CPU的状态（如中断使能标志、溢出标志等）。</p></li></ul></li><li><p><strong>切换至内核态</strong>：CPU自动切换到内核模式（特权模式），并关闭中断（通过清除中断使能标志，以防止嵌套中断）。</p></li></ul><ul><li><strong>跳转到中断处理程序（硬件操作）</strong></li></ul><ul><li><p><strong>查询中断向量表</strong>：CPU根据中断类型（如IRQ编号），从中断向量表（IVT）或中断描述符表（IDT）中读取对应的中断服务例程（ISR）入口地址。</p></li><li><p><strong>跳转执行</strong>：CPU将控制权转移到ISR的入口地址，开始执行操作系统的中断处理程序。</p></li></ul><ul><li><strong>保存完整上下文（操作系统操作）</strong></li></ul><ul><li><p><strong>操作系统保存寄存器</strong>：在ISR中，操作系统需要保存当前进程的完整上下文（如通用寄存器、段寄存器等），以便中断处理完成后能够恢复程序执行。</p><ul><li>例如，在x86架构中，操作系统可能使用<code>pusha</code>指令保存所有通用寄存器。</li></ul></li><li><p><strong>区分内核态和用户态</strong>：如果中断发生时CPU处于用户态，操作系统需要切换栈（从用户栈切换到内核栈）。</p></li></ul><ul><li><strong>处理中断（操作系统操作）</strong></li></ul><ul><li><p><strong>调用设备驱动程序</strong>：操作系统根据中断类型，调用相应的设备驱动程序进行处理。</p><ul><li>例如，当网卡收到数据包后触发中断，操作系统会调用网卡驱动程序来读取数据，并将其放入接收队列中。</li></ul></li><li><p><strong>执行必要操作</strong>：操作系统执行相关操作，如读取设备数据、发送响应，或更新内核状态，通知其他进程中断处理已完成。</p></li></ul><ul><li><strong>中断结束通知（硬件+操作系统协作）</strong></li></ul><ul><li><p><strong>发送EOI（End of Interrupt）</strong>：操作系统向中断控制器发送EOI信号，通知中断已处理完成。</p><ul><li>在x86架构中，使用<code>out</code>指令向8259A PIC发送EOI。</li></ul></li><li><p><strong>重新启用中断</strong>：操作系统通过设置状态寄存器（如x86中的<code>sti</code>指令）重新启用中断，允许接收新的中断信号。</p></li></ul><ul><li><strong>恢复上下文（操作系统操作）</strong></li></ul><ul><li><p><strong>恢复寄存器</strong>：操作系统从栈中恢复之前保存的寄存器值（如通用寄存器、状态寄存器等）。</p></li><li><p><strong>切换回用户态</strong>：如果中断发生时CPU处于用户态，操作系统会切换回用户栈，并恢复用户态的权限。</p></li></ul><ul><li><strong>返回原程序（硬件操作）</strong></li></ul><ul><li><p><strong>执行中断返回指令</strong>：操作系统通过<code>iret</code>（x86架构）或类似指令，触发硬件操作，恢复程序计数器（PC）和状态寄存器（Flags），返回中断前的程序地址和状态。</p></li><li><p><strong>继续执行原程序</strong>：CPU从被中断的指令或下一条指令开始继续执行原程序。</p></li></ul><h3 id="发生异常中断的整体流程"><a href="#发生异常中断的整体流程" class="headerlink" title="发生异常中断的整体流程"></a>发生异常中断的整体流程</h3><p>异常（Exception）处理在操作系统中是一项重要机制，确保当程序出现异常时，系统能够有效地响应并进行处理。异常的处理流程与中断（Interrupt）类似，但由于异常是由程序内部执行中的同步事件触发，因此它需要特定的步骤来处理中断和恢复程序。下面是异常处理的整体流程，并详细区分硬件操作与操作系统操作：</p><ol><li><p><strong>故障（Fault）</strong>：</p><ul><li>这类异常是可修复的，比如页缺失异常。发生故障后，操作系统会处理并修复问题，然后重新执行触发异常的指令。</li></ul></li><li><p><strong>自陷（访管）（Trap）</strong>：</p><ul><li>这类异常通常用于调试或系统调用。处理后，程序会继续执行下一条指令。</li></ul></li></ol><ol start="3"><li><p><strong>终止（Abort）</strong>：</p><ul><li>这类异常表示严重错误，无法恢复，通常会直接终止进程。例如，硬件故障等。</li></ul></li></ol><p><strong>1. 异常触发（硬件操作）</strong></p><ul><li><p><strong>事件发生</strong>：CPU在执行指令时检测到异常条件。例如：</p><ul><li><p><strong>除零错误</strong>：除法指令的除数为零。</p></li><li><p><strong>页缺失</strong>：访问的虚拟地址没有映射到物理内存。</p></li><li><p><strong>非法指令</strong>：执行了未定义或非法的指令。</p></li></ul></li><li><p>异常是同步的，即由当前正在执行的指令直接引发。</p></li></ul><p><strong>2. 硬件响应（硬件操作）</strong></p><ul><li><p><strong>保存关键现场</strong>：</p><ul><li><p><strong>程序计数器（PC）</strong>：硬件会自动保存触发异常的指令地址，或者是下一条指令的地址，取决于异常类型。</p></li><li><p><strong>状态寄存器（Flags&#x2F;PSW）</strong>：保存当前的CPU状态，如中断使能标志和特权级别。</p></li></ul></li><li><p><strong>切换至内核态</strong>：CPU会自动切换到内核模式，并禁用中断以防止异常嵌套。</p></li><li><p><strong>生成错误码（可选）</strong>：对于部分异常（如页缺失），会生成错误码并保存到栈中，供操作系统进一步分析。</p></li></ul><p><strong>3. 跳转到异常处理程序（硬件操作）</strong></p><ul><li><p><strong>查询异常向量表</strong>：CPU根据异常类型（如除零、页缺失等）从异常向量表（如中断描述符表IDT）中查找对应的处理程序入口。</p><ul><li><p>例如，在x86架构中：</p><ul><li><p>除零异常对应向量号为0。</p></li><li><p>页缺失异常对应向量号为14。</p></li></ul></li></ul></li><li><p><strong>跳转执行</strong>：CPU将控制权转交给操作系统的异常处理程序，如 <code>divide_error</code> 或 <code>page_fault_handler</code>。</p></li></ul><p><strong>4. 保存完整上下文（操作系统操作）</strong></p><ul><li><p><strong>手动保存寄存器</strong>：操作系统会保存当前进程的通用寄存器、段寄存器等上下文信息，以便后续恢复。</p></li><li><p><strong>区分用户态和内核态</strong>：</p><ul><li><p>如果异常发生在用户态，操作系统需要切换栈（从用户栈切换到内核栈）。</p></li><li><p>如果异常发生在内核态，操作系统可能直接终止进程（如内核代码触发不可恢复的错误）。</p></li></ul></li></ul><p><strong>5. 处理异常（操作系统操作）</strong></p><ul><li><p><strong>分析异常原因</strong>：操作系统会读取错误码（如果有的话）并分析导致异常的指令地址。</p><ul><li>例如，在页缺失异常中，操作系统需要检查访问的虚拟地址和相应的权限（如读&#x2F;写&#x2F;执行）。</li></ul></li><li><p><strong>分类型处理</strong>：</p><ul><li><p><strong>故障（Fault）</strong>：</p><ul><li><p><strong>页缺失</strong>：操作系统会分配物理内存或从磁盘加载数据，修复页表后重新执行触发异常的指令。</p></li><li><p><strong>除零错误</strong>：操作系统可能向进程发送信号（如 <code>SIGFPE</code>），并终止进程。</p></li></ul></li><li><p><strong>陷阱（Trap）</strong>：</p><ul><li><strong>系统调用</strong>：系统调用通常通过 <code>int 0x80</code> 或 <code>syscall</code> 指令触发，处理后继续执行下一条指令。</li></ul></li><li><p><strong>终止（Abort）</strong>：</p><ul><li>操作系统会直接终止进程，记录错误日志，并可能触发内核崩溃（如内核遇到严重错误时）。</li></ul></li></ul></li></ul><p><strong>6. 恢复或终止（操作系统操作）</strong></p><ul><li><p><strong>可恢复异常（如页缺失）</strong>：</p><ul><li>操作系统恢复寄存器，并通过 <code>iret</code> 指令返回，继续执行触发异常的指令。</li></ul></li><li><p><strong>不可恢复异常（如非法指令）</strong>：</p><ul><li><p>操作系统向进程发送信号（如 <code>SIGSEGV</code>）终止进程，并释放相关资源。</p></li><li><p>如果异常发生在内核态，可能触发系统崩溃（例如 <code>Kernel Panic</code>）。</p></li></ul></li></ul><p><strong>7. 返回原程序或调度新进程（硬件与操作系统协作）</strong></p><ul><li><p><strong>执行返回指令</strong>：操作系统通过 <code>iret</code> 指令恢复硬件现场，从栈中弹出保存的程序计数器（PC）和状态寄存器。CPU恢复到用户态（如果需要）并重新开启中断。</p></li><li><p><strong>继续执行</strong>：</p><ul><li><p>如果异常已经修复（如页缺失），CPU会重新执行触发异常的指令。</p></li><li><p>如果进程被终止，操作系统会调度其他进程运行，确保系统稳定运行。</p></li></ul></li></ul><h3 id="系统调用与一般调用"><a href="#系统调用与一般调用" class="headerlink" title="系统调用与一般调用"></a>系统调用与一般调用</h3><p>补充：系统调用需要将CPU中的PSW和PC端值压栈，而一般调用不需要。</p><h3 id="处理外部中断的时候，判断以下哪些由硬件完成，哪些由操作系统完成"><a href="#处理外部中断的时候，判断以下哪些由硬件完成，哪些由操作系统完成" class="headerlink" title="处理外部中断的时候，判断以下哪些由硬件完成，哪些由操作系统完成"></a>处理外部中断的时候，判断以下哪些由硬件完成，哪些由操作系统完成</h3><p>PC的内容——硬件</p><p>TLB的内容——硬件</p><p>cache中的内容——硬件</p><p>置PSW状态字——硬件</p><p><strong>保存通用寄存器中的内容——操作系统</strong></p><p>提供中断服务——操作系统</p><p>保中断屏蔽字——操作系统</p><p>初始化中断向量表（操作系统初始化的时候就完成了）——操作系统</p><h3 id="硬件与操作系统的职责划分"><a href="#硬件与操作系统的职责划分" class="headerlink" title="硬件与操作系统的职责划分"></a><strong>硬件与操作系统的职责划分</strong></h3><p><strong>1. 硬件管理的资源</strong></p><p><strong>指令执行</strong>：CPU执行指令、计算、内存访问。</p><p><strong>中断处理</strong>：</p><p> 检测中断信号（如时钟中断、IO完成中断）。</p><p> 自动跳转到预设的中断处理程序入口（如x86的IDT表）。</p><p><strong>基本寄存器保存</strong>：</p><p> 在中断&#x2F;异常发生时，自动保存PC和PSW到内核栈。</p><p><strong>内存管理单元</strong>（<strong>MMU</strong>）：</p><p> 虚拟地址到物理地址的转换（页表遍历）。</p><p> TLB管理（部分架构由硬件自动填充）。</p><p><strong>缓存一致性</strong>：通过协议（如MESI）维护多核Cache一致性。</p><p><strong>2.</strong> <strong>操作系统管理的资源</strong></p><p><strong>进程上下文</strong>：</p><p> 保存&#x2F;恢复通用寄存器、堆栈指针、进程状态。</p><p> 管理进程控制块（PCB）。</p><p><strong>内存管理</strong>：</p><p> 分配&#x2F;回收物理内存，维护页表结构。</p><p> 处理缺页异常，触发TLB刷新。</p><p><strong>设备管理</strong>：</p><p> 提供设备驱动，控制IO操作（如磁盘读写）。</p><p> 处理DMA与内存的一致性（刷新Cache）。</p><p><strong>调度策略</strong>：</p><p> 决定进程切换的时机和目标（如时间片轮转、优先级调度）。</p><p><strong>3. 协同工作的典型案例</strong></p><p><strong>系统调用（Syscall）</strong>：</p><p> <strong>硬件</strong>：执行<code>syscall</code>指令，切换到内核态，保存用户态PC和PSW。</p><p> <strong>操作系统</strong>：保存用户态通用寄存器，执行系统调用处理函数，最后恢复寄存器并返回用户态。</p><p><strong>缺页异常</strong>：</p><p> <strong>硬件</strong>：触发缺页异常，保存当前PC和PSW。</p><p> <strong>操作系统</strong>：分配物理页，更新页表，刷新TLB，重新执行指令。</p><p><strong>硬件与操作系统的职责边界</strong></p><ul><li><strong>硬件</strong>：执行指令、处理中断、基础地址转换、维护缓存一致性。</li><li><strong>操作系统</strong>：管理进程上下文、内存分配、设备IO、调度策略。</li></ul><h2 id="1-4-1-5-操作系统结构与虚拟机"><a href="#1-4-1-5-操作系统结构与虚拟机" class="headerlink" title="1.4 +1.5 操作系统结构与虚拟机"></a>1.4 +1.5 操作系统结构与虚拟机</h2><h3 id="微内核特点"><a href="#微内核特点" class="headerlink" title="微内核特点"></a>微内核特点</h3><ul><li><p>扩展性与灵活性</p></li><li><p>可靠性与安全性</p></li><li><p>可移植性</p></li><li><p>分布式计算</p></li><li><p>内核足够小</p></li><li><p>基于C&#x2F;S模式</p></li><li><p>应用机制与策略分离的原理</p></li><li><p>采用面向对象技术</p></li></ul><h3 id="计算机开机流程"><a href="#计算机开机流程" class="headerlink" title="计算机开机流程"></a>计算机开机流程</h3><p><strong>1. CPU通电，执行第一条指令</strong></p><ul><li>**地址<code>FFFF0H</code>**：CPU通电后，会从固定地址<code>FFFF0H</code>（实模式下的复位向量）获取第一条指令。</li><li><strong>JMP指令</strong>：该地址通常存储一条<code>JMP</code>指令，跳转到BIOS的入口点（通常在<code>F0000H</code>附近）。</li></ul><p><strong>2. BIOS初始化</strong></p><ul><li><strong>中断向量表和服务程序</strong>：BIOS在内存的低地址空间（如<code>00000H</code>到<code>003FFH</code>）构建<strong>中断向量表（IVT）</strong>，并加载相应的中断服务程序。</li><li><strong>硬件初始化</strong>：BIOS初始化硬件设备（如键盘、显示器、内存、硬盘等）。</li><li><strong>POST（通电自检）</strong>：BIOS执行<strong>POST</strong>，检测硬件是否有故障。如果发现问题，会通过蜂鸣声或屏幕显示错误代码。</li></ul><p><strong>3. 查找启动设备</strong></p><ul><li><p><strong>启动顺序</strong>：BIOS按照配置的启动顺序（如硬盘、光驱、USB、网络）查找可启动设备。</p></li><li><p>MBR的加载：</p><ul><li>如果选择从硬盘启动，BIOS会读取硬盘的第一个扇区（512字节），即<strong>MBR（主引导记录）</strong>。</li><li>MBR中包含：<ul><li><strong>引导代码</strong>（446字节）：负责加载操作系统内核或下一级引导程序。</li><li><strong>分区表</strong>（64字节）：描述硬盘的分区信息。</li><li><strong>结束标志</strong>（2字节，<code>0x55AA</code>）：用于验证MBR的有效性。</li></ul></li></ul></li></ul><p><strong>4. MBR的执行</strong></p><ul><li><p><strong>引导代码</strong>：MBR中的引导代码被执行，其任务是查找<strong>活动分区</strong>（标记为可启动的分区）。</p></li><li><p>PBR的加载：</p><ul><li>找到活动分区后，MBR会读取该分区的第一个扇区，即<strong>PBR（分区引导记录）</strong>。</li><li>PBR中包含：<ul><li><strong>引导代码</strong>：负责加载操作系统的引导程序（如Windows的<code>NTLDR</code>或Linux的<code>GRUB</code>）。</li><li><strong>文件系统信息</strong>：用于定位操作系统内核。</li></ul></li></ul></li></ul><p><strong>5. 引导加载程序（Bootloader）</strong></p><ul><li><strong>GRUB（Linux）或NTLDR（Windows）</strong>：PBR中的引导代码加载更复杂的引导加载程序。</li><li><strong>加载操作系统内核</strong>：引导加载程序读取配置文件，定位操作系统内核文件（如<code>vmlinuz</code>或<code>ntoskrnl.exe</code>），并将其加载到内存中。</li></ul><p><strong>6. 操作系统内核初始化</strong></p><ul><li><strong>内核启动</strong>：操作系统内核接管控制权，初始化硬件、加载驱动程序、挂载文件系统。</li><li><strong>用户空间初始化</strong>：启动<code>init</code>进程（Linux）或<code>winlogon</code>进程（Windows），进入用户登录界面。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从美丽子集的数目看回溯的形式</title>
      <link href="/2025/03/07/%E4%BB%8E%E7%BE%8E%E4%B8%BD%E5%AD%90%E9%9B%86%E7%9A%84%E6%95%B0%E7%9B%AE%E7%9C%8B%E5%9B%9E%E6%BA%AF%E7%9A%84%E5%BD%A2%E5%BC%8F/"/>
      <url>/2025/03/07/%E4%BB%8E%E7%BE%8E%E4%B8%BD%E5%AD%90%E9%9B%86%E7%9A%84%E6%95%B0%E7%9B%AE%E7%9C%8B%E5%9B%9E%E6%BA%AF%E7%9A%84%E5%BD%A2%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="2597-美丽子集的数目"><a href="#2597-美丽子集的数目" class="headerlink" title="2597.美丽子集的数目"></a>2597.美丽子集的数目</h1><p>给你一个由正整数组成的数组 <code>nums</code> 和一个 <strong>正</strong> 整数 <code>k</code> 。</p><p>如果 <code>nums</code> 的子集中，任意两个整数的绝对差均不等于 <code>k</code> ，则认为该子数组是一个 <strong>美丽</strong> 子集。</p><p>返回数组 <code>nums</code> 中 <strong>非空</strong> 且 <strong>美丽</strong> 的子集数目。</p><p><code>nums</code> 的子集定义为：可以经由 <code>nums</code> 删除某些元素（也可能不删除）得到的一个数组。只有在删除元素时选择的索引不同的情况下，两个子集才会被视作是不同的子集。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,4,6], k = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：数组 nums 中的美丽子集有：[2], [4], [6], [2, 6] 。</span><br><span class="line">可以证明数组 [2,4,6] 中只存在 4 个美丽子集。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：数组 nums 中的美丽数组有：[1] 。</span><br><span class="line">可以证明数组 [1] 中只存在 1 个美丽子集。 </span><br></pre></td></tr></table></figure><h2 id="几种回溯思路与区别"><a href="#几种回溯思路与区别" class="headerlink" title="几种回溯思路与区别"></a>几种回溯思路与区别</h2><p>这道题可以用回溯或者动态规划的思路做，这里重要将回溯的思路。</p><p>首先是最基本的想法：</p><ul><li>首先用回溯生成所有的子数组。</li><li>然后两层循环遍历该数组并对所有的子数据计数。</li></ul><p>如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">beautifulSubsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 存储美丽子集的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有的子集</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; subsets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrack(nums, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), subsets);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每一个子集，检查是否满足美丽子集的条件</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; subset : subsets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isBeautiful(subset, k)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯法，生成所有的子集</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, List&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt; subsets)</span> &#123;</span><br><span class="line">        <span class="comment">// 添加当前的子集到结果中</span></span><br><span class="line">        <span class="keyword">if</span> (!current.isEmpty()) &#123;</span><br><span class="line">            subsets.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(current));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            current.add(nums[i]);</span><br><span class="line">            backtrack(nums, i + <span class="number">1</span>, current, subsets); <span class="comment">// 递归选择下一个元素</span></span><br><span class="line">            current.remove(current.size() - <span class="number">1</span>); <span class="comment">// 回溯，移除当前元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断给定的子集是否是美丽子集</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isBeautiful</span><span class="params">(List&lt;Integer&gt; subset, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; subset.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; subset.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(subset.get(i) - subset.get(j)) == k) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果找到一对绝对差为 k 的元素，返回 false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 满足条件是美丽子集</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点就是太复杂了。</p><p>所以想到将所有的判断合并在一个回溯当中。(每次选或不选)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">beautifulSubsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>, nums, k, cnt);</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>; <span class="comment">// 减去空集</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 初始化为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span>[] nums, <span class="type">int</span> k, Map&lt;Integer, Integer&gt; cnt)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">            ans++; <span class="comment">// 到达叶子节点时，子集数量增加</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不选择当前元素（直接判断下一个）</span></span><br><span class="line">        dfs(index + <span class="number">1</span>, nums, k, cnt);</span><br><span class="line">        <span class="comment">// 以下就是回溯部分（选择当前元素的情况）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择当前元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[index];</span><br><span class="line">        <span class="keyword">if</span> (cnt.getOrDefault(x - k, <span class="number">0</span>) == <span class="number">0</span> &amp;&amp; cnt.getOrDefault(x + k, <span class="number">0</span>) == <span class="number">0</span>) &#123; <span class="comment">// 可以选</span></span><br><span class="line">            cnt.put(x, cnt.getOrDefault(x, <span class="number">0</span>) + <span class="number">1</span>); <span class="comment">// 选，增加计数</span></span><br><span class="line">            dfs(index + <span class="number">1</span>, nums, k, cnt); <span class="comment">// 递归讨论下一个元素</span></span><br><span class="line">            cnt.put(x, cnt.get(x) - <span class="number">1</span>); <span class="comment">// 撤销选择，减少计数</span></span><br><span class="line">            <span class="keyword">if</span> (cnt.get(x) == <span class="number">0</span>) &#123; <span class="comment">// 如果计数减到 0，移除该键</span></span><br><span class="line">                cnt.remove(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看起来有点变扭，如果<code>dfs</code>内就要用for循环那应该怎么写？</p><p>比较以下两种写法</p><p>写法1（每次选哪一个）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">beautifulSubsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>, nums, k, cnt);</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>; <span class="comment">// 减去空集</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 初始化为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] nums, <span class="type">int</span> k, Map&lt;Integer, Integer&gt; cnt)</span> &#123;</span><br><span class="line">        ans++; <span class="comment">//每一个递归都是符合条件的，ans+1</span></span><br><span class="line">        <span class="keyword">if</span> (start == nums.length) &#123; </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">if</span> (cnt.getOrDefault(x - k, <span class="number">0</span>) == <span class="number">0</span> &amp;&amp; cnt.getOrDefault(x + k, <span class="number">0</span>) == <span class="number">0</span>) &#123; <span class="comment">// 可以选</span></span><br><span class="line">                cnt.put(x, cnt.getOrDefault(x, <span class="number">0</span>) + <span class="number">1</span>); <span class="comment">// 选，增加计数</span></span><br><span class="line">                dfs(i + <span class="number">1</span>, nums, k, cnt); <span class="comment">// 递归讨论下一个元素</span></span><br><span class="line">                cnt.put(x, cnt.get(x) - <span class="number">1</span>); <span class="comment">// 撤销选择，减少计数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法2（有多少个树枝）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">beautifulSubsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>, nums, k, cnt);</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>; <span class="comment">// 减去空集</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 初始化为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] nums, <span class="type">int</span> k, Map&lt;Integer, Integer&gt; cnt)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start == nums.length) &#123;</span><br><span class="line">            ans++; <span class="comment">// 到达叶子节点时，子集数量增加</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">if</span> (cnt.getOrDefault(x - k, <span class="number">0</span>) == <span class="number">0</span> &amp;&amp; cnt.getOrDefault(x + k, <span class="number">0</span>) == <span class="number">0</span>) &#123; <span class="comment">// 可以选</span></span><br><span class="line">                cnt.put(x, cnt.getOrDefault(x, <span class="number">0</span>) + <span class="number">1</span>); <span class="comment">// 选，增加计数</span></span><br><span class="line">                dfs(i + <span class="number">1</span>, nums, k, cnt); <span class="comment">// 递归讨论下一个元素</span></span><br><span class="line">                cnt.put(x, cnt.get(x) - <span class="number">1</span>); <span class="comment">// 撤销选择，减少计数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过当前元素，直接递归处理后面的元素</span></span><br><span class="line">        dfs(nums.length, nums, k, cnt);</span><br><span class="line">        <span class="comment">//一下接回溯部分（选择当前元素的情况）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察到两者的区别在于写法2将<code>ans++</code>放在一次<code>dfs</code>走到头的时候，并在结尾处多了一个<code>         dfs(nums.length, nums, k, cnt);</code>，相当于再加了一个回溯，前面是已经选择了的情况，<code>        dfs(nums.length, nums, k, cnt);</code>跳过，然后有回溯走最开始的情况（选择当前元素）。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.2 IPv4</title>
      <link href="/2025/03/07/4-2IPv4/"/>
      <url>/2025/03/07/4-2IPv4/</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h1><blockquote><p>了解：4.1</p><p>重点 4.2,4.4,4,7</p><p>快速学习：4.5.4.6.4.3（不用死磕概念，做课后小题即可）</p></blockquote><h2 id="4-1-网络层的功能"><a href="#4-1-网络层的功能" class="headerlink" title="4.1 网络层的功能"></a>4.1 网络层的功能</h2><p><img src="/2025/03/07/4-2IPv4/image-12.png"></p><ul><li><p>异构网络互联</p><ul><li><p>物理层&amp;链路层实现不同——802.11,以太网，令牌环网。</p></li><li><p>主机类型不同，如以太网连电脑；802.11无线以太网连手机或者电脑。</p></li><li><p>TCP&#x2F;IP中，路由器又称为“网关”。</p></li></ul></li><li><p>路由与转发</p><ul><li><p>路由是各个路由之间的相互配合；而转发指的是单个路由器。</p></li><li><p>路由需要运行各自的“路由协议”，生成各自的“路由表”。</p></li><li><p>转发表&#x3D;精简的路由表。</p></li></ul></li><li><p>拥塞控制方法</p><ul><li><p>开环控制（静态方法）：在部署网络之前就做好预防拥塞的方法。</p></li><li><p>闭环控制（动态方法）：动态监视网路状态，通过<strong>ICMP协议</strong>专递给相关路由器，相应路由器调整路由表。</p></li></ul></li></ul><h2 id="4-2-IPV4"><a href="#4-2-IPV4" class="headerlink" title="4.2 IPV4"></a>4.2 IPV4</h2><p>IP——Internet protocol version 4</p><h3 id="4-2-1-IPV4分组（重要）"><a href="#4-2-1-IPV4分组（重要）" class="headerlink" title="4.2.1 IPV4分组（重要）"></a>4.2.1 IPV4分组（重要）</h3><p><img src="/2025/03/07/4-2IPv4/image-13.png"></p><p>考试的时候会给出参考图，所以具体的长度占多少为不用刻意记忆。但是要记住几个和长度相关的单位。</p><p><strong>口诀：”418首总偏“——首部长度、总长度、片偏移的单位分别为4B、1B、8B</strong></p><ul><li><p>版本：占4bit，指的是IP的版本</p></li><li><p>首部长度：占4bit。以4B为单位，所以最大可以表示(2^4-1)*4B &#x3D; 60B的长度。</p><ul><li>其中固定部分的长度占20B，剩下的40B是可变长度。</li></ul></li><li><p>分区服务（一般用不到）</p></li><li><p>总长度：占16bit。指的是首部长度加上后面的数据部分的长度</p><ul><li><p><strong>数据链路层帧（这里用以太网帧为例）的最大长度MTU是1500B</strong>（见上一张中的MAC帧的格式），所以总长度（首部加数据部分）不能超过数据链路层的MTU值。</p></li><li><p>如果总长度超过了总长度，那么就要进行IP数据报的分片。</p></li></ul></li><li><p>标识：占16bit。对于上面所说的，在数据报传输的过程当中有可能“分片”，为了让接收方知道他们原来属于哪一个ip数据报，标识相同，说明属于同一个数据包。</p></li><li><p>标志（Flag）：3bit，最低为MF(More Fragment)、DF(Don’t Fragment)、最高位不用管。</p><ul><li><p>MF为1表示后面还有分片，0则相反。</p></li><li><p>DF为1表示不允许被分片，0则相反。</p></li></ul></li><li><p>片偏移：13bit，以8B为范围，所以每个分片的长度也必须是以8B的整数倍（<strong>除了最后一个分片</strong>，以为他后面不用再设置一个数据分片以8B为单位的片偏移字段）。</p></li></ul><p><strong>关于标识、标志、总长度分片、片偏移的例子可以看下面这张图：</strong></p><p><img src="/2025/03/07/4-2IPv4/image-11.png"></p><ul><li><p>生存时间（TTL）：8bit。数据报可以在网络中通过的路由器的最大值，路由器转发前会将TTL-1</p><ul><li>注意：如果TTL减到0，就直接丢弃分组报文，并向原主机<strong>发送ICMP报文</strong>。（这是因为ICMP协议和TTL都是在网络层的）。</li></ul></li><li><p>协议：占8bit，如6表示TCP，17表示UDP。</p></li><li><p>首部校验和：16bit</p><ul><li><p>注意：每个路由器仅校验ip报文的首部而不校验数据部分。</p></li><li><p>如果该字段全为0，表示不用校验。</p></li><li><p>校验码类似于CRC、奇偶等，具体的UDP处解释。</p></li></ul></li></ul><h4 id="“分片”注意要点"><a href="#“分片”注意要点" class="headerlink" title="“分片”注意要点"></a>“分片”注意要点</h4><p><img src="/2025/03/07/4-2IPv4/image-14.png"></p><h3 id="4-2-2-IPV4地址与整章串讲"><a href="#4-2-2-IPV4地址与整章串讲" class="headerlink" title="4.2.2 IPV4地址与整章串讲"></a>4.2.2 IPV4地址与整章串讲</h3><h4 id="IPV4地址演化"><a href="#IPV4地址演化" class="headerlink" title="IPV4地址演化"></a>IPV4地址演化</h4><p><img src="/2025/03/07/4-2IPv4/image-7.png"></p><h4 id="最初的IP地址分类方案"><a href="#最初的IP地址分类方案" class="headerlink" title="最初的IP地址分类方案"></a>最初的IP地址分类方案</h4><p><img src="/2025/03/07/4-2IPv4/image-9.png"></p><ul><li><p>单播地址：分配个每一个主机。</p></li><li><p>多播地址：多播地址的主要作用是为多播通信保留地址空间，使得数据包能够被发送到一组特定的主机，而不是单个主机或所有主机。多播地址是一种虚拟组地址，用于标识一组应该接收相同数据包的主机。</p></li></ul><h4 id="数据包如何从源主机发送到目标主机的过程（重要）"><a href="#数据包如何从源主机发送到目标主机的过程（重要）" class="headerlink" title="数据包如何从源主机发送到目标主机的过程（重要）"></a>数据包如何从源主机发送到目标主机的过程（重要）</h4><p><img src="/2025/03/07/4-2IPv4/image-10.png"></p><p>假设我要发送一个ip数据包，当他封装成MAC帧的时候会通过ARP协议找到网关的MAC地址，然后分装成MAC帧发送给路由器。然后路由器在自己的路由转发表中查找对应的<strong>网络号</strong>以及并通过相应的转发接口转发出去。</p><ul><li><p>如果找不到的话，一般会发送给ISP，然后再在网络中的路由器逐个转发。</p></li><li><p>如果找得到，比如说图中的某公司这个路由器，那他就转给某公司的路由器。该路由器发现该数据报和自己的路由转发表中有一个网络号可以匹配，就先用ARP协议在该转发接口中获取最后要发送的目的主机的MAC地址，最后转成MAC地址发送完毕。</p></li><li><p>如果在发送的时候就发现源地址和目的地址的网络号相同，就没必要先发送给网关，直接用ARP查询到目的地址的MAC地址。</p></li></ul><p>图中所写的“H1~H6”需要配置“默认网关”指的是图中的某学校的路由器。</p><h4 id="一些特殊的IP地址"><a href="#一些特殊的IP地址" class="headerlink" title="一些特殊的IP地址"></a>一些特殊的IP地址</h4><p><img src="/2025/03/07/4-2IPv4/image-3.png"></p><p><strong>可以这样记忆：0表示“本”；1表示“所有！”</strong></p><ul><li><p>主机号全为0。只存在于路由转发表当中，用于表示整个网络（网络号）</p></li><li><p>主机号全1。向网络号为Y的地址广播IP数据包，如目的网络号是200.1.1.0，那么想广播到该网络中的所有主机可以将目的地址置为200.1.1.255</p></li><li><p>网络号为0，主机号非零。表示分组的源地址中主机号为Y的主机。</p></li><li><p>网络号全零，目的地址全1。当主机通过DHCP获得ip地址之前它的地址是0.0.0.0。</p></li><li><p>网络号全1，主机号全1。向本网络广播ip分组。如目的地址设置为255.255.255.255，广播发送该主机所在的网络。</p></li><li><p>网络号127开头，主机号非全0或全1的任何数。是环回自检地址，不会发送到网络中，而是发送到网络层然后自己介绍，用于测试。</p></li></ul><h3 id="4-2-3-子网划分与子网掩码"><a href="#4-2-3-子网划分与子网掩码" class="headerlink" title="4.2.3 子网划分与子网掩码"></a>4.2.3 子网划分与子网掩码</h3><p><img src="/2025/03/07/4-2IPv4/image-5.png"></p><h4 id="为什么要进行子网划分？"><a href="#为什么要进行子网划分？" class="headerlink" title="为什么要进行子网划分？"></a>为什么要进行子网划分？</h4><p>进行子网划分的主要目的是<strong>更有效地管理和利用IP地址资源</strong>，具体原因包括以下几点：</p><ol><li><p><strong>提高IP地址利用率</strong>：<br>将一个大的IP地址块划分为多个较小的子网，可以避免IP地址的浪费。例如，一个单位可能不需要使用整个IP地址块，通过子网划分可以分配更合适的地址范围。</p></li><li><p><strong>优化网络性能</strong>：<br>子网划分可以减少广播域的范围，降低网络中的广播流量，从而提高网络性能，减少拥塞。</p></li><li><p><strong>增强网络安全性</strong>：<br>通过子网划分，可以将不同的部门或功能区域隔离在不同的子网中，限制不必要的通信，提高网络的安全性。</p></li><li><p><strong>简化网络管理</strong>：<br>子网划分使网络结构更加清晰，便于管理员对不同的子网进行独立管理和维护，例如分配IP地址、配置路由策略等。</p></li><li><p><strong>支持网络扩展</strong>：<br>子网划分为网络的扩展提供了灵活性，可以根据需求增加新的子网，而不会影响现有网络的结构。</p></li></ol><p><img src="/2025/03/07/4-2IPv4/image-4.png"></p><p><strong>原理</strong>：若某单位租用了一个IP，假设原本主机号占n bit，那么可以将前k bit抠出来作为子网号，用剩余的n-k bit作为主机号，这样就能划分出2^k个子网（每个子网包含的IP地址块大小相等）。</p><p><strong>子网划分前</strong>，IP地址为两级结构：&lt;网络号，主机号&gt;<br><strong>子网划分后</strong>，IP地址为三级结构：&lt;网络号，子网号，主机号&gt;</p><p><strong>注意</strong>：每个子网地址中，主机号不能分配为全0&#x2F;全1——全0表示子网本身，全1为子网广播地址。</p><h4 id="子网掩码的作用？"><a href="#子网掩码的作用？" class="headerlink" title="子网掩码的作用？"></a>子网掩码的作用？</h4><p>想一个问题：<strong>划分子网之后如何判断是否属于一个子网？</strong></p><p>需要子网掩码，因为多了一个子网号，如何像之前单单比较网络号（如你是C类地址就比较前24位，这显然不能将子网掩码也包括在内）</p><p>子网掩码将网络号和子网号所在的位置置为1，主机号置为0。</p><p><img src="/2025/03/07/4-2IPv4/image-6.png"></p><p><img src="/2025/03/07/4-2IPv4/image-8.png"></p><p>如图所示，此时要将子网掩码和目的IP按位与在比较是否能找到目的网络号。</p><h5 id="图中默认子网掩码是什么？"><a href="#图中默认子网掩码是什么？" class="headerlink" title="图中默认子网掩码是什么？"></a>图中默认子网掩码是什么？</h5><p>如果没有进行子网划分，可以给他配置默认子网掩码。</p><ul><li><p><strong>A类地址</strong>：255.0.0.0</p></li><li><p><strong>B类地址</strong>：255.255.0.0</p></li><li><p><strong>C类地址</strong>：255.255.255.0</p></li><li><p><strong>D类和E类地址</strong>：无默认子网掩码</p></li></ul><h5 id="图中的默认路由是什么？"><a href="#图中的默认路由是什么？" class="headerlink" title="图中的默认路由是什么？"></a>图中的默认路由是什么？</h5><p>加上H1给互联网上的IP主机发送信息。</p><p>发送的时候会发现默认网关路由转发表中一项都对不上，会走默认路由（由于全0，一定匹配的上），然后走对应的接口，如发送给ISP路由，然后在跳转。</p><h4 id="主机发送IPP数据报的过程（重要）"><a href="#主机发送IPP数据报的过程（重要）" class="headerlink" title="主机发送IPP数据报的过程（重要）"></a>主机发送IPP数据报的过程（重要）</h4><p><img src="/2025/03/07/4-2IPv4/image-1.png"></p><h4 id="路由器转发一个IP数据报的过程（重要）"><a href="#路由器转发一个IP数据报的过程（重要）" class="headerlink" title="路由器转发一个IP数据报的过程（重要）"></a>路由器转发一个IP数据报的过程（重要）</h4><p><img src="/2025/03/07/4-2IPv4/image-2.png"></p><p>注意这里的最后一句话，如果分装成了广播帧，则不用往回发送，直接丢弃即可。</p><h3 id="4-2-4-无分类编址-CIDR"><a href="#4-2-4-无分类编址-CIDR" class="headerlink" title="4.2.4 无分类编址 CIDR"></a>4.2.4 无分类编址 CIDR</h3><p><img src="/2025/03/07/4-2IPv4/image.png"></p><p>如果基于传统的ip地址分类方法，一旦超过C类地址能容纳的主机数，就要选择B类地址，造成大量的浪费。</p><h4 id="无分类编址划分方法"><a href="#无分类编址划分方法" class="headerlink" title="无分类编址划分方法"></a>无分类编址划分方法</h4><p><img src="/2025/03/07/4-2IPv4/image-29.png"></p><h5 id="定长子网划分"><a href="#定长子网划分" class="headerlink" title="定长子网划分"></a>定长子网划分</h5><p>直接将主机号中选出固定的位数表示网络号</p><h5 id="变长子网划分"><a href="#变长子网划分" class="headerlink" title="变长子网划分"></a>变长子网划分</h5><p><img src="/2025/03/07/4-2IPv4/image-28.png"></p><p>例题：</p><p><img src="/2025/03/07/4-2IPv4/image-26.png"></p><h3 id="4-2-5-路由聚合"><a href="#4-2-5-路由聚合" class="headerlink" title="4.2.5 路由聚合"></a>4.2.5 路由聚合</h3><p><img src="/2025/03/07/4-2IPv4/image-23.png"></p><p>如图，路由聚合是转发接口xiangtong，且部分网络前缀也相同的表项聚合。</p><p>因此，路由聚合可以减少路由表的大小。</p><p>但是，可能会引入额外的无效地址：</p><ul><li>比如我有一个子网号为0，但是为1的子网号还没有分配。但是由于路由聚合也能成功匹配，导致它也转发了过去。</li></ul><h4 id="最长前缀匹配原则"><a href="#最长前缀匹配原则" class="headerlink" title="最长前缀匹配原则"></a>最长前缀匹配原则</h4><p><img src="/2025/03/07/4-2IPv4/image-27.png"></p><h3 id="4-6-2-网络地址转换-NAT"><a href="#4-6-2-网络地址转换-NAT" class="headerlink" title="4.6.2 网络地址转换 NAT"></a>4.6.2 网络地址转换 NAT</h3><p>让一个局域网内部的多态主机共享一个全球唯一的IP地址</p><p><img src="/2025/03/07/4-2IPv4/image-25.png"></p><h4 id="NAT的数据包发送过程（重要）"><a href="#NAT的数据包发送过程（重要）" class="headerlink" title="NAT的数据包发送过程（重要）"></a>NAT的数据包发送过程（重要）</h4><p><img src="/2025/03/07/4-2IPv4/image-21.png"></p><p><strong>训练一：手机1 → 手机2 微信发文字</strong></p><p><strong>场景类型</strong>：跨局域网通信（NAT穿透） <strong>核心原理</strong>：</p><ol><li><strong>内网到外网的地址转换</strong>：<ol><li>手机1（内网IP <code>192.168.3.48</code>）通过微信发送文字消息，数据包经过 <strong>NAT****路由器</strong>（网关）。</li><li>NAT路由器查表，将手机1的 <strong>内网**<strong>IP</strong></strong>:**<strong>端口</strong>（<code>192.168.3.48:9855</code>）转换为 <strong>外网IP:端口</strong>（<code>59.175.49.153:8877</code>）。</li></ol></li><li><strong>跨网络传输</strong>：<ol><li>转换后的数据包通过公网（Internet）传输到手机2的默认网关。</li><li>手机2的NAT路由器转换成私有地址，然后分装成MAC帧，发送。</li></ol></li></ol><p><strong>训练三：电脑 → 服务器 请求网页数据</strong></p><p><strong>场景类型</strong>：客户端-服务器请求（HTTP&#x2F;TCP） <strong>核心原理</strong>：</p><ol><li><strong>HTTP请求****发起</strong>：<ol><li>电脑发送的时候类似训练1的地址转换和发送过程。</li></ol></li><li>服务器接受：<ol><li>服务器没有使用NAT路由，直接通过目的ip以及端口号确定web服务器进程。</li></ol></li></ol><h4 id="NAT关键点"><a href="#NAT关键点" class="headerlink" title="NAT关键点"></a>NAT关键点</h4><p><img src="/2025/03/07/4-2IPv4/image-24.png"></p><ul><li>NAT路由器还要涉及到传输层，因为要修改端口号。</li></ul><h3 id="4-2-7-ARP协议"><a href="#4-2-7-ARP协议" class="headerlink" title="4.2.7 ARP协议"></a>4.2.7 ARP协议</h3><p><img src="/2025/03/07/4-2IPv4/image-20.png"></p><p>注意这里设置请求分组和相应分组是通过设置MAC帧的形式实现的，而不是设置目的ip地址。</p><h4 id="ARP分组放入MAC帧需要填充"><a href="#ARP分组放入MAC帧需要填充" class="headerlink" title="ARP分组放入MAC帧需要填充"></a>ARP分组放入MAC帧需要填充</h4><p>ARP分组大小只有28B，N最小为46。</p><p><img src="/2025/03/07/4-2IPv4/image-18.png"></p><h3 id="4-2-8-动态主机配置协议-DHCP"><a href="#4-2-8-动态主机配置协议-DHCP" class="headerlink" title="4.2.8 动态主机配置协议 DHCP"></a>4.2.8 动态主机配置协议 DHCP</h3><p><img src="/2025/03/07/4-2IPv4/image-19.png"></p><p>首先看到DHCP是应用层之间的协议。</p><h4 id="DHCP服务器"><a href="#DHCP服务器" class="headerlink" title="DHCP服务器"></a>DHCP服务器</h4><p><img src="/2025/03/07/4-2IPv4/image-22.png"></p><p>对每一个子网提供一个DHCP服务器，每一个DHCP服务器只能给该子网下的主机分配IP地址池内部的地址。</p><p><img src="/2025/03/07/4-2IPv4/image-16.png"></p><h4 id="主机向DHCP服务器请求ip地址的过程"><a href="#主机向DHCP服务器请求ip地址的过程" class="headerlink" title="主机向DHCP服务器请求ip地址的过程"></a>主机向DHCP服务器请求ip地址的过程</h4><p><img src="/2025/03/07/4-2IPv4/image-15.png"></p><h5 id="Discover"><a href="#Discover" class="headerlink" title="Discover"></a>Discover</h5><p>注意画圈部分，本质上是两个进程之间的通信——DHCP的客户端和服务端。</p><p><img src="/2025/03/07/4-2IPv4/image-17.png"></p><p>分装过程如下：DHCP是应用层的协议，逐层向下封装。</p><p><img src="/2025/03/07/4-2IPv4/image-34.png"></p><ul><li><p>目的ip全为1，为广播地址，因为第一次他不知道发给谁。</p></li><li><p>目的MAC地址48bit全为1，同样也是广播地址。</p></li></ul><p>注意，由于是广播协议，该网络中所有的主机都为接受带这个DHCP请求报文（discover），但是唯独只有DHCP的服务端金层67端口可以接受。这是因为67这个端口号是专用的。</p><h5 id="Offer"><a href="#Offer" class="headerlink" title="Offer"></a>Offer</h5><p><img src="/2025/03/07/4-2IPv4/image-37.png"></p><ul><li><p>目的ip地址还是广播，因为还没分配完成。</p></li><li><p>目的MAC地址已经可以更新成成之前discover发送时的源mac地址了。</p></li></ul><h5 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h5><p><img src="/2025/03/07/4-2IPv4/image-35.png"></p><ul><li><p><strong>注意这里的目的ip地址和目的MAC地址还是广播， 没有更新！！！</strong></p><ul><li>因为可能有很多DHCP服务器，都会给同一个新节点分配一个offer报文，所以该新节点必须通过广播的形式告诉所有的DHCP服务器自己接受的是哪一个DHCP的offer。</li></ul></li></ul><h5 id="Acknowledge"><a href="#Acknowledge" class="headerlink" title="Acknowledge"></a>Acknowledge</h5><p><img src="/2025/03/07/4-2IPv4/image-33.png"></p><p>acknowledge报文和第二次发送的offer报文相同。</p><h4 id="DHCP总结（重要）"><a href="#DHCP总结（重要）" class="headerlink" title="DHCP总结（重要）"></a>DHCP总结（重要）</h4><p><img src="/2025/03/07/4-2IPv4/image-36.png"></p><h3 id="本章问题"><a href="#本章问题" class="headerlink" title="本章问题"></a>本章问题</h3><h4 id="IPV4地址划分的顺序"><a href="#IPV4地址划分的顺序" class="headerlink" title="IPV4地址划分的顺序"></a>IPV4地址划分的顺序</h4><p><img src="/2025/03/07/4-2IPv4/image-31.png"></p><h4 id="ARP协议是那一层的协议？"><a href="#ARP协议是那一层的协议？" class="headerlink" title="ARP协议是那一层的协议？"></a>ARP协议是那一层的协议？</h4><p>ARP协议（地址解析协议）在网络分层模型中的位置存在不同的解释，具体取决于使用的是OSI模型还是TCP&#x2F;IP模型。</p><ul><li><p><strong>在OSI模型中</strong>，ARP协议通常被认为是<strong>数据链路层（第二层）​</strong>的协议，因为它主要负责将网络层的IP地址解析为数据链路层的MAC地址，以便在局域网中进行数据传输。</p></li><li><p><strong>在TCP&#x2F;IP模型中</strong>，ARP协议则被归类为<strong>网络层（第三层）​</strong>的协议，因为它与IP地址的解析密切相关，尽管它的功能涉及数据链路层的MAC地址</p></li></ul><p>因此，ARP协议可以看作是<strong>介于数据链路层和网络层之间</strong>的协议，具体归属取决于所使用的网络模型。</p><h4 id="特殊的MAC地址"><a href="#特殊的MAC地址" class="headerlink" title="特殊的MAC地址"></a>特殊的MAC地址</h4><p><img src="/2025/03/07/4-2IPv4/image-32.png"></p><h4 id="各个协议之间的关系（重要）"><a href="#各个协议之间的关系（重要）" class="headerlink" title="各个协议之间的关系（重要）"></a>各个协议之间的关系（重要）</h4><p><img src="/2025/03/07/4-2IPv4/image-30.png"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣每日一题（破坏回文串）</title>
      <link href="/2025/03/05/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%88%E7%A0%B4%E5%9D%8F%E5%9B%9E%E6%96%87%E4%B8%B2%EF%BC%89/"/>
      <url>/2025/03/05/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%88%E7%A0%B4%E5%9D%8F%E5%9B%9E%E6%96%87%E4%B8%B2%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="1328-破坏回文串-有意思"><a href="#1328-破坏回文串-有意思" class="headerlink" title="1328.破坏回文串(有意思)"></a>1328.破坏回文串(有意思)</h2><p>贪心的算法很好想到，但是要注意三个细节</p><ul><li>如果只有一个字符那就返回“”</li><li>如果字符全由a组成，将最后一位变为b</li><li>如果是奇数长度的字符串，他的中间的字符无论怎么改，他永远都是回文的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">breakPalindrome</span><span class="params">(String palindrome)</span> &#123;</span><br><span class="line">        <span class="comment">// 贪心，将最前的大于a的字符调成a</span></span><br><span class="line">        <span class="comment">// 如果字符串长度为1，不能破坏回文，直接返回 &quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (palindrome.length() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] str = palindrome.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 贪心：从左往右遍历字符，找到第一个不是 &#x27;a&#x27; 的字符，将其替换为 &#x27;a&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            <span class="comment">//如果正好是长度为奇数的字符串，对于他中间的数不能改，因为改了还是回文字符串。</span></span><br><span class="line">            <span class="keyword">if</span> (str.length % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; i == str.length / <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[i] != <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">                str[i] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(str); <span class="comment">// 直接返回修改后的字符串</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果字符串是全 &#x27;a&#x27;，返回除去最后一个字符的字符串</span></span><br><span class="line">        str[str.length - <span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>; <span class="comment">// 改变最后一个字符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="33-搜索螺旋排序数组"><a href="#33-搜索螺旋排序数组" class="headerlink" title="33.搜索螺旋排序数组"></a>33.搜索螺旋排序数组</h2><p>一开始的思路是先二分查到分割点。，然后再分别二分两个区间，写的有些冗余了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public <span class="type">int</span> <span class="keyword">search</span>(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span> 首先二分找到那个旋转点，再分别二分</span><br><span class="line">        <span class="type">int</span> <span class="keyword">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="keyword">right</span> <span class="operator">=</span> nums.length <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line">        while (<span class="keyword">left</span> <span class="operator">&lt;</span> <span class="keyword">right</span>) &#123;</span><br><span class="line">            <span class="type">int</span> mid <span class="operator">=</span> <span class="keyword">left</span> <span class="operator">+</span> (<span class="keyword">right</span> <span class="operator">-</span> <span class="keyword">left</span>) <span class="operator">/</span> <span class="number">2</span>;</span><br><span class="line">            if (nums[mid] <span class="operator">&gt;</span> nums[<span class="keyword">right</span>]) &#123;</span><br><span class="line">                <span class="operator">/</span><span class="operator">/</span> 如果中间元素大于右端，说明旋转点在右半部分</span><br><span class="line">                <span class="keyword">left</span> <span class="operator">=</span> mid <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="operator">/</span><span class="operator">/</span> 如果中间元素小于等于右端，说明旋转点在左半部分</span><br><span class="line">                <span class="keyword">right</span> <span class="operator">=</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index <span class="operator">=</span> <span class="keyword">left</span>;</span><br><span class="line">        if (target <span class="operator">&gt;=</span> nums[index] <span class="operator">&amp;&amp;</span> target <span class="operator">&lt;=</span> nums[nums.length <span class="operator">-</span> <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> bsearch(nums, index, nums.length <span class="operator">-</span> <span class="number">1</span>, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> if (target <span class="operator">&gt;=</span> nums[<span class="number">0</span>] <span class="operator">&amp;&amp;</span> index <span class="operator">&gt;=</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> target <span class="operator">&lt;=</span> nums[index <span class="operator">-</span> <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> bsearch(nums, <span class="number">0</span>, index <span class="operator">-</span> <span class="number">1</span>, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="type">int</span> bsearch(<span class="type">int</span>[] nums, <span class="type">int</span> <span class="keyword">left</span>, <span class="type">int</span> <span class="keyword">right</span>, <span class="type">int</span> target) &#123;</span><br><span class="line">        while (<span class="keyword">left</span> <span class="operator">&lt;=</span> <span class="keyword">right</span>) &#123;</span><br><span class="line">            <span class="type">int</span> mid <span class="operator">=</span> <span class="keyword">left</span> <span class="operator">+</span> (<span class="keyword">right</span> <span class="operator">-</span> <span class="keyword">left</span>) <span class="operator">/</span> <span class="number">2</span>;</span><br><span class="line">            if (nums[mid] <span class="operator">&gt;</span> target) &#123;</span><br><span class="line">                <span class="keyword">right</span> <span class="operator">=</span> mid <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> if (nums[mid] <span class="operator">&lt;</span> target) &#123;</span><br><span class="line">                <span class="keyword">left</span> <span class="operator">=</span> mid <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>付一个官方题解,看起来更加清爽。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class="number">1</span>]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="81-搜索螺旋排序数组2"><a href="#81-搜索螺旋排序数组2" class="headerlink" title="81.搜索螺旋排序数组2"></a>81.搜索螺旋排序数组2</h2><p>这一题和上一题的区别在于该数组是非递减数组，有可能有相同的值。在遇到相同的值的时候我们无法使用上一题中的官方解法通过<code>nums[0] &lt;= nums[mid]</code>来判断是否在左区间或者是右区间内，所以采用以下写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[left] == nums[mid] &amp;&amp; nums[mid] == nums[right]) &#123;</span><br><span class="line">               ++left;</span><br><span class="line">               --right;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>即对于每次二分都通过left和right来判断，如图相等则内缩（注意前面先判断了是否相等，所以这里不存在相等的情况）。</p><p>注意<code>nums[left] &lt;= target</code>也要修改，将0替换为left。而<code>target &lt;= nums[len - 1]</code>不用修改是因为右侧不会因为相同的值产生分组的问题。当然你改成<code>target &lt;= nums[right]</code>也没问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    public boolean search(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">len</span> = nums.length;</span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> right = <span class="built_in">len</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="built_in">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> true;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> (nums[left] == nums[mid] &amp;&amp; nums[mid] == nums[right]) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            // 在一个区间内</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; nums[mid] &gt; target) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 在另一个区间内</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &lt;= nums[<span class="built_in">len</span> - <span class="number">1</span>] &amp;&amp; nums[mid] &lt; target) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1299-将每个元素替换为右侧最大元素（有意思）"><a href="#1299-将每个元素替换为右侧最大元素（有意思）" class="headerlink" title="1299.将每个元素替换为右侧最大元素（有意思）"></a>1299.将每个元素替换为右侧最大元素（有意思）</h2><p>思路其实很清楚。但是要注意要提前存tmp值否则会被覆盖掉，这里贴一下我最初始的版本，但是肉眼看出来没有任何问题，实际上就是每次取了刚刚被覆盖掉的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    public <span class="built_in">int</span>[] replaceElements(<span class="built_in">int</span>[] arr) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = arr.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            //这里取得都是上次被arr[i]=<span class="built_in">max</span>覆盖掉的值</span><br><span class="line">            <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, arr[i + <span class="number">1</span>]);</span><br><span class="line">            arr[i] = <span class="built_in">max</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] replaceElements(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[arr.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            max = Math.max(max, tmp);</span><br><span class="line">            tmp = arr[i];</span><br><span class="line">            arr[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣每日一题（分割回文串）</title>
      <link href="/2025/03/04/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>/2025/03/04/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="131-分割回文串1"><a href="#131-分割回文串1" class="headerlink" title="131.分割回文串1"></a>131.分割回文串1</h2><p>观察到s的长度小于等于16，使用回溯不会超时。</p><p>方法1：动态规划+回溯</p><p>首先用<code>dp[i][j]</code>表示下标从i到j的字符串是否是回文数组，再用回溯储存结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[][] dp;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        len = s.length();</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="comment">// 初始化单个字符为回文串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 动态规划填充 dp[i][j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i == <span class="number">1</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        backTrace(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrace</span><span class="params">(String s, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == len) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> index; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[index][j]) &#123;</span><br><span class="line">                tmp.add(s.substring(index, j + <span class="number">1</span>));</span><br><span class="line">                backTrace(s, j + <span class="number">1</span>);</span><br><span class="line">                tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：纯回溯</p><p>直接在回溯中判断是否是回文串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        backtrack(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(String s, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == s.length()) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s, index, i)) &#123;</span><br><span class="line">                path.add(s.substring(index, i + <span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            backtrack(s, i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(start) != s.charAt(end))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="132-分割回文串2"><a href="#132-分割回文串2" class="headerlink" title="132.分割回文串2"></a>132.分割回文串2</h2><p>和分割回文串1有很大关联。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCut</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// dp[i][j]判断[i,j]是否是回文串</span></span><br><span class="line">        <span class="comment">// 之所以要定义二维是经验之谈，因为如果dp[i][j]为ture且s[i+1]==s[j-1],那么一个新的回文串就判断出来了。</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>; <span class="comment">// 单个字符是回文串</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意这里的循环（相比于上一题换了一种遍历方式，这里不推荐），由于我们的i和j含义是[i,j]的子串，所以最外层的循环限制子串的长度，让他从小到大，符合dp[i + 1][j -1]代表的子串从小到大</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">2</span>; length &lt;= len; length++) &#123; <span class="comment">// 长度从 2 到 len</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= len - length; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + length - <span class="number">1</span>;<span class="comment">// j代表子串的右端</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    <span class="comment">// length == 2处理边界情况，防止出现dp[i][j]中i&gt;j的情况</span></span><br><span class="line">                    <span class="keyword">if</span> (length == <span class="number">2</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] cuts = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[<span class="number">0</span>][i])</span><br><span class="line">                cuts[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cuts[i] = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[j + <span class="number">1</span>][i])</span><br><span class="line">                        cuts[i] = Math.min(cuts[i], cuts[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cuts[len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1278-分割回文串3"><a href="#1278-分割回文串3" class="headerlink" title="1278.分割回文串3"></a>1278.分割回文串3</h2><p>上一个问题是两个动态规划相结合，这题也是。要先用编辑距离的思想求出对于某一区间的字符串变成回文串的最小编辑次数，然后就得到递推公式就方便了——<code>dp[i][j] = Math.min(dp[i][j], dp[t][j - 1] + cost[t + 1][i]);</code></p><p><strong>问题描述</strong></p><p>给定一个由小写字母组成的字符串 <code>s</code> 和一个整数 <code>k</code>，要求：</p><ol><li>可以修改 <code>s</code> 中的部分字符为其他小写字母。</li><li>将 <code>s</code> 分割成 <code>k</code> 个非空且不相交的子串，且每个子串都是回文串。</li><li>返回满足上述条件所需修改的最少字符数。</li></ol><p><strong>思路</strong></p><p>这个问题可以拆解为两个部分：</p><ol><li><p><strong>计算将任意子串变成回文串的最小修改次数</strong>。</p></li><li><p><strong>在字符串中寻找</strong> <code>k</code> <strong>个分割点，使得总修改次数最小</strong>。</p></li><li><p><strong>计算将子串变成回文串的最小修改次数</strong></p></li></ol><p>定义一个二维数组 <code>cost[i][j]</code>，表示将子串 <code>s[i...j]</code> 变成回文串所需的最小修改次数。计算 <code>cost[i][j]</code> 的方法：</p><ul><li>如果 <code>s[i] == s[j]</code>，则 <code>cost[i][j] = cost[i+1][j-1]</code>（不需要修改）。</li><li>如果 <code>s[i] != s[j]</code>，则 <code>cost[i][j] = cost[i+1][j-1] + 1</code>（需要修改其中一个字符）。</li></ul><ol><li><strong>动态规划寻找最佳分割点</strong></li></ol><p>定义一个二维数组 <code>dp[i][j]</code>，表示将字符串 <code>s[0...i]</code> 分割成 <code>j</code> 个回文子串所需的最小修改次数。状态转移方程：</p><ul><li>如果 <code>j == 1</code>，则 <code>dp[i][1] = cost[0][i]</code>（整个字符串作为一个回文子串）。</li><li>如果 <code>j &gt; 1</code>，则遍历所有可能的分割点 <code>t</code>，并更新 <code>dp[i][j] = min(dp[i][j], dp[t][j-1] + cost[t+1][i])</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">palindromePartition</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 计算 cost[i][j]</span></span><br><span class="line">        <span class="type">int</span>[][] cost = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">1</span>; length &lt;= n; length++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - length; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">                    cost[i][j] = <span class="number">0</span>; <span class="comment">// 单个字符已经是回文串</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                        cost[i][j] = cost[i + <span class="number">1</span>][j - <span class="number">1</span>]; <span class="comment">// 不需要修改</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cost[i][j] = cost[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>; <span class="comment">// 需要修改一个字符</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 动态规划计算 dp[i][j]</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                dp[i][j] = Integer.MAX_VALUE; <span class="comment">// 初始化为最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化 j = 1 的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = cost[<span class="number">0</span>][i]; <span class="comment">// 将 s[0...i] 作为一个回文子串</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算 j &gt; 1 的情况</span></span><br><span class="line">        <span class="comment">// j循环在外侧不能换，因为对于dp[t][j - 1]遍历到i的时候j可能还没有初始化，所以j要放最外层。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; t &lt; i; t++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[t][j - <span class="number">1</span>] != Integer.MAX_VALUE) &#123; <span class="comment">// 确保 t 是一个有效的分割点</span></span><br><span class="line">                        dp[i][j] = Math.min(dp[i][j], dp[t][j - <span class="number">1</span>] + cost[t + <span class="number">1</span>][i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.1 内存管理概念</title>
      <link href="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/"/>
      <url>/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="内存基础知识"><a href="#内存基础知识" class="headerlink" title="内存基础知识"></a>内存基础知识</h2><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-14.png"></p><h3 id="三种链接方式（重要）"><a href="#三种链接方式（重要）" class="headerlink" title="三种链接方式（重要）"></a>三种链接方式（重要）</h3><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-9.png"></p><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-12.png"></p><h4 id="装入时动态链接"><a href="#装入时动态链接" class="headerlink" title="装入时动态链接"></a>装入时动态链接</h4><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-13.png"></p><h4 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h4><p>他和装入时动态链接的区别是只有在用需要的模块的时候才会装入内存进行链接。而装入时动态链接不管是否使用，直接放入内存进行链接。</p><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-11.png"></p><h3 id="三种装入方式（重要）"><a href="#三种装入方式（重要）" class="headerlink" title="三种装入方式（重要）"></a>三种装入方式（重要）</h3><p>装入方式是为了解决如何将地址中的逻辑地址转化为物理地址。</p><h4 id="绝对装入"><a href="#绝对装入" class="headerlink" title="绝对装入"></a>绝对装入</h4><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-8.png"></p><h4 id="静态重定位装入（可重定位装入）"><a href="#静态重定位装入（可重定位装入）" class="headerlink" title="静态重定位装入（可重定位装入）"></a>静态重定位装入（可重定位装入）</h4><p>早期的多道批处理程序，装入时重定向。</p><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-5.png"></p><p>可以图中右侧分配的内存空间必须是连续的，且在运行期间不能再移动。</p><h4 id="动态运行时装入（动态运行时装入）"><a href="#动态运行时装入（动态运行时装入）" class="headerlink" title="动态运行时装入（动态运行时装入）"></a>动态运行时装入（动态运行时装入）</h4><p>现在的段式存储和页式存储使用的就是动态运行时装入。</p><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-7.png"></p><h2 id="3-1-内存管理概念"><a href="#3-1-内存管理概念" class="headerlink" title="3.1 内存管理概念"></a>3.1 内存管理概念</h2><h3 id="3-1-1-内存管理的基本原理与要求"><a href="#3-1-1-内存管理的基本原理与要求" class="headerlink" title="3.1.1 内存管理的基本原理与要求"></a>3.1.1 内存管理的基本原理与要求</h3><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-10.png"></p><ul><li><p>内存空间的分配与回收</p></li><li><p>地址转换</p></li><li><p>内存空间的扩充：虚拟存储技术（如何装入一个大小超过内存的大程序）</p></li><li><p>内存共享</p></li><li><p>内存保护</p></li></ul><h3 id="3-1-2-连续分配管理方式（重要）"><a href="#3-1-2-连续分配管理方式（重要）" class="headerlink" title="3.1.2 连续分配管理方式（重要）"></a>3.1.2 连续分配管理方式（重要）</h3><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-4.png"></p><h4 id="1-单一连续分配"><a href="#1-单一连续分配" class="headerlink" title="1.单一连续分配"></a>1.单一连续分配</h4><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-3.png"></p><p>用户区内仅有一道用户程序，即用户程序独占整个用户区。</p><p>优点：</p><ul><li><p>简单，无外部碎片（因为所有的用户区都分配给了一个用户程序）</p></li><li><p>无序进行内存保护，因为只有一道程序</p></li></ul><p>缺点</p><ul><li><p>内部碎片</p></li><li><p>内存利用率低</p></li></ul><h4 id="2-固定分区分配"><a href="#2-固定分区分配" class="headerlink" title="2.固定分区分配"></a>2.固定分区分配</h4><p>多道程序的存储管理方式，内存空间划分为固定大小的分区。</p><p><strong>注意，固定不代表分区大小一定相等！</strong>&#x20;</p><ul><li><p>分区大小相等：程序太小会造成浪费；太大无法存入。</p></li><li><p>分区大小不等：具有灵活性。</p></li></ul><p>如何实现——建立一张分区使用表：</p><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-6.png"></p><h4 id="3-动态分区分配"><a href="#3-动态分区分配" class="headerlink" title="3.动态分区分配"></a>3.动态分区分配</h4><p>不会像固定内存区域一样实现划分内存分区，而是在进程装入内存的时候根据进程的大小动态简历分区。</p><h5 id="动态分区分配使用什么数据结构？"><a href="#动态分区分配使用什么数据结构？" class="headerlink" title="动态分区分配使用什么数据结构？"></a><strong>动态分区分配使用什么数据结构？</strong></h5><ul><li><p>空闲分区表</p></li><li><p>空闲分区链</p></li></ul><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-2.png"></p><h5 id="动态分区如何进行分配与回收？"><a href="#动态分区如何进行分配与回收？" class="headerlink" title="动态分区如何进行分配与回收？"></a><strong>动态分区如何进行分配与回收？</strong></h5><p>分成4种情况（本质上就是合并相邻的空闲区）</p><ol><li><p><strong>回收区之后有相邻的空闲分区</strong></p><ul><li><p><strong>描述</strong>：回收的内存分区后面紧接着一个空闲分区。</p></li><li><p><strong>处理方式</strong>：将回收区与后面的空闲分区合并，形成一个更大的空闲分区。</p></li><li><p><strong>优点</strong>：减少内存碎片，提高内存利用率。</p></li><li><p><strong>示例</strong>：</p><ul><li><p>回收区地址：1000-2000</p></li><li><p>空闲分区地址：2000-3000</p></li><li><p>合并后空闲分区：1000-3000</p></li></ul></li></ul></li><li><p><strong>回收区之前有相邻的空闲分区</strong></p><ul><li><p><strong>描述</strong>：回收的内存分区前面紧接着一个空闲分区。</p></li><li><p><strong>处理方式</strong>：将回收区与前面的空闲分区合并，形成一个更大的空闲分区。</p></li><li><p><strong>优点</strong>：减少内存碎片，提高内存利用率。</p></li><li><p><strong>示例</strong>：</p><ul><li><p>空闲分区地址：500-1000</p></li><li><p>回收区地址：1000-2000</p></li><li><p>合并后空闲分区：500-2000</p></li></ul></li></ul></li><li><p><strong>回收区前、后都有相邻的空闲分区</strong></p><ul><li><p><strong>描述</strong>：回收的内存分区前后都有相邻的空闲分区。</p></li><li><p><strong>处理方式</strong>：将回收区与前后两个空闲分区合并，形成一个更大的空闲分区。</p></li><li><p><strong>优点</strong>：最大限度地减少内存碎片，提高内存利用率。</p></li><li><p><strong>示例</strong>：</p><ul><li><p>空闲分区地址：500-1000</p></li><li><p>回收区地址：1000-2000</p></li><li><p>空闲分区地址：2000-3000</p></li><li><p>合并后空闲分区：500-3000</p></li></ul></li></ul></li><li><p><strong>回收区前、后都没有相邻的空闲分区</strong></p><ul><li><p><strong>描述</strong>：回收的内存分区前后都没有相邻的空闲分区。</p></li><li><p><strong>处理方式</strong>：将回收区单独标记为空闲分区，不进行合并。</p></li><li><p><strong>优点</strong>：简单直接，适用于孤立的内存分区。</p></li><li><p><strong>示例</strong>：</p><ul><li><p>回收区地址：1000-2000</p></li><li><p>空闲分区地址：500-1000（不相邻）</p></li><li><p>空闲分区地址：2000-3000（不相邻）</p></li><li><p>回收后新增空闲分区：1000-2000</p></li></ul></li></ul></li></ol><h5 id="紧凑技术"><a href="#紧凑技术" class="headerlink" title="紧凑技术"></a>紧凑技术</h5><p><strong>没有内部碎片，但是会有外部碎片。外部碎片可以通过紧凑技术。</strong></p><p>紧凑技术是指将内存中已分配的分区（占用区）向一端移动，同时将空闲分区合并，从而减少内存碎片，形成一个连续的大空闲分区。这一过程也称为<strong>内存碎片整理</strong>。</p><h5 id="动态分区分配算法（重要）"><a href="#动态分区分配算法（重要）" class="headerlink" title="动态分区分配算法（重要）"></a>动态分区分配算法（重要）</h5><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image.png"></p><ol><li><p><strong>首次适应算法（First Fit）​</strong></p><ul><li><p><strong>原理</strong>：从内存的起始位置开始搜索，找到第一个能够满足请求大小的空闲分区，并分配给进程。</p></li><li><p><strong>特点</strong>：</p><ul><li><p>简单高效，搜索速度快。</p></li><li><p>倾向于在内存的低地址部分分配，可能导致低地址部分碎片化。</p></li></ul></li><li><p><strong>优点</strong>：实现简单，分配速度快。</p></li><li><p><strong>缺点</strong>：可能产生外部碎片，内存利用率较低。</p></li><li><p><strong>适用场景</strong>：对分配速度要求较高的场景。</p></li></ul></li><li><p><strong>最佳适应算法（Best Fit）​</strong></p><ul><li><p><strong>原理</strong>：搜索整个空闲分区链表，找到能够满足请求大小的最小空闲分区，并分配给进程。</p></li><li><p><strong>特点</strong>：</p><ul><li><p>尽量利用小分区，减少大分区的浪费。</p></li><li><p>可能导致大量小碎片，增加外部碎片。</p></li></ul></li><li><p><strong>优点</strong>：内存利用率较高，适合小内存请求。</p></li><li><p><strong>缺点</strong>：搜索速度较慢，可能产生大量小碎片。</p></li><li><p><strong>适用场景</strong>：内存资源有限且请求大小差异较大的场景。</p></li></ul></li><li><p><strong>最坏适应算法（Worst Fit）​</strong></p><ul><li><p><strong>原理</strong>：搜索整个空闲分区链表，找到最大的空闲分区，并分配给进程。</p></li><li><p><strong>特点</strong>：</p><ul><li><p>尽量利用大分区，减少小分区的产生。</p></li><li><p>可能导致大分区被快速消耗，无法满足后续大内存请求。</p></li></ul></li><li><p><strong>优点</strong>：减少小碎片的产生。</p></li><li><p><strong>缺点</strong>：大分区被快速消耗，可能无法满足大内存请求。</p></li><li><p><strong>适用场景</strong>：内存请求大小较为均匀的场景。</p></li></ul></li><li><p><strong>邻近适应算法（Next Fit）​</strong></p><ul><li><p><strong>原理</strong>：从<strong>上次分配结束的位置</strong>开始搜索，找到第一个能够满足请求大小的空闲分区，并分配给进程。</p></li><li><p><strong>特点</strong>：</p><ul><li><p>分配较为均匀，避免集中在低地址部分。</p></li><li><p>可能导致高地址部分碎片化。</p></li></ul></li><li><p><strong>优点</strong>：分配速度较快（不用再给空闲分区链重新排序），避免低地址部分碎片化。</p></li><li><p><strong>缺点</strong>：可能产生外部碎片，内存利用率较低。</p></li><li><p><strong>适用场景</strong>：对分配速度要求较高且内存请求分布均匀的场景。</p></li></ul></li></ol><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-1.png"></p><h3 id="3-1-3-基本分页存储管理（重要，注意文字）"><a href="#3-1-3-基本分页存储管理（重要，注意文字）" class="headerlink" title="3.1.3 基本分页存储管理（重要，注意文字）"></a>3.1.3 基本分页存储管理（重要，注意文字）</h3><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-25.png"></p><h4 id="分页存储的几个基本概念"><a href="#分页存储的几个基本概念" class="headerlink" title="分页存储的几个基本概念"></a>分页存储的几个基本概念</h4><ul><li><p>内存地址——页框、页帧、物理块。</p></li><li><p>逻辑地址——页、页面。</p></li></ul><h4 id="基本地址变化机构"><a href="#基本地址变化机构" class="headerlink" title="基本地址变化机构"></a>基本地址变化机构</h4><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-24.png"></p><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-29.png"></p><ul><li><p>页表寄存器（PTR）存放页表在内存中的起始地址F和页表长度M，在单CPU系统中只设置一个页表寄存器。</p></li><li><p>平时的页表起始地址和页表长度存放在本进程的PCB中。</p></li></ul><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-23.png"></p><p>例题</p><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-22.png"></p><p>有的时候会故意让一个页表项占用更多的字节，使得每个页面恰好可以装得下整数个页表项（注意这里，对于一快表TLB存储在cache中，但是对于普通的页表或者说“慢表”，则存储在内存中），防止出现页内碎片。</p><p>如下图所示：</p><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-27.png"></p><h4 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h4><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-26.png"></p><p>文字解释：</p><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-18.png"></p><p>使用快表进行访存的例题：</p><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-19.png"></p><p>这里要注意一个点：快表要经过一次访存（就是访问我们最终想要访问的内存单元）；慢表经过两次（又有一次是根据PTR寻找页表）。</p><p>上图中的100us就是一次访存的时间。</p><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-28.png"></p><h4 id="快表与局部性原理"><a href="#快表与局部性原理" class="headerlink" title="快表与局部性原理"></a>快表与局部性原理</h4><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-17.png"></p><h4 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h4><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-21.png"></p><h5 id="两级页表存在的问题"><a href="#两级页表存在的问题" class="headerlink" title="两级页表存在的问题"></a>两级页表存在的问题</h5><ol><li><p><strong>问题一</strong>：<br><strong>页表必须连续存放（因为要根据页内偏移量来推出最后实际的物理地址）</strong>，因此当页表很大时，需要占用很多连续的页框。</p></li><li><p><strong>问题二</strong>：<br>浪费内存。由局部性可知，没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</p></li></ol><p><strong>思考与解决方案</strong></p><ol><li><p><strong>解决“页表必须连续存放”的问题</strong></p><ol><li>把必须连续存放的页表再分页。</li></ol><ul><li><p>将长长的页表进行分组，使每个内存块刚好可以放入一个分组。</p><ul><li><p>例如，页面大小为4KB，每个页表项为4B，每个页面可存放1K个页表项。</p></li><li><p>因此，每1K个连续的页表项为一组，每组刚好占一个内存块。</p></li></ul></li><li><p>将各组离散地放到各个内存块中。</p></li></ul></li><li><p><strong>解决内存浪费的问题</strong><br>引入虚拟内存管理：</p></li></ol><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-15.png"></p><h5 id="两级页表细节"><a href="#两级页表细节" class="headerlink" title="两级页表细节"></a>两级页表细节</h5><p>1.<strong>多级页表中各级页表的大小不能超过一个页面最多能放的页表项</strong></p><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-16.png"></p><p>2.<strong>n级页表的访存次数是n+1次（如果不用快表）</strong>&#x20;</p><p>总结：</p><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-20.png"></p><h3 id="3-1-4-基本分段存储管理（重要）"><a href="#3-1-4-基本分段存储管理（重要）" class="headerlink" title="3.1.4 基本分段存储管理（重要）"></a>3.1.4 基本分段存储管理（重要）</h3><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-44.png"></p><p>分段：按照程序自身的逻辑关系划分成若干段，每段从0开始编址。</p><p>内存分配规则：每个段内部连续，但是段之间可以不相邻。</p><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-43.png"></p><h4 id="逻辑地址组成"><a href="#逻辑地址组成" class="headerlink" title="逻辑地址组成"></a>逻辑地址组成</h4><p>逻辑地址由段号和段内地址（段内偏移量）组成</p><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-41.png"></p><ul><li><p>段号位数决定可以分多少个段</p></li><li><p>段内地址位数决定每个段的最大长度是多少</p></li></ul><h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-42.png"></p><ul><li><p>相比于页表多了一列表示段长，这是因为每个段长可能是不同的，但是分页中每个页的长度都是相同的。</p></li><li><p>“段表项”长度是相同的，所以同样段表项中的段号可以隐含，不占存储空间。</p></li></ul><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-40.png"></p><h4 id="分段管理方式"><a href="#分段管理方式" class="headerlink" title="分段管理方式"></a>分段管理方式</h4><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-39.png"></p><p>与分页的最大区别在于：由于分段的段长不同，所以在上图中的步骤4还要再检查一次是否会产生越界中断。</p><h3 id="3-1-5-段页式管理方式"><a href="#3-1-5-段页式管理方式" class="headerlink" title="3.1.5 段页式管理方式"></a>3.1.5 段页式管理方式</h3><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-38.png"></p><h4 id="分段与分页各自不足"><a href="#分段与分页各自不足" class="headerlink" title="分段与分页各自不足"></a>分段与分页各自不足</h4><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-34.png"></p><p><strong>注意：分段管理产生的内部碎片其实页可以使用“紧凑（详见本章动态分区分分配）”的思路来解决，只是需要付出较大的时间代价。</strong></p><h4 id="段页式管理的逻辑地址结构"><a href="#段页式管理的逻辑地址结构" class="headerlink" title="段页式管理的逻辑地址结构"></a>段页式管理的逻辑地址结构</h4><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-35.png"></p><p>他的思路实际上就是先分段，然后系统会自己在段的内部分页。</p><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-32.png"></p><p>如上图所示，可以看到段页式存储和段式存储的区别——它的段表存放的的是“段号、页表长度和页表存放块号”。</p><ul><li><p>页表长度是为了进行越界中断的判断</p></li><li><p>页表存放块号是因为一个进程中有一个段表，但是可能有多个页表，所以要找到对应的页表所在的块才可以进行后续根据页号查找的操作。</p></li></ul><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-37.png"></p><p>注意这里的步骤4还要根据获得的页号P以及段表中的页表长度来判断是否越界。</p><p>访存次数为3次，首先访问段表，再访问页表，最后访问相应的目标单元。</p><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-36.png"></p><h3 id="本章问题"><a href="#本章问题" class="headerlink" title="本章问题"></a>本章问题</h3><h4 id="编译、链接、装入的作用分别是什么？"><a href="#编译、链接、装入的作用分别是什么？" class="headerlink" title="编译、链接、装入的作用分别是什么？"></a>编译、链接、装入的作用分别是什么？</h4><ul><li><p>编译：由代码文件转化为目标模块（高级语言转化为机器语言）。</p></li><li><p>链接：由目标模块生成装入模块，链接后形成完整的逻辑地址。</p></li><li><p>装入：装入模块进入内存，装入后形成物理地址。</p></li></ul><h4 id="分段，分页管理的对比？（重要）"><a href="#分段，分页管理的对比？（重要）" class="headerlink" title="分段，分页管理的对比？（重要）"></a>分段，分页管理的对比？（重要）</h4><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-31.png"></p><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-33.png"></p><p><img src="/2025/03/04/3-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/image-30.png"></p><p>总结一下：</p><ul><li><p><strong>页是信息的物理单位，对用户不可见；段是信息的逻辑单位，对用户可见。</strong></p></li><li><p><strong>分页的用户进程的地址空间是一维的，分段的地址空间是二维的</strong>。分页机制将逻辑地址空间划分为大小固定且连续的页（如4KB），用户进程的逻辑地址仅需通过一个线性地址即可表达。</p><ul><li><p>例如，当用户给出逻辑地址<code>5000</code>时，系统自动根据页大小（如4KB）计算出页号（第2页）和页内偏移（1000），无需用户显式指定页号。</p></li><li><p>分段管理根据程序的逻辑功能（如代码段、数据段、栈段）划分内存，每个段独立编址且长度可变。用户需显式指定段名（或段号）和段内偏移量，例如汇编指令<code>MOV [DS:0x100]</code>需同时指明段（DS）和偏移地址（0x100），形成二维地址结构。</p></li></ul></li><li><p>分段比分页更容易实现<strong>信息保护</strong>（上图2、3）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.4 死锁</title>
      <link href="/2025/03/03/2-4%E6%AD%BB%E9%94%81/"/>
      <url>/2025/03/03/2-4%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="2-4-死锁"><a href="#2-4-死锁" class="headerlink" title="2.4 死锁"></a>2.4 死锁</h2><p><img src="/2025/03/03/2-4%E6%AD%BB%E9%94%81/image-7.png"></p><h3 id="2-4-1-死锁的概念"><a href="#2-4-1-死锁的概念" class="headerlink" title="2.4.1 死锁的概念"></a>2.4.1 死锁的概念</h3><h4 id="死锁，饥饿，死循环的区别是什么？（重要）"><a href="#死锁，饥饿，死循环的区别是什么？（重要）" class="headerlink" title="死锁，饥饿，死循环的区别是什么？（重要）"></a>死锁，饥饿，死循环的区别是什么？（重要）</h4><p><strong>死锁</strong></p><p>各进程互相等待对方手里的资源，导致各进程阻塞，无法向前推进的现象。</p><p><strong>饥饿</strong></p><p>由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</p><p><strong>死循环</strong></p><p>某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。</p><p><strong>共同点</strong></p><p>都是进程无法顺利向前推进的现象（故意设计的死循环除外）。</p><p><strong>区别</strong></p><h4 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a><strong>死锁的四个必要条件</strong></h4><p>产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。</p><ol><li><p><strong>互斥条件</strong><br>只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。</p></li><li><p><strong>不剥夺条件</strong><br>进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</p></li><li><p><strong>请求和保持条件</strong><br>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</p></li><li><p><strong>循环等待条件</strong><br>存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</p></li></ol><p><img src="/2025/03/03/2-4%E6%AD%BB%E9%94%81/image-8.png"></p><p><strong>注意：发生死锁的时候一定有循环等待；发生循环等待时未必会造成死锁。</strong></p><p>如上图，虽然发生了循环等待，但此时只要存在一个哲学家6，它放下手中的筷子就可以防止死锁的产生。</p><p><strong>换句话说：如果同类资源数大于1，即使发生了循环等待，也未必会发生死锁。但是如果系统中没类资源只有一个，那么发生循环等待就必定会发行死锁（充要条件）。</strong></p><h4 id="死锁的处理"><a href="#死锁的处理" class="headerlink" title="死锁的处理"></a>死锁的处理</h4><h5 id="1-预防死锁"><a href="#1-预防死锁" class="headerlink" title="1.预防死锁"></a>1.<strong>预防死锁</strong></h5><p>破坏死锁产生的四个必要条件中的一个或几个。</p><h5 id="2-避免死锁"><a href="#2-避免死锁" class="headerlink" title="2.避免死锁"></a>2.<strong>避免死锁</strong></h5><p>用某种方法防止系统进入不安全状态，从而避免死锁（如银行家算法）。</p><h5 id="3-死锁的检测和解除"><a href="#3-死锁的检测和解除" class="headerlink" title="3.死锁的检测和解除"></a>3.<strong>死锁的检测和解除</strong></h5><p>允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</p><p><img src="/2025/03/03/2-4%E6%AD%BB%E9%94%81/image-5.png"></p><h3 id="2-4-2-死锁预防"><a href="#2-4-2-死锁预防" class="headerlink" title="2.4.2 死锁预防"></a>2.4.2 死锁预防</h3><p><img src="/2025/03/03/2-4%E6%AD%BB%E9%94%81/image.png"></p><h4 id="1-破坏互斥条件"><a href="#1-破坏互斥条件" class="headerlink" title="1.破坏互斥条件"></a>1.破坏互斥条件</h4><p>例如使用SPOOLing技术把独占设备在逻辑上改造成共享设备。</p><p><img src="/2025/03/03/2-4%E6%AD%BB%E9%94%81/image-3.png"></p><p>缺点：不是所有的资源都可以改造成可共享使用的资源。为了安全性，很多时候要保护互斥性。所以平【破坏互斥性的应用面较窄。</p><h4 id="2-破坏不剥夺条件"><a href="#2-破坏不剥夺条件" class="headerlink" title="2.破坏不剥夺条件"></a>2.破坏不剥夺条件</h4><p>方案一：如果某一个进程请求新的资源得不到满足的时候，必须立即释放保持的所有资源，然后再重新申请。比如reentractlock中的trylock，不满足就使用finally释放之后的所。（见JUC）</p><p>方案二：让操作系统协助，将该进程想要的资源强行剥夺。</p><p>缺点：</p><ol><li><p><strong>实现起来比较复杂</strong>。</p></li><li><p><strong>释放已获得的资源可能造成前一阶段工作的失效</strong>。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。</p></li><li><p><strong>反复地申请和释放资源会增加系统开销，降低系统吞吐量</strong>。</p></li><li><p><strong>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请</strong>。如果一直发生这样的情况，就会导致进程饥饿。</p></li></ol><h4 id="3-破坏请求与保持条件"><a href="#3-破坏请求与保持条件" class="headerlink" title="3.破坏请求与保持条件"></a>3.破坏请求与保持条件</h4><p>使用<strong>静态分配法</strong> ：即在进程运行一次前申请完他所需要的全部资源，如果不能满足就不运行。在投入运行之后，他不会在请求其他的资源。</p><p>缺点：</p><ol><li><p><strong>资源利用率低</strong>：因为某些资源做需要的时间较短，这种同一申请并释放的方式会造成这些资源的浪费。</p></li><li><p><strong>造成饥饿现象</strong>：如下图有可能导致C类进程饥饿。</p></li></ol><p><img src="/2025/03/03/2-4%E6%AD%BB%E9%94%81/image-2.png"></p><h4 id="4-破坏循环等待条件"><a href="#4-破坏循环等待条件" class="headerlink" title="4.破坏循环等待条件"></a>4.破坏循环等待条件</h4><p>采用“顺序资源分配法”：也就是说</p><p>缺点：</p><ol><li><p>如果要新增设备，则要重新编号</p></li><li><p>实际使用资源的顺序可能和编号递增顺序不一样，造成资源的浪费</p></li><li><p>必须按照规定次序申请资源，对于用户编程不便。</p></li></ol><h3 id="2-4-3-死锁避免"><a href="#2-4-3-死锁避免" class="headerlink" title="2.4.3 死锁避免"></a>2.4.3 死锁避免</h3><h4 id="1-安全序列"><a href="#1-安全序列" class="headerlink" title="1. 安全序列"></a><strong>1. 安全序列</strong></h4><ul><li><p><strong>定义</strong>：存在一个进程执行顺序（如 <strong>T→B→A</strong>），使得系统按此顺序分配资源时，<strong>所有进程都能顺利完成</strong>。</p></li><li><p><strong>判断标准</strong>：<br>若某个进程的<strong>最多还会借 ≤ 当前可用资源</strong>，则可将其加入安全序列。重复此过程，若所有进程都能被满足，则系统处于<strong>安全状态</strong>。</p></li><li><p><strong>实例</strong>​（图中案例）：<br>当系统剩余资源为 <strong>10亿</strong> 时：</p><ul><li><p>若给进程A分配 <strong>20亿</strong>，A的剩余需求变为 <strong>10亿</strong>​（≤10亿），满足条件。</p></li><li><p>后续依次完成 <strong>T→B→A</strong>，形成安全序列，系统处于安全状态。</p></li></ul></li></ul><h4 id="2-不安全状态"><a href="#2-不安全状态" class="headerlink" title="2. 不安全状态"></a><strong>2. 不安全状态</strong></h4><ul><li><p><strong>定义</strong>：若资源分配后<strong>无法找到任何一个安全序列</strong>，则系统进入不安全状态。此时<strong>所有进程可能无法完成</strong>​（但未必立即死锁）。</p></li><li><p><strong>触发条件</strong>：<br>某次分配导致<strong>剩余资源无法满足任何进程的后续需求</strong>。</p></li><li><p><strong>实例</strong>​（图中案例）：</p><ul><li><p>若给进程B分配 <strong>30亿</strong>，系统剩余资源仅剩 <strong>10亿</strong>。</p></li><li><p>此时：</p><ul><li><p>进程B仍需 <strong>20亿</strong>​（&gt;10亿）→ 不满足</p></li><li><p>进程A仍需 <strong>30亿</strong>​（&gt;10亿）→ 不满足</p></li><li><p>进程T仍需 <strong>20亿</strong>​（&gt;10亿）→ 不满足</p></li></ul></li><li><p>所有进程均无法继续，系统进入不安全状态。</p></li></ul></li></ul><h4 id="3-死锁与不安全状态的关系"><a href="#3-死锁与不安全状态的关系" class="headerlink" title="3. 死锁与不安全状态的关系"></a><strong>3. 死锁与不安全状态的关系</strong></h4><ul><li><p><strong>必然性</strong>：​<strong>死锁一定发生在不安全状态</strong>，但<strong>不安全状态不一定会发生死锁</strong>。</p></li><li><p><strong>区别</strong>：</p><ul><li><p>不安全状态可能导致进程暂时阻塞（若后续有资源释放，仍可能恢复）。</p></li><li><p>死锁是进程间<strong>永久相互等待</strong>的状态，无法自行解除。</p></li></ul></li></ul><h4 id="4-银行家算法"><a href="#4-银行家算法" class="headerlink" title="4.银行家算法"></a>4.<strong>银行家算法</strong></h4><p>在分配资源前，<strong>预先模拟分配后的系统状态</strong>，判断是否存在安全序列：</p><p>通过主动预判，<strong>从源头杜绝死锁风险</strong>，确保系统始终处于安全状态。</p><p><img src="/2025/03/03/2-4%E6%AD%BB%E9%94%81/image-1.png"></p><h3 id="2-4-4-死锁的检测与解除"><a href="#2-4-4-死锁的检测与解除" class="headerlink" title="2.4.4 死锁的检测与解除"></a>2.4.4 死锁的检测与解除</h3><h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><p><img src="/2025/03/03/2-4%E6%AD%BB%E9%94%81/image-4.png"></p><h4 id="死锁将解除"><a href="#死锁将解除" class="headerlink" title="死锁将解除"></a>死锁将解除</h4><p><img src="/2025/03/03/2-4%E6%AD%BB%E9%94%81/image-6.png"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.6局域网与IEEE802</title>
      <link href="/2025/03/03/3-6%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8EIEEE802/"/>
      <url>/2025/03/03/3-6%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8EIEEE802/</url>
      
        <content type="html"><![CDATA[<h2 id="3-6-局域网-与-IEEE-802"><a href="#3-6-局域网-与-IEEE-802" class="headerlink" title="3.6 局域网 与 IEEE 802"></a>3.6 局域网 与 IEEE 802</h2><h3 id="本章概述"><a href="#本章概述" class="headerlink" title="本章概述"></a>本章概述</h3><p><img src="/2025/03/03/3-6%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8EIEEE802/image-12.png"></p><h3 id="什么是IEEE-802？"><a href="#什么是IEEE-802？" class="headerlink" title="什么是IEEE 802？"></a>什么是IEEE 802？</h3><p><img src="/2025/03/03/3-6%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8EIEEE802/image-14.png"></p><h4 id="802委员会和各种局域网技术的关系"><a href="#802委员会和各种局域网技术的关系" class="headerlink" title="802委员会和各种局域网技术的关系"></a>802委员会和各种局域网技术的关系</h4><ul><li><p>IEEE 802是IEEE下属的一个委员会，他下属有一些工作组。一开始的时候某些科技公司的局域网技术会受到大众的认可，如IBM公司之前发明了令牌环网技术，然后802.5工作组就成立来<strong>推进该技术的标准化工作技术使其普及</strong>。</p></li><li><p>802.3 以太网技术（局域网），802.11 WIFI技术（无线局域网）</p></li></ul><h4 id="IEEE-802的层次划分"><a href="#IEEE-802的层次划分" class="headerlink" title="IEEE 802的层次划分"></a>IEEE 802的层次划分</h4><p>将数据链路层拆分成了两个子层</p><ul><li><p><strong>MAC子层</strong>（介质访问控制）: 与访问截止相关（组帧、差错控制、透明传输、介质访问控制）</p></li><li><p><strong>LLC子层</strong>（逻辑链路控制）: 兼容各种局域网技术，对上层网络层暴露出相同的结点。但是目前已经被有线和无线局域网所垄断，已经名存实亡。</p></li></ul><h4 id="IEEE-802-3推出的以太网标准（物理层）"><a href="#IEEE-802-3推出的以太网标准（物理层）" class="headerlink" title="IEEE 802.3推出的以太网标准（物理层）"></a>IEEE 802.3推出的以太网标准（物理层）</h4><p><img src="/2025/03/03/3-6%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8EIEEE802/image-11.png"></p><p><img src="/2025/03/03/3-6%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8EIEEE802/image-13.png"></p><h4 id="两种常见的MAC层标准——v2与802-3"><a href="#两种常见的MAC层标准——v2与802-3" class="headerlink" title="两种常见的MAC层标准——v2与802.3"></a>两种常见的MAC层标准——v2与802.3</h4><p><img src="/2025/03/03/3-6%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8EIEEE802/image-10.png"></p><ul><li><p>市面上常用v2标准。</p></li><li><p><strong>802.3标准和v2标准，只有画圈部分不一样！</strong></p></li></ul><p>注意两者口诀差异。</p><h5 id="IEEE802-3"><a href="#IEEE802-3" class="headerlink" title="IEEE802.3"></a>IEEE802.3</h5><p><img src="/2025/03/03/3-6%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8EIEEE802/image-9.png"></p><h5 id="v2"><a href="#v2" class="headerlink" title="v2"></a>v2</h5><p><img src="/2025/03/03/3-6%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8EIEEE802/image-8.png"></p><p>注意右下角的这个违规编码法表示停止，回顾一下：物理层使用曼彻斯特编码是中必变的，如果中间不跳变就是违规的，表示正的结尾。</p><h4 id="单播帧，广播帧如何传播？（重点）"><a href="#单播帧，广播帧如何传播？（重点）" class="headerlink" title="单播帧，广播帧如何传播？（重点）"></a>单播帧，广播帧如何传播？（重点）</h4><p><img src="/2025/03/03/3-6%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8EIEEE802/image-2.png"></p><h4 id="冲突域，广播域（重点）"><a href="#冲突域，广播域（重点）" class="headerlink" title="冲突域，广播域（重点）"></a>冲突域，广播域（重点）</h4><p><img src="/2025/03/03/3-6%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8EIEEE802/image-4.png"></p><ul><li><p><strong>路由器会隔离冲突域和广播域</strong></p></li><li><p>集线器什么都不会隔离</p></li><li><p>交换机会隔离冲突域和广播域</p></li></ul><h4 id="虚拟局域网（VLAN）（新内容）"><a href="#虚拟局域网（VLAN）（新内容）" class="headerlink" title="虚拟局域网（VLAN）（新内容）"></a>虚拟局域网（VLAN）（新内容）</h4><p>VLAN由IEEE 802.1Q 维护</p><p>之所以要引入VLAN，是因为对于一个大型的局域网会存在一下问题：</p><p><img src="/2025/03/03/3-6%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8EIEEE802/image-6.png"></p><p><img src="/2025/03/03/3-6%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8EIEEE802/image-7.png"></p><p>如图，每个VLAN对应一个VID，当A进行广播的时候，只有和他在同一个VLAN中的电脑才有可能收到。所以我们可以把一些敏感节点给分开到不同的VLAN，保障安全性。</p><h5 id="VLAN的划分"><a href="#VLAN的划分" class="headerlink" title="VLAN的划分"></a>VLAN的划分</h5><h6 id="（1）基于接口划分"><a href="#（1）基于接口划分" class="headerlink" title="（1）基于接口划分"></a>（1）基于接口划分</h6><p><img src="/2025/03/03/3-6%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8EIEEE802/image-5.png"></p><h6 id="（2）基于MAC地址划分"><a href="#（2）基于MAC地址划分" class="headerlink" title="（2）基于MAC地址划分"></a>（2）基于MAC地址划分</h6><p>好处是即使改了接口，只要MAC地址不变就可以发送到。</p><p><img src="/2025/03/03/3-6%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8EIEEE802/image.png"></p><h6 id="（3）基于ip地址"><a href="#（3）基于ip地址" class="headerlink" title="（3）基于ip地址"></a>（3）基于ip地址</h6><p><img src="/2025/03/03/3-6%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8EIEEE802/image-3.png"></p><p>好处是可以跨越局域网。</p><h5 id="820-1Q帧"><a href="#820-1Q帧" class="headerlink" title="820.1Q帧"></a>820.1Q帧</h5><p><img src="/2025/03/03/3-6%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8EIEEE802/image-1.png"></p><h6 id="802-1Q帧结构"><a href="#802-1Q帧结构" class="headerlink" title="802.1Q帧结构"></a>802.1Q帧结构</h6><p><img src="/2025/03/03/3-6%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8EIEEE802/image-19.png"></p><h3 id="局域网（LAN）"><a href="#局域网（LAN）" class="headerlink" title="局域网（LAN）"></a>局域网（LAN）</h3><h4 id="局域网的特点"><a href="#局域网的特点" class="headerlink" title="局域网的特点"></a>局域网的特点</h4><ul><li><p>覆盖较小的地理范围</p></li><li><p>LAN中的通信有较低的试验和误码率</p></li><li><p>各个节点间的数据传输是以帧为单位的</p></li><li><p>支持单播、多播、广播</p></li></ul><p><img src="/2025/03/03/3-6%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8EIEEE802/image-18.png"></p><p>通过MAC地址发送。</p><h4 id="LAN的分类"><a href="#LAN的分类" class="headerlink" title="LAN的分类"></a>LAN的分类</h4><p><img src="/2025/03/03/3-6%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8EIEEE802/image-17.png"></p><h5 id="有线局域网"><a href="#有线局域网" class="headerlink" title="有线局域网"></a>有线局域网</h5><ul><li><p>现在一般用以太网而不是令牌环网</p></li><li><p>物理层采用曼彻斯特编码</p></li><li><p>早期以太网使用同轴电缆，之后使用双绞线以及光纤</p></li><li><p>使用CAMA&#x2F;CD协议，除了光纤以太网为null</p></li><li><p><strong>由于光纤以太网是点对点以及全双工通信，所以不需要介质访问控制</strong></p></li><li><p>双绞线以太网需要介质访问控制。</p><ul><li><p>因为虽然他物理上是星型结构，如果是通过集线器实现的，而<strong>集线器他的底层使用的是总线型的拓扑结构</strong>，所以会存在信道争用的问题。需要CSMA&#x2F;CD。</p></li><li><p>如果是使用交换机实现的，有的交换机是半双工，会信道争用，使用CSMA&#x2F;CD协议。有的是全双工，不会信道争用，为null。</p></li></ul></li></ul><h5 id="无线局域网（WLAN）"><a href="#无线局域网（WLAN）" class="headerlink" title="无线局域网（WLAN）"></a>无线局域网（WLAN）</h5><ul><li><p>定义为星型（想象一个AP+n个移动设备）</p></li><li><p>CSMA&#x2F;CA协议</p></li></ul><h4 id="LAN的硬件架构"><a href="#LAN的硬件架构" class="headerlink" title="LAN的硬件架构"></a>LAN的硬件架构</h4><p><img src="/2025/03/03/3-6%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8EIEEE802/image-16.png"></p><ul><li><p>数据链路层的发送与接收窗口的帧都是存储在以太网适配器的RAM芯片中。</p></li><li><p>WIFI网络适配器又称“无线网卡”。它的ROM也有一个全球唯一的MAC地址，但是这个和有线网络的MAC地址不一样。如果有的笔记本没有有线的网络接口，可以用USB-to-Ethernet这个转换器，使用转换器的MAC地址唯一标识。</p></li><li><p>封装成帧可以由主机或者网络适配器实现。</p></li></ul><h3 id="本章问题"><a href="#本章问题" class="headerlink" title="本章问题"></a>本章问题</h3><h4 id="MAC帧的格式？"><a href="#MAC帧的格式？" class="headerlink" title="MAC帧的格式？"></a>MAC帧的格式？</h4><ul><li><p>v2——662N4 收发协数验</p></li><li><p>IEEE 802.3——662N4 收发长数验</p></li><li><p>VLAN 802.1Q帧——6642N4收发V协数验</p></li></ul><h4 id="为什么v2的MAC帧包含2位表示协议，而IEEE-802-3相同的位置表示长度？"><a href="#为什么v2的MAC帧包含2位表示协议，而IEEE-802-3相同的位置表示长度？" class="headerlink" title="为什么v2的MAC帧包含2位表示协议，而IEEE 802.3相同的位置表示长度？"></a>为什么v2的MAC帧包含2位表示协议，而IEEE 802.3相同的位置表示长度？</h4><ul><li><p>DIX Ethernet V2标准是由DEC、Intel和Xerox联合开发的，其设计目标是为了实现<strong>简单高效的局域网通信</strong>。</p></li><li><p>IEEE 802.3标准是在DIX Ethernet V2的基础上进一步标准化的产物，其设计目标是为了<strong>增强以太网的兼容性和扩展性</strong>。</p></li><li><p>IEEE 802.3标准是在DIX Ethernet V2的基础上进一步标准化的产物，其设计目标是为了<strong>增强以太网的兼容性和扩展性</strong>。</p></li><li><p>在IEEE 802.3中，<strong>Length字段</strong>用于指示数据字段的长度（以字节为单位），这是为了<strong>确保数据帧的完整性</strong>，尤其是在数据链路层和物理层的传输过程中。</p></li><li><p>IEEE 802.3标准还引入了<strong>LLC（逻辑链路控制）子层</strong>，通过LLC头部的SAP（服务访问点）字段来标识上层协议类型，因此不再需要在MAC帧中使用Type字段。</p></li><li><p>这种设计更适合<strong>标准化和模块化</strong>的网络架构，因为它将协议类型的标识任务交给了LLC子层，而不是MAC层。</p></li></ul><p><strong>总结：现在常用v2，舍弃了LLC，需要有2位表示协议。</strong></p><h4 id="哪些线支持全双工？哪些支持半双工？-xA"><a href="#哪些线支持全双工？哪些支持半双工？-xA" class="headerlink" title="哪些线支持全双工？哪些支持半双工？&#xA;"></a>哪些线支持全双工？哪些支持半双工？&#xA;</h4><p><img src="/2025/03/03/3-6%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8EIEEE802/image-15.png"></p><h4 id="双绞线以太网实现全双工通信最少需要几对双绞线？为什么常用的是4对？"><a href="#双绞线以太网实现全双工通信最少需要几对双绞线？为什么常用的是4对？" class="headerlink" title="双绞线以太网实现全双工通信最少需要几对双绞线？为什么常用的是4对？"></a>双绞线以太网实现全双工通信最少需要几对双绞线？为什么常用的是4对？</h4><p>最少需要其实一根就可以了，只要他的速率够快。</p><p>现在双绞线通常设计为4对线（12、36、45、78），主要是为了满足以太网通信的需求、优化物理和电气性能、符合RJ45接口标准以及简化工程实现。</p><ol><li><p><strong>符合以太网通信要求</strong>：早期的10BASE-T和100BASE-TX标准只使用了两对线（12和36），分别用于发送和接收数据。随着千兆以太网（1000BASE-T）的普及，全部四对线都被启用以支持全双工通信。为了确保兼容性，后续标准沿用了这一分配方式。</p></li><li><p><strong>物理和电气性能优化</strong>：双绞线的绞合设计是为了减少电磁干扰和串扰。12、36、45、78的排列方式可以最大限度地减少信号间的串扰。如果采用12、34、56、78的排列，不同信号线可能彼此靠得更近，增加串扰的风险，降低通信质量。</p></li></ol><ol start="3"><li><p><strong>符合RJ45接口标准</strong>：RJ45接口的针脚定义严格遵循线对的排列方式（1、2号针用于12，3、6号针用于36，4、5号针用于45，7、8号针用于78）。这种设计有助于实现电缆的通用性，使得一根双绞线既能用于早期的10&#x2F;100Mbps以太网，也能用于千兆以太网，降低了布线成本和复杂性。</p></li><li><p><strong>工程实现中的便利性</strong>：在实际布线和标准化生产中，12、36、45、78的设计简化了线缆的制作和测试流程。这种分布方式确保了每对线的物理特性保持一致，方便工程师快速查找和测试故障。</p></li></ol><h4 id="点对点的半双工需要介质访问控制吗？全双工呢？如果不是点对点呢？"><a href="#点对点的半双工需要介质访问控制吗？全双工呢？如果不是点对点呢？" class="headerlink" title="点对点的半双工需要介质访问控制吗？全双工呢？如果不是点对点呢？"></a>点对点的半双工需要介质访问控制吗？全双工呢？如果不是点对点呢？</h4><ul><li><p>在点对点的半双工通信中，<strong>需要介质访问控制</strong>。因为半双工模式下，通信双方不能同时发送和接收数据，因此需要通过介质访问控制机制（如CSMA&#x2F;CD）来避免冲突，确保数据传输的顺利进行。</p></li><li><p>对于点对点的全双工通信，<strong>不需要介质访问控制</strong>。全双工模式下，通信双方可以同时发送和接收数据，且使用独立的线路，因此不会产生冲突，无需介质访问控制机制。</p></li><li><p>如果通信不是点对点的（例如共享介质的多点通信），<strong>无论半双工还是全双工，都需要介质访问控制</strong>。在半双工模式下，共享介质的多点通信需要通过CSMA&#x2F;CD等机制来避免冲突；而在全双工模式下，虽然理论上可以同时收发数据，但由于共享介质的存在，仍然需要介质访问控制来协调多个设备的通信。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.3同步与互斥</title>
      <link href="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/"/>
      <url>/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="2-3-同步与互斥"><a href="#2-3-同步与互斥" class="headerlink" title="2.3 同步与互斥"></a>2.3 同步与互斥</h2><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-14.png"></p><p><strong>回顾：什么是异步性？</strong><br>异步是指个并发执行的进程会以各自独立的，不可预知的速度向前推进。</p><p>同步又称为直接制约关系，在某些位置上需要协调多个线程之间的次序。</p><h3 id="2-3-1-同步与互斥的基本概念"><a href="#2-3-1-同步与互斥的基本概念" class="headerlink" title="2.3.1 同步与互斥的基本概念"></a>2.3.1 同步与互斥的基本概念</h3><h4 id="什么是进程互斥？"><a href="#什么是进程互斥？" class="headerlink" title="什么是进程互斥？"></a>什么是进程互斥？</h4><p>回顾一下OS的4大特性：并发，共享，虚拟，异步。</p><p>其中共享可以分为两部分</p><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-13.png"></p><p>一段时间之内对临界资源的访问必须互斥进行。</p><h4 id="临界资源（重要）"><a href="#临界资源（重要）" class="headerlink" title="临界资源（重要）"></a>临界资源（重要）</h4><p>对临界资源的访问可以划分为4个部分</p><ul><li><p><strong>进入区</strong> entry section (<strong>上锁</strong>，阻止其他进程进入临界区)</p></li><li><p><strong>临界区</strong> critical section（<strong>访问临界资源的代码</strong>）</p></li><li><p><strong>退出区</strong> exit section（<strong>解锁</strong>）</p></li><li><p><strong>剩余区</strong> remainder section（做其他处理）</p></li></ul><p>所以，临界区是进程中访问临界资源的代码段，而真正实现互斥访问的代码段是进入区和退出区。</p><h4 id="实现临界区互斥必须遵守的标准"><a href="#实现临界区互斥必须遵守的标准" class="headerlink" title="实现临界区互斥必须遵守的标准"></a>实现临界区互斥必须遵守的标准</h4><p>一共有4个：</p><ul><li><p><strong>空闲让进</strong>。如果临界区空闲，则允许一个请求进入临界区的进程进程立即进入临界区。</p></li><li><p><strong>忙则等待</strong>。如果有进程进入临界区，其他试图进入临界区的进程必须要等待。</p></li><li><p><strong>有限等待</strong>。对于请求访问的进程，必须要保证它能在有限的时间内进入临界区，防止进程的无限等待。</p></li><li><p><strong>让权等待</strong>（原则上应遵守，但不是必须的）。当进程不能进入临界区的时候应该立即释放处理器，防止进程忙等待。</p><ul><li>关于让权等待，让我们回顾一下，以下两种说法的区别：</li></ul><ol><li><p>在处理中断程序的过程中，在OS的内核程序临界区不可以进行进程调度。（如进程从等待队列切换至就绪独队列是由源语负责的）</p></li><li><p>进程处于临界区时可以进行处理机调度。（如暂时获得不了io资源就让出cpu权限等待io完成通知——<strong>阻塞等待</strong>）</p></li></ol></li></ul><h3 id="2-3-2-进程互斥的软件实现方法（重要）"><a href="#2-3-2-进程互斥的软件实现方法（重要）" class="headerlink" title="2.3.2 进程互斥的软件实现方法（重要）"></a>2.3.2 进程互斥的软件实现方法（重要）</h3><h4 id="1-软件实现方法"><a href="#1-软件实现方法" class="headerlink" title="1.软件实现方法"></a>1.软件实现方法</h4><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-10.png"></p><h5 id="（1）单标志法"><a href="#（1）单标志法" class="headerlink" title="（1）单标志法"></a>（1）单标志法</h5><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-9.png"></p><p>缺点：turn表达谦让，因为while循环会先判断如果turn是对方的序号，则拦截，然对方先运行。但是会<strong>违反“空闲让进”原则。</strong>&#x56E0;为只能按照p0-&gt;p1-&gt;p0-&gt;p1…的顺序轮训访问，但如果标志位允许访问的进程是p0，但是p0一直不访问临界区，就会造成临界区空闲但是没有进程进入的情况。</p><h5 id="（2）双标志先检查法"><a href="#（2）双标志先检查法" class="headerlink" title="（2）双标志先检查法"></a>（2）双标志先检查法</h5><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-12.png"></p><p>缺点：并发执行两个while循环导致两个进程都可以进入临界区。违反“<strong>忙则等待</strong>”。</p><h5 id="（3）双标志后检查法"><a href="#（3）双标志后检查法" class="headerlink" title="（3）双标志后检查法"></a>（3）双标志后检查法</h5><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-11.png"></p><p>缺点：还是类似的问题，如果并发执行两个flag置true，他们都进不了临界区，会在while卡死。虽然解决了双标志位前检法的“<strong>忙则等待</strong>”，但是违反“<strong>有限等待</strong>”，以及“<strong>空闲让进</strong>”。各进程长期无法访问境界资源而产生“饥饿”现象。</p><h5 id="（4）peterson算法"><a href="#（4）peterson算法" class="headerlink" title="（4）peterson算法"></a>（4）peterson算法</h5><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-6.png"></p><p>集合之前的算法，flag置自己的意愿，turn表示自己原理谦让。</p><p>缺点：peterson算法解决了进程互斥问题，唯独没有遵循“<strong>让权等待</strong>”，因为他依旧不断执行while循环消耗cpu资源。</p><h4 id="2-硬件实现方法"><a href="#2-硬件实现方法" class="headerlink" title="2.硬件实现方法"></a>2.硬件实现方法</h4><h5 id="（1）中断屏蔽方法"><a href="#（1）中断屏蔽方法" class="headerlink" title="（1）中断屏蔽方法"></a>（1）中断屏蔽方法</h5><p>利用开\关中断。思路类似原语言，即某进程开始访问临界区直到结束访问不会发生中断，也就是不会发生进程切换，所以不会发行互斥。</p><p>优点：简单高效。</p><p>问题：</p><ul><li><p>不适用于多处理机。</p></li><li><p>不适用于用户进程，只能作用于OS的内核进程。</p></li></ul><h5 id="（2）TestAndSet指令"><a href="#（2）TestAndSet指令" class="headerlink" title="（2）TestAndSet指令"></a>（2）TestAndSet指令</h5><p>简称<strong>TS指令、</strong>&#x54;SL指令、TestAndLock。</p><p>TS指令由硬件实现，一气呵成，不能中断。</p><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-5.png"></p><h5 id="（3）Swap指令"><a href="#（3）Swap指令" class="headerlink" title="（3）Swap指令"></a>（3）Swap指令</h5><p>又叫Exchange、XCHG指令</p><p>同样硬件实现，一气呵成不能中断。</p><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-4.png"></p><h3 id="2-3-3-互斥锁"><a href="#2-3-3-互斥锁" class="headerlink" title="2.3.3 互斥锁"></a>2.3.3 互斥锁</h3><h3 id="2-3-4-信号量（重要）"><a href="#2-3-4-信号量（重要）" class="headerlink" title="2.3.4 信号量（重要）"></a>2.3.4 信号量（重要）</h3><p>直线在学习软件实现的互斥方式的时候我们知道之后peterson算法解决了互斥问题，前三者失败的原因是没有把赋值和while封装成一个原语。</p><p><strong>于是就有信号量机制。提供wait()和signal()两个原语，也就是P(),V()操作。</strong></p><h4 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h4><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-7.png"></p><h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-3.png"></p><p><strong>整型信号量不满足“让权等待”，会发生忙等的情况；而记录型信号量不存在这个问题（因为它使用block()原句主动阻塞当前进程并放入等待队列，释放当前进程的CPU）。</strong></p><h4 id="信号量实现同步"><a href="#信号量实现同步" class="headerlink" title="信号量实现同步"></a>信号量实现同步</h4><p>详情见JUC。</p><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-8.png"></p><h4 id="信号量实现前驱"><a href="#信号量实现前驱" class="headerlink" title="信号量实现前驱"></a>信号量实现前驱</h4><p>详情见JUC。</p><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-1.png"></p><h3 id="2-3-5-经典同步问题"><a href="#2-3-5-经典同步问题" class="headerlink" title="2.3.5 经典同步问题"></a>2.3.5 经典同步问题</h3><h4 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h4><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image.png"></p><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-2.png"></p><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-29.png"></p><h4 id="多生产者多消费者问题"><a href="#多生产者多消费者问题" class="headerlink" title="多生产者多消费者问题"></a>多生产者多消费者问题</h4><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-28.png"></p><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-27.png"></p><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-26.png"></p><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-25.png"></p><h4 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h4><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-20.png"></p><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-24.png"></p><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-23.png"></p><h4 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h4><h5 id="读优先"><a href="#读优先" class="headerlink" title="读优先"></a>读优先</h5><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-21.png"></p><h5 id="读写公平"><a href="#读写公平" class="headerlink" title="读写公平"></a>读写公平</h5><p>实际上就是增加一个互斥信号量w，让读者和写者进行竞争，防止出现之前读者优先的情况。</p><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-22.png"></p><p><strong>注意这里count的用法使得多个读者不会互斥，很巧妙。</strong></p><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-18.png"></p><h4 id="哲学家就餐"><a href="#哲学家就餐" class="headerlink" title="哲学家就餐"></a>哲学家就餐</h4><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-19.png"></p><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-17.png"></p><h3 id="2-3-6-管程"><a href="#2-3-6-管程" class="headerlink" title="2.3.6 管程"></a>2.3.6 管程</h3><p>引入管程是因为信号量机制存在编写困难，易出错的问题。而管程是一种更高级的同步机制。</p><h4 id="管程特征"><a href="#管程特征" class="headerlink" title="管程特征"></a>管程特征</h4><p>&#x20;   <strong>管理是一种特殊的软件模块，由这些部分组成：​</strong></p><p>&#x20;    <strong>管理的基本特征：​</strong></p><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-15.png"></p><p><img src="/2025/03/02/2-3%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/image-16.png"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>介质访问控制</title>
      <link href="/2025/03/02/media-access-control/"/>
      <url>/2025/03/02/media-access-control/</url>
      
        <content type="html"><![CDATA[<h2 id="3-5-介质访问控制"><a href="#3-5-介质访问控制" class="headerlink" title="3.5 介质访问控制"></a>3.5 介质访问控制</h2><h3 id="本节总览："><a href="#本节总览：" class="headerlink" title="本节总览："></a>本节总览：</h3><p>包括：信道划分、随机访问、轮询访问。</p><p><img src="/2025/03/02/media-access-control/1.png" alt="img"></p><p>介质访问控制（Medium Access Control MAC）:多个节点访问一个”总线型“广播网络的时候，可能发生信号冲突。</p><p><img src="/2025/03/02/media-access-control/2.png" alt="img"></p><p>如：</p><ul><li>集线器连接多个节点。</li><li>一个同轴电缆链接多个节点。</li></ul><p><strong>介质访问控制就是为了解决信号冲突的问题。</strong></p><h4 id="复习一下：网络的拓扑结构可以分为：总线型、星型、环形、网状。"><a href="#复习一下：网络的拓扑结构可以分为：总线型、星型、环形、网状。" class="headerlink" title="复习一下：网络的拓扑结构可以分为：总线型、星型、环形、网状。"></a>复习一下：网络的拓扑结构可以分为：总线型、星型、环形、网状。</h4><p><img src="/2025/03/02/media-access-control/3.png" alt="img"></p><h4 id="复习一下：什么是冲突域？"><a href="#复习一下：什么是冲突域？" class="headerlink" title="复习一下：什么是冲突域？"></a>复习一下：什么是冲突域？</h4><p>两台主机同时发送数据数据导致冲突。（注意集线器不会隔离中途与，交换机可以隔离冲突域）</p><ul><li>集线器和中继器不能无限串联。</li><li>集线器弱连接网段的速率不同，会使速率向下兼容。</li></ul><h3 id="3-5-1-信道划分介质访问控制"><a href="#3-5-1-信道划分介质访问控制" class="headerlink" title="3.5.1 信道划分介质访问控制"></a>3.5.1 信道划分介质访问控制</h3><h4 id="1-时分复用（TDM）Time-Division-Multiplexing"><a href="#1-时分复用（TDM）Time-Division-Multiplexing" class="headerlink" title="1. 时分复用（TDM）Time Division Multiplexing"></a>1. 时分复用（TDM）Time Division Multiplexing</h4><p><img src="/2025/03/02/media-access-control/4.png" alt="img"></p><p><img src="/2025/03/02/media-access-control/18.png" alt="img"></p><p><strong>将时间分为等长的TDM帧，每个TDM帧分为等长的M个时隙，将M个时隙分配给M对用户使用。</strong></p><p>缺点：</p><ul><li>每个节点只能分配到总信道带宽的1&#x2F;m</li><li>如果某节点不发送数据，会导致时隙闲置，信道利用率低。</li></ul><p>如何解决这个缺点？很简单，只要动态按需分配时隙即可——<strong>统计时分复用（SDTM）</strong>。</p><h5 id="统计时分复用（STDM）"><a href="#统计时分复用（STDM）" class="headerlink" title="统计时分复用（STDM）"></a>统计时分复用（STDM）</h5><p><img src="/2025/03/02/media-access-control/5.png" alt="img"></p><ul><li>一个节点可以在一段时间内获得所有的的信道贷款资源。</li><li>如果某节点暂不发送数据，可以不分配时隙。</li></ul><h4 id="2-频分复用（FDM）Frequency-Division-Multiplexing"><a href="#2-频分复用（FDM）Frequency-Division-Multiplexing" class="headerlink" title="2.频分复用（FDM）Frequency Division Multiplexing"></a>2.频分复用（FDM）Frequency Division Multiplexing</h4><p>将信道的总频带划分为多个子频带。</p><p><img src="/2025/03/02/media-access-control/6.png" alt="img"></p><ul><li>隔离频带是为了防止信道间相互干扰。</li><li>每个子频带作为一个子信道。</li></ul><h4 id="3-波分复用（WDM）Wavelength"><a href="#3-波分复用（WDM）Wavelength" class="headerlink" title="3.波分复用（WDM）Wavelength"></a>3.波分复用（WDM）Wavelength</h4><p><img src="/2025/03/02/media-access-control/7.png" alt="img"></p><h4 id="4-码分复用（CDM）"><a href="#4-码分复用（CDM）" class="headerlink" title="4.码分复用（CDM）"></a>4.码分复用（CDM）</h4><p><img src="/2025/03/02/media-access-control/8.png" alt="img"></p><ul><li>既共享频率，又共享时间（）。</li><li>要给每一个节点分配其专属的码片序列。</li><li>各个节点的码片需求列要求相互正交。</li></ul><h5 id="码片序列-规格化内积"><a href="#码片序列-规格化内积" class="headerlink" title="码片序列+规格化内积"></a>码片序列+规格化内积</h5><p><img src="/2025/03/02/media-access-control/9.png" alt="img"></p><p>主要是将接收到的<strong>序列</strong>和发送方的<strong>码片序列</strong>求<strong>规格化内积。</strong>最后结果为-1代表0，结果为1代表1。</p><p><img src="/2025/03/02/media-access-control/10.png" alt="img"></p><h3 id="3-5-2-随机访问介质访问控制"><a href="#3-5-2-随机访问介质访问控制" class="headerlink" title="3.5.2 随机访问介质访问控制"></a>3.5.2 随机访问介质访问控制</h3><p><strong>画三角形为重点！</strong></p><p><img src="/2025/03/02/media-access-control/11.png" alt="img"></p><h4 id="1-ALOHA协议"><a href="#1-ALOHA协议" class="headerlink" title="1.ALOHA协议"></a>1.ALOHA协议</h4><p><img src="/2025/03/02/media-access-control/12.png" alt="img"></p><p>注意：</p><ul><li>纯ALOHA协议中是<strong>随机等待</strong>一段时间之后重发（如果是固定时间再重发还会冲突）。</li><li>时隙ALOHA协议降低了纯ALOHA协议的冲突可能性。</li></ul><h4 id="2-CSMA协议——载波监听多路访问（Carrier-Sense-Multiple-Access）"><a href="#2-CSMA协议——载波监听多路访问（Carrier-Sense-Multiple-Access）" class="headerlink" title="2.CSMA协议——载波监听多路访问（Carrier Sense Multiple Access）"></a>2.CSMA协议——载波监听多路访问（Carrier Sense Multiple Access）</h4><p><strong>CSMA协议是为了降低ALOHA协议的冲突概率而诞生的。</strong></p><p><img src="/2025/03/02/media-access-control/13.png" alt="img"></p><p>和ALOHA协议最主要的区别就是只有在信道是空闲的时候才会发送信息。</p><h5 id="CSMA协议分3类"><a href="#CSMA协议分3类" class="headerlink" title="CSMA协议分3类"></a>CSMA协议分3类</h5><ul><li><strong>1-坚持CSMA协议</strong>：1代表的就是“监听到信道是空闲的时候发送数据的概率为1”。也就是说如果信道忙就一直监听信道，直到发现信道空闲就发送（<strong>但是会造成一旦信道空闲，多个结点同时发送数据，冲突概率大</strong>）</li><li><strong>非坚持CSMA（可以统一一下名称，改为1-非坚持CSMA协议）</strong>：为了解决1-坚持CSMA协议的问题。非坚持会在信道忙的时候放弃监听信道，然后随机一段时间之后再重新监听，以此降低了空闲时信道冲突的概率。（<strong>可能会导致信道闲置，信道利用率低</strong>）</li><li><strong>p-坚持CSMA协议（前两者的折中方案）</strong>：这里的P还是指概率，也就是说在空闲时有p的概率会发送信号，有1-p的概率会推迟到下一个时隙继续监听。</li></ul><h4 id="3-CSMA-CD协议（重点）"><a href="#3-CSMA-CD协议（重点）" class="headerlink" title="3.CSMA&#x2F;CD协议（重点）"></a>3.CSMA&#x2F;CD协议（重点）</h4><ul><li><strong>经常被使用在早期的有线以太网（总线型）。</strong></li><li>有些类似p-坚持CSMA协议。</li><li>CD指的是 collision detection（冲突检测），也就是在载波监听的基础上加上了冲突检测。</li></ul><p><img src="/2025/03/02/media-access-control/14.png" alt="img"></p><h5 id="最小帧长"><a href="#最小帧长" class="headerlink" title="最小帧长"></a>最小帧长</h5><ul><li><strong>传播延迟</strong>：信号在物理介质（如电缆）中传输需要一定的时间，这个时间称为传播延迟。</li><li><strong>冲突检测时间</strong>：节点需要足够的时间来检测冲突。如果帧太短，节点可能在发送完帧之前无法检测到冲突。</li><li><strong>直接丢弃</strong>：由于发生了冲突，所以目的站会直接丢弃这个帧，但是发送方不知道也就不会重传。因此需要规定最小帧长。</li></ul><p>为了确保节点能够在发送完帧之前检测到冲突，帧的发送时间必须至少等于信号在网络上往返传播的最大时间（即 <strong>2 倍传播延迟</strong>）。因此，最小帧长的计算公式为：</p><p><strong>最小帧长&#x3D;数据传输速率×往返传播延迟</strong></p><p>或者这么写</p><p>​                                           <strong>最小帧长&#x3D;（数据传输速率×最大单向传播时延）× 2</strong></p><p>数据传输速率×最大单向传播时延：又称为<strong>时延带宽积（代表）信道中最多可容纳多少bit的长度。</strong></p><h5 id="截断二进制指数退避算法"><a href="#截断二进制指数退避算法" class="headerlink" title="截断二进制指数退避算法"></a>截断二进制指数退避算法</h5><ul><li>每次冲突后，节点计算一个随机退避时间：<code>退避时间=</code><em><code>r</code></em><code>×基本退避时间</code>，其中：<ul><li><em>r</em> 是从 0 到 2^<em>k</em>−1 中随机选择的整数。</li><li><em>k</em>&#x3D;min(冲突次数,10)，即退避指数不超过 10。</li></ul></li></ul><ol><li><strong>截断机制</strong>：<ol><li>如果冲突次数超过 10 次，退避指数 <em>k</em> 保持为 10，不再继续增长。</li></ol></li><li><strong>重试与放弃</strong>：<ol><li>如果重试次数达到最大退避次数（16 次），则放弃发送并报告错误。</li></ol></li></ol><h4 id="4-CSMA-CA协议"><a href="#4-CSMA-CA协议" class="headerlink" title="4.CSMA&#x2F;CA协议"></a>4.CSMA&#x2F;CA协议</h4><p>CA——Collision Avoidance 冲突避免。</p><h5 id="AP——Access-Point接入点"><a href="#AP——Access-Point接入点" class="headerlink" title="AP——Access Point接入点"></a>AP——Access Point接入点</h5><p>也就是WIFI热点。</p><p><img src="/2025/03/02/media-access-control/15.png" alt="img"></p><ul><li>校园网 &#x3D; 路由器 + n个交换机 +n*m个AP</li><li>切换WIFI热点的行为称为漫游</li><li>AP有些教材会称为固定站点，链接的手机是移动的</li></ul><p>为什么不采用CSMA&#x2F;CD协议？</p><ol><li>硬件上难以实现“边听边发，信号检测”功能。因为接受信号的强度远远小于发送信号的强度；无线介质上信号强度变化大。</li><li>存在<strong>“隐藏站”</strong>的问题：并非所有的站点都可以听见对方，所以判断此时信道空闲时不准确的。例如A和B互相看不见，然后同时对AP发信号，会产生冲突（接收数据的结点发生冲突）</li></ol><p>考虑到以上问题引入了CSMA&#x2F;CA协议。</p><p><img src="/2025/03/02/media-access-control/16.png" alt="img"></p><h5 id="协议要点："><a href="#协议要点：" class="headerlink" title="协议要点："></a>协议要点：</h5><ul><li>信道空闲，间隔DIFS，再发送帧。</li><li>若信道不空间，则进行<strong>“随机退避”</strong>（用<strong>二进制指数退避算法</strong>确定一段随机大小的退避时间）</li><li>接受方未收到ACK进行重传使用的也是随机退避算法。</li></ul><h5 id="信道预约功能："><a href="#信道预约功能：" class="headerlink" title="信道预约功能："></a>信道预约功能：</h5><p>主要用于解决“隐蔽站”的问题。</p><p><img src="/2025/03/02/media-access-control/17.png" alt="img"></p><ul><li>某一个结点像 AP 发送 RST 用于预约信道。</li><li>AP 广播 CTS 用于通知所有节点当前AP已经被预约了。这实际上就解决了“隐藏站”冲突的问题，因为AP能够广播CST到所有的站点。假设有一个站点收到了CST，会根据CST帧中的持续时间设置自己的<strong>网络分配向量（NAV）。</strong></li><li>其他无关结点收到CTS后自觉“禁言”一段时间，称为“<strong>虚拟载波监听机制</strong>”（Virtual Carrier Sense Mechanism）</li><li>可以看到同样需要SIFS进行差错处理。</li><li>依旧满足“先听后发，忙则退避”。</li><li>IEEE 802.11会基于数据帧的长度判断是否启用“虚拟载波机制”（因为数据帧如果较小，重传的代价也较小）。</li></ul><h3 id="3-5-3-轮询访问——以令牌控制协议为例"><a href="#3-5-3-轮询访问——以令牌控制协议为例" class="headerlink" title="3.5.3 轮询访问——以令牌控制协议为例"></a>3.5.3 轮询访问——以令牌控制协议为例</h3><p>出现的原因是总线型网络带来的信道冲突问题，通过个结点的轮训访问“令牌控制”保证不冲突。</p><p><img src="/2025/03/02/media-access-control/21.png" alt="img"></p><p><strong>假设#1-&gt;#3发送数据，将令牌帧变为数据帧。</strong></p><p><img src="/2025/03/02/media-access-control/19.png" alt="img"></p><p><img src="/2025/03/02/media-access-control/20.png" alt="img"></p><p><strong>令牌帧和数据帧一样均为单向传播，且传递过程中修改令牌号为对应的结点编号。</strong></p><h4 id="MAU构建令牌环网"><a href="#MAU构建令牌环网" class="headerlink" title="MAU构建令牌环网"></a>MAU构建令牌环网</h4><p><img src="/2025/03/02/media-access-control/22.png" alt="img"></p><p><img src="/2025/03/02/media-access-control/23.png" alt="img"></p><h3 id="本章疑问"><a href="#本章疑问" class="headerlink" title="本章疑问"></a>本章疑问</h3><h4 id="信道划分与随机访问控制的特点？"><a href="#信道划分与随机访问控制的特点？" class="headerlink" title="信道划分与随机访问控制的特点？"></a>信道划分与随机访问控制的特点？</h4><h4 id="为什么最小帧长-（数据传输速率×最大单向传播时延）×-2-？"><a href="#为什么最小帧长-（数据传输速率×最大单向传播时延）×-2-？" class="headerlink" title="为什么最小帧长 &#x3D;（数据传输速率×最大单向传播时延）× 2 ？"></a>为什么最小帧长 &#x3D;（数据传输速率×最大单向传播时延）× 2 ？</h4><p>之所以要乘以2是因为检测到冲突之后还要返回给发送站也需要时间。所以这还涉及到一个点就是CSMA&#x2F;CD一般服务于半双工网络，如果是单向的网络的话无法返回冲突信息。</p><h4 id="SIFS存在的作用是什么？"><a href="#SIFS存在的作用是什么？" class="headerlink" title="SIFS存在的作用是什么？"></a>SIFS存在的作用是什么？</h4><p>IEEE 802.11定义SIFS（short inter frame gap 最短帧间间隔）留一段较短的时间间隔进行差错检验。</p><p>回顾一下其他在CSMA&#x2F;CA中的时间间:<strong>DIFS&gt;PIFS&gt;SIFS。</strong></p><h4 id="DIFS存在的作用是什么呢？"><a href="#DIFS存在的作用是什么呢？" class="headerlink" title="DIFS存在的作用是什么呢？"></a>DIFS存在的作用是什么呢？</h4><p>用于准备接下来要一口气发送的数据。</p><h4 id="CSMA-CA中有最小帧的概念吗？"><a href="#CSMA-CA中有最小帧的概念吗？" class="headerlink" title="CSMA&#x2F;CA中有最小帧的概念吗？"></a>CSMA&#x2F;CA中有最小帧的概念吗？</h4><p>没有。CSMA&#x2F;CA 协议通过主动预约信道和确认机制规避冲突（直接AP广播CST保证信道被一个结点占有），无需依赖最小帧长；而 CSMA&#x2F;CD 小于最小帧长度的帧的碰撞难以被检测出来。</p><h4 id="什么是网络分配向量（NAV）？"><a href="#什么是网络分配向量（NAV）？" class="headerlink" title="什么是网络分配向量（NAV）？"></a>什么是网络分配向量（NAV）？</h4><p>在虚拟载波监听机制中，站点收到CST帧后，NAV会根据CST帧中的持续时间的值来模拟物理载波监听，从而避免数据包冲突。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划（分组背包）</title>
      <link href="/2025/02/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%EF%BC%89/"/>
      <url>/2025/02/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划（分组背包）"><a href="#动态规划（分组背包）" class="headerlink" title="动态规划（分组背包）"></a>动态规划（分组背包）</h1><p>分组问题是动态规划里面常见的问题，分组背包就是其中的一种。</p><p>个人感觉分组背包和01背包或者完全背包不同，他没有很多的样板题，更多的还是根据题目的意思写二维的dp数组，最后在尝试能不能化成一维的。</p><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>单独讨论这个是因为分组背包问题往往和前缀和联系起来，这里注意一下前缀和的写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span>[] prefixNum = <span class="keyword">new</span> <span class="title class_">double</span>[nums.length + <span class="number">1</span>];</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">      prefixNum[i + <span class="number">1</span>] = prefixNum[i] + nums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>首先明确三个要点：</strong></p><ul><li><strong>前缀和的大小一般要+1，如这里的</strong><code> int[] prefixNum = new double[nums.length + 1];</code><strong>如果懒得记的话直接多加一点也可以，防止后面因为前缀和下标越界导致的问题。</strong></li><li><strong>求<code>nums</code>数组中前i个数(即[0,i-1])的总和为<code>prefixNum(i)</code>。</strong></li><li><strong>如果我想求<code>nums</code>数组中下标从i到j的和，那就是<code>prefixNum[j]-prefixNum[i-1]</code>,因为<code>nums[0]</code>对应的是下标<code>prefixNum[1]</code>。</strong></li></ul><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><p>然后来看以下这些题：</p><h4 id="2218-从栈中取出k个硬币的最大面值和-腾讯后台一面"><a href="#2218-从栈中取出k个硬币的最大面值和-腾讯后台一面" class="headerlink" title="2218.从栈中取出k个硬币的最大面值和(腾讯后台一面)"></a>2218.从栈中取出k个硬币的最大面值和(腾讯后台一面)</h4><p><a href="https://leetcode.cn/problems/maximum-value-of-k-coins-from-piles/">https://leetcode.cn/problems/maximum-value-of-k-coins-from-piles/</a></p><p>一张桌子上总共有 <code>n</code> 个硬币 <strong>栈</strong> 。每个栈有 <strong>正整数</strong> 个带面值的硬币。</p><p>每一次操作中，你可以从任意一个栈的 <strong>顶部</strong> 取出 1 个硬币，从栈中移除它，并放入你的钱包里。</p><p>给你一个列表 <code>piles</code> ，其中 <code>piles[i]</code> 是一个整数数组，分别表示第 <code>i</code> 个栈里 <strong>从顶到底</strong> 的硬币面值。同时给你一个正整数 <code>k</code> ，请你返回在 <strong>恰好</strong> 进行 <code>k</code> 次操作的前提下，你钱包里硬币面值之和 <strong>最大为多少</strong> 。</p><p><img src="https://assets.leetcode.com/uploads/2019/11/09/e1.png" alt="示例图片"></p><hr><p>思路：</p><ul><li>观察题目发现求的是<strong>最大为多少，</strong>所以感觉递推公式中<strong>要遇到<code>Math.max</code>操作。</strong>如果说是求多少种方法，那一般就是通过加减法来计算。</li><li>要求返回对于n个栈一共取k次求得的值，开一个二维dp[i][j]，表示前i个栈中取j个值得到的最大值，这样最后就直接返回<code>dp[piles.size()][k]</code>。</li><li>判断递推公式。之前觉得可能会用到<code>Math.max</code>操作<ul><li><code>dp[i][j] = Math.max(dp[i][j],dp[i-1][j-k]+prefoxNum[k])</code>。</li><li>还有特殊情况是这个栈中一个都不取值<code> dp[i][j] = dp[i-1][j]</code>.</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValueOfCoins</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; piles, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> piles.size();</span><br><span class="line">        <span class="comment">// 在前i个栈中取j次获得的最大值，最后返回dp[m][k]</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; pile = piles.get(i - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">pileSize</span> <span class="operator">=</span> pile.size();</span><br><span class="line">            <span class="comment">// 求前缀和,这个应该是从下标1开始，e.g.因为转态转移方程中-1的话前缀和对应的也只是一个数而不是两个数。</span></span><br><span class="line">            <span class="type">int</span>[] prefixNum = <span class="keyword">new</span> <span class="title class_">int</span>[pileSize + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; t &lt; pileSize; t++) &#123;</span><br><span class="line">                prefixNum[t + <span class="number">1</span>] = prefixNum[t] + pile.get(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                <span class="comment">//什么都不取</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>; p &lt;= Math.min(j, pileSize); p++) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - p] + prefixNum[p]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1155-投甩子等同于目标和的方法数"><a href="#1155-投甩子等同于目标和的方法数" class="headerlink" title="1155.投甩子等同于目标和的方法数"></a>1155.投甩子等同于目标和的方法数</h4><p><a href="https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/">https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/</a></p><p>这里有 <code>n</code> 个一样的骰子，每个骰子上都有 <code>k</code> 个面，分别标号为 <code>1</code> 到 <code>k</code> 。</p><p>给定三个整数 <code>n</code>、<code>k</code> 和 <code>target</code>，请返回投掷骰子的所有可能得到的结果（共有 <code>k(n)</code> 种方式），使得骰子面朝上的数字总和等于 <code>target</code>。</p><ul><li>由于答案可能很大，你需要对 <code>10(9)7</code> <strong>取模</strong>。</li></ul><p><strong>示例 1：</strong></p><p><strong>输入：</strong>n &#x3D; 1, k &#x3D; 6, target &#x3D; 3 <strong>输出：</strong>1 <strong>解释：</strong>你掷了一个有 6 个面的骰子。 得到总和为 3 的结果的方式只有一种。</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>n &#x3D; 2, k &#x3D; 6, target &#x3D; 7 <strong>输出：</strong>6 <strong>解释：</strong>你掷了两个骰子，每个骰子有 6 个面。 有 6 种方式得到总和为 7 的结果: 1+6, 2+5, 3+4, 4+3, 5+2, 6+1。</p><p><strong>示例 3：</strong></p><ul><li><strong>输入：</strong>n &#x3D; 30, k &#x3D; 30, target &#x3D; 500 <strong>输出：</strong>222616187 <strong>解释：</strong>返回的结果必须对 10(9)7 取模。</li></ul><hr><p>思路：</p><ul><li>甩n个骰子，分组背包（骰子相当于背包）。</li><li>题目问的是有多少种法，应该不会出现Math.max的情况。</li><li>题目应该返回投n次总和为target的次数，因此dp就设置为dp[i][j]投i次综合为j的次数，最后返回<code>dp[n][target]</code>即可。</li><li>最后判断递推公式<ul><li>很明显，由于每一个骰子都有<code>[1,k]</code>个值，所以<code>dp[i][j]=dp[i-1][j-n] (m=1~k)</code>的总和（当然前提是j&gt;&#x3D;n）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numRollsToTarget</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// dp[i][j]，投前i个骰子总和为j的个数</span></span><br><span class="line">        <span class="comment">// dp[i][j]= max(dp[i][j],dp[i-1][j-t])+1;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= target; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">1</span>; t &lt;= k; t++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j &gt;= t)</span><br><span class="line">                        dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][j - t]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="813-最大平均和的分组"><a href="#813-最大平均和的分组" class="headerlink" title="813.最大平均和的分组"></a>813.最大平均和的分组</h4><p><a href="https://leetcode.cn/problems/largest-sum-of-averages/description/">https://leetcode.cn/problems/largest-sum-of-averages/description/</a></p><p>给定数组 <code>nums</code> 和一个整数 <code>k</code> 。我们将给定的数组 <code>nums</code> 分成 <strong>最多</strong> <code>k</code> 个非空子数组，且数组内部是连续的。 <strong>分数</strong> 由每个子数组内的平均值的总和构成。</p><p>注意我们必须使用 <code>nums</code> 数组中的每一个数进行分组，并且分数不一定需要是整数。</p><p>返回我们所能得到的最大 <strong>分数</strong> 是多少。答案误差在 <code>10(-6)</code> 内被视为是正确的。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> nums &#x3D; [9,1,2,3,9], k &#x3D; 3 <strong>输出:</strong> 20.00000 <strong>解释:</strong>  nums 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) &#x2F; 3 + 9 &#x3D; 20.  我们也可以把 nums 分成[9, 1], [2], [3, 9].  这样的分组得到的分数为 5 + 2 + 6 &#x3D; 13, 但不是最大值.</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 4 <strong>输出:</strong> 20.50000</p><hr><p>思路：</p><ul><li>题目要求返回最大的分数，预计递归表达式中存在<code>Math.max</code>。</li><li>题目要求经过最多k次划分，最后返回所能得到的最大分数是多少。因此设dp[i][j]为前i个数经过j次划分之后所能达到的最大数是多少。</li><li>然后求递推公式：<ul><li>对于dp[i][j]，它应该就经过j-1次划分的数组递归而来，但是我们不知道这次划分的位置(我们只知道它的位置应该位于(j-1.i))，因此这一步同样需要一个循环。因此递推公式如下。</li><li><code>dp[i][j] = Math.max(dp[i][j],dp[t][j-1]+(prefixNum[i]-prefix[t])/(i-t))</code></li><li>由于不能进行空划分(即出现<code>dp[i][0]</code>的情况)，所以考虑特殊情况 j&#x3D;&#x3D;1 此时应该是<code>prefixNum(i)/i</code>。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">double</span> <span class="title">largestSumOfAverages</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 划分份数越多，平均值之和越大，所以应该要尽可能的分完k个数</span></span><br><span class="line">        <span class="comment">// dp[i][j] 在[0,i-1]划分j个组件的最大平均值和，返回dp[nums.length][k]</span></span><br><span class="line">        <span class="comment">// dp[i][j] = max(dp[k][j-1])+剩下的平均和i-k(用前缀和来求)</span></span><br><span class="line">        <span class="type">double</span>[][] dp = <span class="keyword">new</span> <span class="type">double</span>[nums.length + <span class="number">1</span>][k + <span class="number">1</span>];</span><br><span class="line">        <span class="type">double</span>[] prefixNum = <span class="keyword">new</span> <span class="type">double</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            prefixNum[i + <span class="number">1</span>] = prefixNum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= Math.<span class="built_in">min</span>(i, k); j++) &#123;</span><br><span class="line">                <span class="comment">//划分出来的子数组不能是空集，即dp[i][j]中的不能出现为0的情况，所以这里要j==1进行讨论</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">1</span>)</span><br><span class="line">                    dp[i][j] = prefixNum[i] / i;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> t = j - <span class="number">1</span>; t &lt; i; t++) &#123;</span><br><span class="line">                        dp[i][j] = Math.<span class="built_in">max</span>(dp[i][j], dp[t][j - <span class="number">1</span>] + (prefixNum[i] - prefixNum[t]) / (i - t));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-2操作系统的发展流程</title>
      <link href="/2025/02/20/1-2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E6%B5%81%E7%A8%8B/"/>
      <url>/2025/02/20/1-2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-2-操作系统发展历程"><a href="#1-2-操作系统发展历程" class="headerlink" title="1.2 操作系统发展历程"></a>1.2 操作系统发展历程</h2><h3 id="1-2-1-手工操作阶段（无操作系统）"><a href="#1-2-1-手工操作阶段（无操作系统）" class="headerlink" title="1.2.1 手工操作阶段（无操作系统）"></a>1.2.1 手工操作阶段（无操作系统）</h3><p>计算机所有的工作都需要人工干预，如装入、运行、输出等。</p><p>缺点：</p><ul><li>用户独占全机，不会出现资源被其他用户占用而等待（因为独占，只能运行一个），但是资源利用率低。</li><li>CPU等待手工操作，CPU利用不充分</li></ul><h3 id="1-2-2-批处理阶段（操作系统出现）"><a href="#1-2-2-批处理阶段（操作系统出现）" class="headerlink" title="1.2.2 批处理阶段（操作系统出现）"></a>1.2.2 批处理阶段（操作系统出现）</h3><ol><li>单道批处理<ol><li><p>将一批作业机脱机的方式输入磁带，并使用系统中的Mointor控制使得这批作业可以一个接一个地连续处理。</p></li><li><p>特点：</p></li><li><p>自动性。mointor监督逐个运行</p></li><li><p>顺序性。fcfs</p></li><li><p>单道性。内存中只有一道程序运行。</p></li><li><p>由弹道性可知单道批处理会造成“高速的cpu和低速的IO”。因此为了提升IO的效率，设计了躲到批处理。</p></li></ol></li><li>多道批处理</li></ol><p>所有的作业首先在外存上排成一个队列，作业调度在按照一定的算法从后备队列中选择若干作业调入程序。</p><p>在管理程序安排下交替运行。</p><p>特点：宏观上<strong>并行</strong>、微观上<strong>串行</strong>。</p><ul><li><strong>多道</strong>：内存中同时存放多道相互独立的程序（这里与单道系统对比，单道系统内存中只有一道程序在运行）。</li><li><strong>宏观上并行</strong>：因为进入系统的多道程序都在并行处理，尽管它们都未执行完毕。</li><li><strong>微观上串行</strong>：内存中的多道程序轮流占用CPU，交替执行，即使系统中有多个作业，它们并不会真正并行运行，而是被串行执行。</li></ul><p>要实现多道批处理系统，需要解决的问题：</p><ol><li><p><strong>如何分配处理器（CPU）</strong>：</p><ul><li>需要选择合适的调度算法，常见的调度算法有FCFS（先来先服务）、SJF（最短作业优先）、高响应比优先等。这些算法决定了多个作业如何共享CPU时间。</li></ul></li><li><p><strong>多道处理程序内存分配问题</strong>：</p><ul><li>由于多个程序需要在内存中并行运行，因此必须解决内存分配的问题。常见的方法有分页和分段技术，以确保每个作业可以独立运行。</li></ul></li><li><p><strong>IO设备如何分配</strong>：</p><ul><li>IO设备的分配可以是独占式的或共享式的，这取决于任务之间如何协调使用这些资源。合理的分配可以减少空闲时间，提高资源利用率。</li></ul></li><li><p><strong>如何组织并存放大量程序和数据，保证安全性与一致性</strong>：</p><ul><li>需要采取合理的策略来组织内存和磁盘中的数据。操作系统必须确保数据的安全性与一致性，避免不同程序之间的干扰。</li></ul></li></ol><p>优点：</p><ol><li><p><strong>资源利用率高</strong>：</p><ul><li>多道批处理系统可以同时利用CPU和IO设备，减少资源的空闲时间，提高资源的利用效率。</li></ul></li><li><p><strong>系统吞吐量大</strong>：</p><ul><li>通过同时处理多个作业，系统可以在单位时间内完成更多的任务，从而提高吞吐量。</li></ul></li></ol><p>缺点：</p><ol><li><p><strong>用户响应时间较长</strong>：</p><ul><li>由于作业需要排队等待执行，可能需要较长时间才能得到处理结果。因此，用户的响应时间可能较长。</li></ul></li><li><p><strong>不提供人机交互能力</strong>：</p><ul><li>多道批处理系统通常用于后台任务处理，不支持实时的用户交互，因此不适合需要快速反馈的任务。</li></ul></li></ol><h3 id="1-2-3-分时操作系统"><a href="#1-2-3-分时操作系统" class="headerlink" title="1.2.3 分时操作系统"></a>1.2.3 分时操作系统</h3><p>分时操作系统是一种允许多个用户通过终端同时使用计算机资源的操作系统。其核心特点是通过<strong>时间片轮转</strong>的方式，将处理器时间分配给多个用户或任务，从而实现多用户共享系统资源的目标。在分时操作系统中，计算机的CPU时间被划分为若干个时间片，每个任务在各自的时间片内独占CPU。</p><p>特点：</p><ol><li><strong>同时性</strong> 多个用户可以同时使用系统资源。每个用户通过终端与系统交互，系统通过快速切换任务的方式，让每个用户感觉自己在独占系统。</li><li><strong>交互性</strong> 用户可以通过终端直接与系统进行交互，输入命令并立即获得响应。这种交互性使得分时操作系统非常适合需要实时操作的应用场景。</li><li><strong>独立性</strong> 每个用户的操作是独立的，彼此之间不会互相干扰。系统通过隔离机制（如内存保护和权限控制）确保用户任务的独立性。</li><li><strong>及时性</strong> 系统能够在较短的时间内响应用户请求。通过合理的时间片分配和调度算法，分时操作系统能够保证用户任务的及时响应。</li></ol><p>虽然分时操作系统较好的解决了人机交互问题，但是有些时候要求做出反映的时间要比时间片更短。——实时操作系统。</p><h3 id="1-2-4-实时操作系统"><a href="#1-2-4-实时操作系统" class="headerlink" title="1.2.4 实时操作系统"></a>1.2.4 实时操作系统</h3><table><thead><tr><th>特性</th><th>硬实时操作系统</th><th>软实时操作系统</th></tr></thead><tbody><tr><td>时间限制</td><td>严格，必须满足</td><td>宽松，尽量满足</td></tr><tr><td>后果</td><td>超时会导致系统失败或严重后果</td><td>超时不会导致系统失败</td></tr><tr><td>确定性</td><td>高，响应时间可预测</td><td>较低，响应时间有一定波动</td></tr><tr><td>应用场景</td><td>航空航天、工业控制、医疗设备</td><td>多媒体、网络通信、交互式系统</td></tr><tr><td>示例</td><td>VxWorks、QNX</td><td>Windows、Linux（实时补丁）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何批量插入数据并实现优雅暂停？</title>
      <link href="/2025/02/17/%E5%A6%82%E4%BD%95%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%BC%98%E9%9B%85%E6%9A%82%E5%81%9C%EF%BC%9F/"/>
      <url>/2025/02/17/%E5%A6%82%E4%BD%95%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%BC%98%E9%9B%85%E6%9A%82%E5%81%9C%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="如何批量插入数据并实现优雅暂停？"><a href="#如何批量插入数据并实现优雅暂停？" class="headerlink" title="如何批量插入数据并实现优雅暂停？"></a>如何批量插入数据并实现优雅暂停？</h2><p>要实现“当前批量插入循环插入完毕之后终止，不再执行之后的循环”，同时确保线程池状态变为 <code>SHUTDOWN</code> 后不再接收新任务，但已提交的任务会执行完毕，可以通过以下步骤实现：</p><h3 id="1-配置线程池"><a href="#1-配置线程池" class="headerlink" title="1. 配置线程池"></a>1. 配置线程池</h3><p>配置一个线程池，并确保它支持优雅关闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;batchInsertThreadPool&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">batchInsertThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>); <span class="comment">// 核心线程数</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">20</span>);  <span class="comment">// 最大线程数</span></span><br><span class="line">        executor.setQueueCapacity(<span class="number">100</span>); <span class="comment">// 队列容量</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;BatchInsertThread-&quot;</span>); <span class="comment">// 线程名前缀</span></span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="literal">true</span>); <span class="comment">// 关闭时等待任务完成</span></span><br><span class="line">        executor.setAwaitTerminationSeconds(<span class="number">60</span>); <span class="comment">// 等待任务完成的最大时间</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-实现批量插入逻辑"><a href="#2-实现批量插入逻辑" class="headerlink" title="2. 实现批量插入逻辑"></a>2. 实现批量插入逻辑</h3><p>编写批量插入的逻辑，并在插入完成后检查线程池状态，决定是否继续插入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchInsertService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor batchInsertThreadPool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量插入数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchInsert</span><span class="params">(List&lt;Data&gt; dataList)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO your_table (column1, column2) VALUES (?, ?)&quot;</span>;</span><br><span class="line">        jdbcTemplate.batchUpdate(sql, dataList, dataList.size(), (ps, data) -&gt; &#123;</span><br><span class="line">            ps.setString(<span class="number">1</span>, data.getColumn1());</span><br><span class="line">            ps.setString(<span class="number">2</span>, data.getColumn2());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查线程池是否已关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isThreadPoolShutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> batchInsertThreadPool.getThreadPoolExecutor().isShutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-控制批量插入循环"><a href="#3-控制批量插入循环" class="headerlink" title="3. 控制批量插入循环"></a>3. 控制批量插入循环</h3><p>在批量插入的循环中，每次插入后检查线程池状态。如果线程池已关闭，则退出循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BatchInsertService batchInsertService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor batchInsertThreadPool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量插入数据循环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchInsertLoop</span><span class="params">(List&lt;List&lt;Data&gt;&gt; dataBatches)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Data&gt; batch : dataBatches) &#123;</span><br><span class="line">            <span class="comment">// 检查线程池是否已关闭</span></span><br><span class="line">            <span class="keyword">if</span> (batchInsertThreadPool.getThreadPoolExecutor().isShutdown()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程池已关闭，停止插入任务。&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 提交批量插入任务</span></span><br><span class="line">            batchInsertThreadPool.execute(() -&gt; &#123;</span><br><span class="line">                batchInsertService.batchInsert(batch);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-实现优雅关闭"><a href="#4-实现优雅关闭" class="headerlink" title="4. 实现优雅关闭"></a>4. 实现优雅关闭</h3><p>编写一个方法，用于关闭线程池并等待任务完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolShutdownService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor batchInsertThreadPool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优雅关闭线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdownThreadPoolGracefully</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一阶段：停止接受新任务</span></span><br><span class="line">        batchInsertThreadPool.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二阶段：等待已提交的任务完成</span></span><br><span class="line">        <span class="keyword">while</span> (!batchInsertThreadPool.getThreadPoolExecutor().isTerminated()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 每隔100ms检查一次</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;线程池已优雅关闭，所有任务已完成。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-触发优雅关闭"><a href="#5-触发优雅关闭" class="headerlink" title="5. 触发优雅关闭"></a>5. 触发优雅关闭</h3><p>通过REST接口或其他方式触发线程池的优雅关闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/thread-pool&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolShutdownService threadPoolShutdownService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/shutdown&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">shutdownThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        threadPoolShutdownService.shutdownThreadPoolGracefully();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池正在优雅关闭...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-测试与验证"><a href="#6-测试与验证" class="headerlink" title="6. 测试与验证"></a>6. 测试与验证</h3><p>启动Spring应用，调用批量插入接口和关闭接口，观察线程池的行为。</p><ul><li><strong>批量插入接口</strong>：提交多个批量插入任务。</li><li><strong>关闭接口</strong>：调用关闭接口后，线程池会停止接受新任务，但会等待已提交的任务完成。</li></ul><h3 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h3><ol><li><strong>线程池状态检查</strong>：在批量插入循环中，每次插入后检查线程池状态（<code>isShutdown()</code>），如果线程池已关闭，则退出循环。</li><li><strong>优雅关闭</strong>：通过<code>shutdown()</code>方法停止接受新任务，并通过<code>isTerminated()</code>等待任务完成。</li><li><strong>Spring继续运行</strong>：线程池关闭后，Spring应用的其他部分仍然可以正常运行。</li></ol><h2 id="spring和servlet之间有从属关系吗？"><a href="#spring和servlet之间有从属关系吗？" class="headerlink" title="spring和servlet之间有从属关系吗？"></a>spring和servlet之间有从属关系吗？</h2><p>你的问题涉及 <strong>Spring 容器</strong>、<strong>Tomcat线程池</strong>以及 <strong>Spring 管理的 <code>ThreadPoolTaskExecutor</code></strong> 之间的关系。我们一步步解析它们的 <strong>从属结构</strong> 和 <strong>线程生命周期</strong>。</p><h3 id="1-Spring-和-Tomcat-线程池的关系"><a href="#1-Spring-和-Tomcat-线程池的关系" class="headerlink" title="1. Spring 和 Tomcat 线程池的关系"></a><strong>1. Spring 和</strong> <strong>Tomcat</strong> <strong>线程池</strong>的关系</h3><p>Spring Web 应用 <strong>运行在</strong> <strong>Tomcat</strong> <strong>之上</strong>，但它和 Tomcat 的线程管理是 <strong>两个独立的体系</strong>。</p><h4 id="1-1-Tomcat-线程池"><a href="#1-1-Tomcat-线程池" class="headerlink" title="1.1 Tomcat 线程池"></a><strong>1.1</strong> <strong>Tomcat</strong> <strong>线程池</strong></h4><ul><li><strong>Tomcat</strong> <strong>是 HTTP 服务器</strong>，它负责接收请求并分配线程来处理。</li><li>Tomcat 的 <strong>线程池</strong>（通常是 <code>org.apache.tomcat.util.threads.ThreadPoolExecutor</code>）维护着 <code>http-nio-8080-exec-</code> 线程，它们 <strong>执行</strong> <strong>Spring MVC</strong> <strong>Controller</strong> <strong>方法</strong>。</li><li><strong>生命周期</strong>：Tomcat 线程池在 <strong>Tomcat 启动时创建</strong>，在 <strong>Tomcat 关闭时销毁</strong>。</li></ul><h4 id="1-2-Spring-容器和-Bean"><a href="#1-2-Spring-容器和-Bean" class="headerlink" title="1.2 Spring 容器和 Bean"></a><strong>1.2 Spring 容器和 Bean</strong></h4><ul><li>Spring 在 Tomcat 启动时 <strong>加载自己的容器</strong>（<code>ApplicationContext</code>），实例化所有 <strong>单例</strong> <strong>Bean</strong>，包括 <code>ThreadPoolTaskExecutor</code>。</li><li>这些 <strong>Spring Bean 在整个应用中共享</strong>，它们不依赖单个 HTTP 请求，而是<strong>全局管理</strong>的。</li></ul><h4 id="1-3-ThreadPoolTaskExecutor-线程池"><a href="#1-3-ThreadPoolTaskExecutor-线程池" class="headerlink" title="1.3 ThreadPoolTaskExecutor 线程池"></a><strong>1.3</strong> <strong><code>ThreadPoolTaskExecutor</code></strong> <strong>线程池</strong></h4><ul><li><strong><code>ThreadPoolTaskExecutor</code></strong> <strong>是 Spring 维护的****线程池</strong>，它独立于 Tomcat 线程池。</li><li>这个线程池的 <strong>生命周期由 Spring 容器管理</strong>，在 Spring 启动时创建，在 Spring 关闭时销毁。</li><li>当 <code>Controller</code> 里提交任务到 <code>ThreadPoolTaskExecutor</code>，这个任务会在 <strong>Spring</strong> <strong>线程池</strong> 里执行，而不是在 Tomcat 线程池里。</li></ul><h3 id="2-为什么-ThreadPoolTaskExecutor-可以脱离-Tomcat-线程？"><a href="#2-为什么-ThreadPoolTaskExecutor-可以脱离-Tomcat-线程？" class="headerlink" title="2. 为什么 ThreadPoolTaskExecutor 可以脱离 Tomcat 线程？"></a><strong>2. 为什么</strong> <strong><code>ThreadPoolTaskExecutor</code></strong> <strong>可以脱离</strong> <strong>Tomcat</strong> <strong>线程？</strong></h3><p>你提到：</p><blockquote><p><strong>在一个线程中</strong> **<code>new ThreadA()</code><strong>，再在另一个线程</strong><code>new ThreadB()</code>**，它们应该是相互隔离的，为什么 <strong><code>ThreadPoolTaskExecutor</code></strong> <strong>不是这样？</strong></p></blockquote><p>答案是：</p><ul><li><strong>Spring</strong> <strong>线程池</strong>是 <strong>“全局”</strong> <strong>的</strong>，它不属于单个 Tomcat 线程，而是由 <strong>Spring 容器管理</strong>，所有 Tomcat 线程都可以访问它。</li><li><strong>Tomcat</strong> <strong>线程只是 “请求处理线程”，并不掌控</strong> **<code>ThreadPoolTaskExecutor</code>**。</li><li><strong>当</strong> <strong>Tomcat</strong> <strong>线程调用</strong> <strong><code>batchInsertThreadPool.execute()</code><strong>，它只是把任务提交给</strong>线程池</strong>，然后它自己会立即返回，而 <code>ThreadPoolTaskExecutor</code> 负责在自己的线程中执行任务。</li></ul><h3 id="3-从属关系（Spring-vs-Tomcat-vs-线程池）"><a href="#3-从属关系（Spring-vs-Tomcat-vs-线程池）" class="headerlink" title="3. 从属关系（Spring vs. Tomcat vs. 线程池）"></a><strong>3. 从属关系（Spring vs.</strong> <strong>Tomcat</strong> <strong>vs.</strong> <strong>线程池</strong>）</h3><p>可以用下图表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Tomcat 服务器（管理 HTTP 线程池）</span><br><span class="line">│</span><br><span class="line">├── Tomcat 线程池（http-nio-8080-exec-1, 2, 3, ...）</span><br><span class="line">│   ├── 处理 HTTP 请求（调用 Spring Controller）</span><br><span class="line">│   ├── 在 Controller 里提交任务给 Spring 线程池</span><br><span class="line">│</span><br><span class="line">└── Spring 容器（ApplicationContext）</span><br><span class="line">    ├── 管理 Spring Bean（包括 ThreadPoolTaskExecutor）</span><br><span class="line">    ├── 管理业务逻辑（Service、Repository）</span><br><span class="line">    ├── 启动 ThreadPoolTaskExecutor（独立于 Tomcat）</span><br><span class="line">    │   ├── 线程：BatchInsertThread-1, 2, 3, ...</span><br><span class="line">    │   ├── 运行异步任务</span><br></pre></td></tr></table></figure><h3 id="4-示例：Tomcat-线程如何与-ThreadPoolTaskExecutor-交互"><a href="#4-示例：Tomcat-线程如何与-ThreadPoolTaskExecutor-交互" class="headerlink" title="4. 示例：Tomcat 线程如何与 ThreadPoolTaskExecutor 交互"></a><strong>4. 示例：</strong>Tomcat <strong>线程如何与</strong> <strong><code>ThreadPoolTaskExecutor</code></strong> <strong>交互</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor batchInsertThreadPool;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/submitTask&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">submitTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        batchInsertThreadPool.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行任务的线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;任务已提交&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>请求</strong> <strong><code>/test/submitTask</code></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080/test/submitTask</span><br></pre></td></tr></table></figure><p><strong>控制台输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请求线程：http-nio-8080-exec-1</span><br><span class="line">执行任务的线程：BatchInsertThread-1</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>Tomcat 线程 <code>http-nio-8080-exec-1</code> 负责处理 HTTP 请求，执行 <code>Controller</code> 代码。</li><li><code>Controller</code> 把任务提交给 <code>ThreadPoolTaskExecutor</code>，然后立即返回。</li><li><code>ThreadPoolTaskExecutor</code> <strong>在自己的线程</strong> <code>BatchInsertThread-1</code> 里执行任务，<strong>不再依赖</strong> <strong>Tomcat</strong> <strong>线程</strong>。</li></ul><h3 id="5-为什么-ThreadPoolTaskExecutor-不会受到-Tomcat-线程的限制？"><a href="#5-为什么-ThreadPoolTaskExecutor-不会受到-Tomcat-线程的限制？" class="headerlink" title="5. 为什么 ThreadPoolTaskExecutor 不会受到 Tomcat 线程的限制？"></a><strong>5. 为什么</strong> <strong><code>ThreadPoolTaskExecutor</code></strong> <strong>不会受到</strong> <strong>Tomcat</strong> <strong>线程的限制？</strong></h3><ul><li><strong>线程池</strong>是 Spring 容器管理的全局 Bean，所有 Tomcat 线程都可以访问它。</li><li><strong>任务是提交给线程池，而不是运行在Tomcat 线程里</strong>，所以 Tomcat 线程和 <code>ThreadPoolTaskExecutor</code> 线程是分开的。</li><li><strong>Spring 线程池的生命周期不依赖于单个 HTTP 请求</strong>，即使 Tomcat 线程结束，Spring 线程池仍然可以运行。</li></ul><h3 id="6-线程池-shutdown-为什么能影响所有任务？"><a href="#6-线程池-shutdown-为什么能影响所有任务？" class="headerlink" title="6. 线程池 shutdown() 为什么能影响所有任务？"></a><strong>6. 线程池</strong> <strong><code>shutdown()</code></strong> <strong>为什么能影响所有任务？</strong></h3><blockquote><p><strong>不同</strong> <strong>REST API</strong> <strong>的线程为什么可以互相控制</strong> **<code>ThreadPoolTaskExecutor</code>**？</p></blockquote><p>原因是：</p><ol><li><strong>所有请求共享同一个</strong> <strong><code>ThreadPoolTaskExecutor</code></strong> <strong>实例</strong>（Spring 容器管理的单例 Bean）。</li><li><strong><code>shutdown()</code></strong> <strong>作用于整个线程池</strong>，而不是单个任务，所以不管是哪个请求触发的 <code>shutdown()</code>，它都会让整个线程池停止。</li><li><strong>结论</strong></li></ol><table><thead><tr><th>组件</th><th>作用</th><th>线程管理方式</th></tr></thead><tbody><tr><td>Tomcat 线程池</td><td>处理 HTTP 请求（Controller）</td><td>Tomcat 管理</td></tr><tr><td>Spring 容器</td><td>管理 Bean 和 ThreadPoolTaskExecutor</td><td>Spring 管理</td></tr><tr><td>ThreadPoolTaskExecutor</td><td>处理异步任务</td><td>Spring 管理</td></tr></tbody></table><p>✅ <strong>Tomcat</strong> <strong>线程和</strong> <strong><code>ThreadPoolTaskExecutor</code></strong> <strong>线程是完全独立的</strong>，但它们可以互相交互。 </p><p>✅ <strong>所有 HTTP 请求共享</strong> **<code>ThreadPoolTaskExecutor</code>**，所以 <code>shutdown()</code> 会影响所有提交的任务。</p><h2 id="多个servlet线程与spring的单例模式之间会造成线程冲突吗？"><a href="#多个servlet线程与spring的单例模式之间会造成线程冲突吗？" class="headerlink" title="多个servlet线程与spring的单例模式之间会造成线程冲突吗？"></a>多个servlet线程与spring的单例模式之间会造成线程冲突吗？</h2><p>不会，<strong>除非</strong> <strong><code>OrderService</code></strong> <strong>里有共享的可变状态（如全局变量）</strong>，否则不会发生线程冲突。</p><h3 id="1-Spring-单例-Bean-并发访问的本质"><a href="#1-Spring-单例-Bean-并发访问的本质" class="headerlink" title="1. Spring 单例 Bean 并发访问的本质"></a><strong>1. Spring</strong> <strong>单例</strong> <strong>Bean 并发访问的本质</strong></h3><h4 id="1-每个请求的线程是独立的"><a href="#1-每个请求的线程是独立的" class="headerlink" title="(1) 每个请求的线程是独立的"></a><strong>(1) 每个请求的线程是独立的</strong></h4><p>Spring 的 <code>@Service</code> Bean 默认是<strong>单例模式</strong>，但<strong>它的方法是被不同的</strong> <strong>Tomcat</strong> <strong>线程调用的</strong>，而每个 Tomcat 线程都有自己的<strong>独立调用栈</strong>，不会共享方法里的局部变量。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在处理订单：&quot;</span> + userId);</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 这是一个局部变量，每个线程都有自己的副本</span></span><br><span class="line">        total++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 订单完成，total = &quot;</span> + total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 5 个用户同时访问这个方法，Tomcat 可能会分配 5 个线程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http-nio-8080-exec-1 正在处理订单：A</span><br><span class="line">http-nio-8080-exec-2 正在处理订单：B</span><br><span class="line">http-nio-8080-exec-3 正在处理订单：C</span><br><span class="line">http-nio-8080-exec-4 正在处理订单：D</span><br><span class="line">http-nio-8080-exec-5 正在处理订单：E</span><br></pre></td></tr></table></figure><p>每个线程都会有自己独立的 <code>total</code> 变量，<strong>互不影响</strong>，因此不会有线程冲突。</p><h4 id="2-什么时候会发生线程冲突？"><a href="#2-什么时候会发生线程冲突？" class="headerlink" title="(2) 什么时候会发生线程冲突？"></a><strong>(2) 什么时候会发生线程冲突？</strong></h4><p>如果 <code>OrderService</code> 里有<strong>共享的可变全局变量</strong>，那么多个线程可能会同时修改它，导致<strong>数据错乱</strong>。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">orderCount</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 共享变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        orderCount++; <span class="comment">// 线程不安全操作</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 订单处理完毕，orderCount = &quot;</span> + orderCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 5 个线程同时执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http-nio-8080-exec-1 订单处理完毕，orderCount = 1</span><br><span class="line">http-nio-8080-exec-2 订单处理完毕，orderCount = 2</span><br><span class="line">http-nio-8080-exec-3 订单处理完毕，orderCount = 3</span><br><span class="line">http-nio-8080-exec-4 订单处理完毕，orderCount = 4</span><br><span class="line">http-nio-8080-exec-5 订单处理完毕，orderCount = 5</span><br></pre></td></tr></table></figure><p><strong>问题：</strong></p><ul><li><code>orderCount++</code> 不是原子操作，多个线程可能会同时读取 <code>orderCount</code>，导致最终值不准确（可能丢失部分更新）。</li><li>这是线程安全问题，因为 <code>orderCount</code> 是多个线程共享的可变变量。</li></ul><h3 id="2-如何避免线程冲突？"><a href="#2-如何避免线程冲突？" class="headerlink" title="2. 如何避免线程冲突？"></a><strong>2. 如何避免线程冲突？</strong></h3><h4 id="✅-方案-1：避免共享可变变量"><a href="#✅-方案-1：避免共享可变变量" class="headerlink" title="✅ 方案 1：避免共享可变变量"></a><strong>✅ 方案 1：避免共享可变变量</strong></h4><p>如果 <code>orderCount</code> 只是一个业务逻辑内部的计数，不应该作为全局变量，可以把它改成<strong>局部变量</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">orderCount</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 线程安全，局部变量不会被共享</span></span><br><span class="line">        orderCount++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 订单处理完毕，orderCount = &quot;</span> + orderCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这样每个线程都有自己独立的</strong> <strong><code>orderCount</code></strong> <strong>变量，就不会有冲突。</strong></p><h4 id="✅-方案-2：使用-ThreadLocal"><a href="#✅-方案-2：使用-ThreadLocal" class="headerlink" title="✅ 方案 2：使用 ThreadLocal"></a><strong>✅ 方案 2：使用</strong> <strong><code>ThreadLocal</code></strong></h4><p>如果需要在同一个线程中共享数据，但不想让不同线程相互干扰，可以用 <code>ThreadLocal</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; orderCount = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        orderCount.set(orderCount.get() + <span class="number">1</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 订单处理完毕，orderCount = &quot;</span> + orderCount.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>ThreadLocal</code></strong> <strong>的作用：</strong></p><ul><li><strong>每个线程都会有自己独立的</strong> <strong><code>orderCount</code></strong> <strong>变量</strong>，不会和其他线程共享。</li><li><strong>适用于线程内部存储数据</strong>，比如用户会话信息、事务 ID 等。</li></ul><h4 id="✅-方案-3：使用-synchronized-（不推荐）"><a href="#✅-方案-3：使用-synchronized-（不推荐）" class="headerlink" title="✅ 方案 3：使用 **synchronized**（不推荐）"></a><strong>✅ 方案 3：使用</strong> **<code>synchronized</code>**（不推荐）</h4><p>如果确实需要在多个线程间共享变量，可以使用 <strong>同步锁</strong>，但这样会降低并发性能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">orderCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(String userId)</span> &#123; <span class="comment">// 方法加锁</span></span><br><span class="line">        orderCount++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 订单处理完毕，orderCount = &quot;</span> + orderCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题：</strong></p><ul><li><code>synchronized</code> 会<strong>让方法变成串行执行</strong>，一个线程执行时，其他线程必须等待，会导致性能下降。</li><li><strong>不推荐在高并发场景下使用</strong> **<code>synchronized</code>**。</li></ul><h4 id="✅-方案-4：使用-AtomicInteger"><a href="#✅-方案-4：使用-AtomicInteger" class="headerlink" title="✅ 方案 4：使用 AtomicInteger"></a><strong>✅ 方案 4：使用</strong> <strong><code>AtomicInteger</code></strong></h4><p><code>AtomicInteger</code> 通过 <strong>CAS（Compare And Swap）</strong> 操作保证线程安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">orderCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> orderCount.incrementAndGet(); <span class="comment">// 线程安全自增</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 订单处理完毕，orderCount = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li><code>incrementAndGet()</code> 是原子操作，多个线程同时调用不会导致数据丢失。</li><li>性能比 <code>synchronized</code> 更高。</li></ul><ol><li><strong>结论</strong></li></ol><p>❌ <strong>会引发线程冲突的情况</strong></p><ul><li><strong>Service 里的全局变量是可变的（非线程安全操作）</strong></li><li><strong>多个线程同时修改这个共享变量</strong></li></ul><p>✅ <strong>不会有线程冲突的情况</strong></p><ul><li><strong>方法里只有</strong>局部变量</li><li><strong>Tomcat</strong> <strong>分配的每个线程都有自己的</strong>调用栈</li><li><strong>使用</strong> <code>ThreadLocal</code><strong>、</strong><code>AtomicInteger</code>等解决共享变量问题</li></ul><p>🚀 <strong>Spring</strong> <strong><code>@Service</code></strong> 是单例的，但方法调用是并发的，不会天然有线程冲突，只有在共享全局变量时才需要额外注意线程安全。</p><h2 id="什么时候要调整-scope为多例"><a href="#什么时候要调整-scope为多例" class="headerlink" title="什么时候要调整@scope为多例"></a>什么时候要调整@scope为多例</h2><p>在 Spring 中，<strong>默认的 Bean</strong> <strong>作用域</strong>（Scope）是单例<strong>（</strong>Singleton<strong>）</strong>，即<strong>Spring 容器</strong>在应用启动时创建一个<strong>唯一的实例</strong>，并在整个应用程序范围内共享该实例。</p><p>但在某些情况下，我们需要使用 <code>@Scope</code> <strong>改变 Bean 的作用域</strong>，使其不再是单例模式，例如<strong>每个请求、每个线程、甚至每次调用都创建新的实例</strong>。</p><h3 id="1-什么时候需要使用-Scope-改变默认单例？"><a href="#1-什么时候需要使用-Scope-改变默认单例？" class="headerlink" title="1. 什么时候需要使用 @Scope 改变默认单例？"></a><strong>1. 什么时候需要使用</strong> <strong><code>@Scope</code></strong> <em>改变默认</em>单例？</h3><h4 id="✅-场景-1：需要为每个-HTTP-请求创建新的-Bean"><a href="#✅-场景-1：需要为每个-HTTP-请求创建新的-Bean" class="headerlink" title="✅ 场景 1：需要为每个 HTTP 请求创建新的 Bean"></a><strong>✅ 场景 1：需要为每个 HTTP 请求创建新的 Bean</strong></h4><blockquote><p><strong>适用</strong> <strong><code>@Scope(&quot;request&quot;)</code></strong> 适用于：Controller、用户信息、登录状态等与请求相关的 Bean</p></blockquote><p>在 Web 应用中，每个 HTTP 请求可能需要一个<strong>独立的 Bean 实例</strong>，比如<strong>存储当前请求的用户信息</strong>。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;request&quot;)</span> <span class="comment">// 每个 HTTP 请求都会创建新的 UserInfo 实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建新的 UserInfo 实例：&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123; <span class="keyword">return</span> username; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123; <span class="built_in">this</span>.username = username; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserInfo userInfo;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/set&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">setUser</span><span class="params">(<span class="meta">@RequestParam</span> String name)</span> &#123;</span><br><span class="line">        userInfo.setUsername(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User set: &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/get&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Current User: &quot;</span> + userInfo.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>📌 结果</strong></p><ul><li><code>GET /user/set?name=Alice</code> → <strong>创建新的</strong> <strong><code>UserInfo</code></strong> <strong>实例</strong></li><li><code>GET /user/get</code> → <strong>返回 Alice</strong></li><li>但如果换一个请求（比如新用户 <code>Bob</code>），Spring 会创建一个<strong>新的</strong> <strong><code>UserInfo</code></strong> <strong>实例</strong>。</li></ul><h4 id="✅-场景-2：每个会话（Session）创建一个新的-Bean"><a href="#✅-场景-2：每个会话（Session）创建一个新的-Bean" class="headerlink" title="✅ 场景 2：每个会话（Session）创建一个新的 Bean"></a><strong>✅ 场景 2：每个会话（Session）创建一个新的 Bean</strong></h4><blockquote><p><strong>适用</strong> <strong><code>@Scope(&quot;session&quot;)</code></strong> <strong>适用于：存储用户登录信息（比如购物车、用户认证信息等）</strong></p></blockquote><p>当用户登录后，我们通常需要在<strong>整个会话（Session）中保存用户状态</strong>，例如用户购物车、登录信息等。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;session&quot;)</span> <span class="comment">// 每个用户的 Session 共享一个实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCart</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; items = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addItem</span><span class="params">(String item)</span> &#123; items.add(item); &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getItems</span><span class="params">()</span> &#123; <span class="keyword">return</span> items; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a><strong>使用</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/cart&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCartController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ShoppingCart shoppingCart;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addItem</span><span class="params">(<span class="meta">@RequestParam</span> String item)</span> &#123;</span><br><span class="line">        shoppingCart.addItem(item);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Item added: &quot;</span> + item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getItems</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shoppingCart.getItems();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>📌 结果</strong></p><ul><li><strong>用户 A（Session 1）</strong> → <code>GET /cart/add?item=Apple</code> → <code>GET /cart/list</code> → <code>[&quot;Apple&quot;]</code></li><li><strong>用户 B（Session 2）</strong> → <code>GET /cart/list</code> → <code>[]</code>（因为 B 是新的会话）</li></ul><h4 id="✅-场景-3：每个线程创建一个独立的-Bean"><a href="#✅-场景-3：每个线程创建一个独立的-Bean" class="headerlink" title="✅ 场景 3：每个线程创建一个独立的 Bean"></a><strong>✅ 场景 3：每个线程创建一个独立的 Bean</strong></h4><blockquote><p><strong>适用</strong> <strong><code>@Scope(&quot;prototype&quot;)</code></strong> <strong>或</strong> <strong><code>@Scope(&quot;thread&quot;)</code></strong> <strong>适用于：<strong><strong>多线程</strong></strong>任务、线程隔离数据</strong></p></blockquote><p>在一些并发任务中，我们希望<strong>每个线程有自己的 Bean 实例</strong>，而不是所有线程共享同一个实例。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span> <span class="comment">// 每次调用都会创建新的实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TaskProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建新的 TaskProcessor：&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 处理任务：&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a><strong>使用</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TaskProcessor taskProcessor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeTask</span><span class="params">()</span> &#123;</span><br><span class="line">        taskProcessor.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多线程调用"><a href="#多线程调用" class="headerlink" title="多线程调用"></a>多线程调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/task&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TaskService taskService;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/start&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">startTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(taskService::executeTask).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(taskService::executeTask).start();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Tasks started!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>📌 结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread-1 处理任务：TaskProcessor@12345</span><br><span class="line">Thread-2 处理任务：TaskProcessor@67890</span><br></pre></td></tr></table></figure><p><strong>每个线程都有自己的</strong> <strong><code>TaskProcessor</code></strong> <strong>实例，互不干扰。</strong></p><h4 id="✅-场景-4：Bean-具有状态，每次使用都应该创建新实例"><a href="#✅-场景-4：Bean-具有状态，每次使用都应该创建新实例" class="headerlink" title="✅ 场景 4：Bean 具有状态，每次使用都应该创建新实例"></a><strong>✅ 场景 4：Bean 具有状态，每次使用都应该创建新实例</strong></h4><blockquote><p><strong>适用</strong> <strong><code>@Scope(&quot;prototype&quot;)</code></strong> <strong>适用于：任务处理器、算法计算等短生命周期对象</strong></p></blockquote><p>如果某个 Bean 有<strong>内部状态</strong>，并且不能被多个线程或请求共享，就需要 <code>prototype</code> 作用域。</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span> <span class="comment">// 每次调用都会创建新实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">processCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        processCount++;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单处理次数：&quot;</span> + processCount + <span class="string">&quot; 实例：&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a><strong>使用</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processNewOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">OrderProcessor</span> <span class="variable">orderProcessor</span> <span class="operator">=</span> context.getBean(OrderProcessor.class);</span><br><span class="line">        orderProcessor.processOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a><strong>调用</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/process&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">processOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        orderService.processNewOrder();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Order processed!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>📌 结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">订单处理次数：1 实例：OrderProcessor@12345</span><br><span class="line">订单处理次数：1 实例：OrderProcessor@67890</span><br></pre></td></tr></table></figure><p>每次调用 <code>processNewOrder()</code> 都会创建一个新的 <code>OrderProcessor</code> 实例，避免了状态共享导致的数据错误。</p><h3 id="2-Scope-作用范围总结"><a href="#2-Scope-作用范围总结" class="headerlink" title="2.@Scope 作用范围总结"></a><strong>2.<code>@Scope</code></strong> <strong>作用范围总结</strong></h3><table><thead><tr><th>作用域</th><th>说明</th><th>适用场景</th></tr></thead><tbody><tr><td>singleton</td><td>默认作用域，Spring 只创建一个实例</td><td>大多数无状态 Service、DAO</td></tr><tr><td>prototype</td><td>每次请求都会创建新实例</td><td>任务处理器、状态 Bean</td></tr><tr><td>request</td><td>每个 HTTP 请求创建一个实例</td><td>存储当前请求数据</td></tr><tr><td>session</td><td>每个用户 Session 创建一个实例</td><td>存储用户登录状态</td></tr><tr><td>application</td><td>整个 Web 应用共享一个实例</td><td>全局配置 Bean</td></tr><tr><td>websocket</td><td>每个 WebSocket 连接创建一个实例</td><td>WebSocket 会话管理</td></tr></tbody></table><h3 id="3-结论"><a href="#3-结论" class="headerlink" title="3.结论"></a><strong>3.结论</strong></h3><p><strong>🌟 什么时候用</strong> <strong><code>@Scope</code></strong> 改变默认单例模式？</p><ol><li><strong>如果 Bean 需要保存 HTTP 请求的状态</strong>，使用 <code>@Scope(&quot;request&quot;)</code></li><li><strong>如果 Bean 需要在整个用户 Session 共享</strong>，使用 <code>@Scope(&quot;session&quot;)</code></li><li><strong>如果 Bean 需要在每个线程中独立使用</strong>，使用 <code>@Scope(&quot;prototype&quot;)</code></li><li><strong>如果 Bean 具有状态，每次调用都需要新实例</strong>，使用 <code>@Scope(&quot;prototype&quot;)</code></li></ol><p><strong>🚀 Spring 默认使用</strong> <strong><code>singleton</code></strong> <strong>是因为它节省</strong>内存<strong>，提高性能，但在某些情况下，我们需要使用</strong> <strong><code>@Scope</code></strong> 来改变作用域<strong>，以保证</strong>线程安全和数据隔离。</p>]]></content>
      
      
      <categories>
          
          <category> 疑惑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 突发奇想的问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC_线程池</title>
      <link href="/2025/02/14/JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2025/02/14/JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>线程池：一个容纳多个线程的容器，容器中的线程可以重复使用，省去了频繁创建和销毁线程对象的操作</p><p>线程池作用：</p><ol><li>降低资源消耗，减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务</li><li>提高响应速度，当任务到达时，如果有线程可以直接用，不会出现系统僵死</li><li>提高线程的可管理性，如果无限制的创建线程，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li></ol><p>线程池的核心思想：<strong>线程复用</strong>，同一个线程可以被重复使用，来处理多个任务</p><p>池化技术 (Pool) ：一种编程技巧，核心思想是资源复用，在请求量大时能优化应用性能，降低系统频繁建连的资源开销</p><h3 id="手写线程池"><a href="#手写线程池" class="headerlink" title="手写线程池"></a>手写线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池，依次输入线程池的核心线程数、超时时间、超时单位、任务队列的容量、拒绝策略（函数式接口）</span></span><br><span class="line">        <span class="type">ThreadPool</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPool</span>(<span class="number">1</span>,</span><br><span class="line">                <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="number">1</span>, ((queue, task) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 拒绝策略1：死等</span></span><br><span class="line"><span class="comment">//            queue.put(task);</span></span><br><span class="line">            <span class="comment">// 策略2：带超时等待</span></span><br><span class="line"><span class="comment">//            queue.offer(task,500,TimeUnit.MILLISECONDS);</span></span><br><span class="line">            <span class="comment">// 策略3：让调用者放弃任务执行</span></span><br><span class="line"><span class="comment">//            log.info(&quot;放弃 &#123;&#125;&quot;,task);</span></span><br><span class="line">            <span class="comment">// 策略4：让调用者抛出异常</span></span><br><span class="line"><span class="comment">//            throw  new RuntimeException(&quot;任务执行失败 &quot;+task);</span></span><br><span class="line">            <span class="comment">// 策略5：让调用者自己执行任务（也就是main线程）</span></span><br><span class="line">            task.run();</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟线程池执行4个任务（也就是有4个worker（worker继承自Thread类，内含Runnable成员变量）要线程池执行）</span></span><br><span class="line">        <span class="comment">// 由于4个线程超过线程池的核心线程数，就会放入任务队列（也就是阻塞队列）进行等待，但由于任务队列的容量为1</span></span><br><span class="line">        <span class="comment">// 也就是多余的线程暂时无法放入任务队列，就执行拒绝策略</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// j是为了让i可以输出</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,j);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞队列（用作任务队列，当线程池满了的话就任务放入任务队列）</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockingQueue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 1.任务队列</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面两个条件变量的作用主要是用于往任务队列添加任务和取任务</span></span><br><span class="line">    <span class="comment">// 防止空队列时取任务，满队列时加任务出错（类似操作系统中的PV操作）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.生产者条件变量（往任务队列加内容）（使变满）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">fullWaitSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.消费者条件变量（从任务队列拿内容出来）（使变空）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">emptyWaitSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞添加（往任务队列中添加线程）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T task)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 当任务队列达到容量时（往任务队列添加内容要先看看任务队列还有没有位置）</span></span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 也就是任务队列满了</span></span><br><span class="line">                    log.info(<span class="string">&quot;等待加入任务队列&#123;&#125;...&quot;</span>, task);</span><br><span class="line">                    fullWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当任务队列有空位置就加入任务</span></span><br><span class="line">            log.info(<span class="string">&quot;加入任务队列&#123;&#125;&quot;</span>, task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞获取线程（也就是从任务队列中把任务提供给线程池）</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 当任务队列是空的时候就一直让消费者条件变量进行等待</span></span><br><span class="line">            <span class="comment">// 因为从任务队列取内容要防止出现向空队列取任务的情况</span></span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当任务队列不为空的时候，就将任务移除</span></span><br><span class="line">            <span class="comment">// 唤醒生产者条件变量</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是带有超时时间的阻塞添加和获取</span></span><br><span class="line">    <span class="comment">// 阻塞添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(T task, <span class="type">long</span> timeout, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 先将超时时间转化为纳秒</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="comment">// 循环判断队满状态</span></span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果nacos（后面的代码让它在while循环中会不断减少）小于等于0</span></span><br><span class="line">                    <span class="comment">// 说明超时了，就直接返回false</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    log.info(<span class="string">&quot;&#123;&#125; 等待加入队列&quot;</span>,task);</span><br><span class="line">                    nanos = fullWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果队列不满，就把任务加入队列</span></span><br><span class="line">            log.info(<span class="string">&quot;&#123;&#125; 加入队列&quot;</span>,task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞获取</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout,TimeUnit timeUnit)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 计算剩余时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="comment">// 队列为空就一直循环</span></span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nanos &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = emptyWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 队列不为空就取出任务</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">            <span class="comment">// 唤醒生产者条件变量</span></span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取任务队列的长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当任务队列满的时候可以选择拒绝策略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPut</span><span class="params">(RejectPolicy&lt;T&gt; rejectPolicy,T task)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 当任务队列满的时候执行拒绝策略</span></span><br><span class="line">            <span class="keyword">if</span> (queue.size() == capacity) &#123;</span><br><span class="line">                rejectPolicy.reject(<span class="built_in">this</span>,task);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                log.info(<span class="string">&quot;&#123;&#125; 加入任务队列&quot;</span>,task);</span><br><span class="line">                queue.addLast(task);</span><br><span class="line">                emptyWaitSet.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拒绝策略的接口，当队列满的时候任务队列可以选择拒绝策略</span></span><br><span class="line"><span class="comment">// 策略模式，这个拒绝策略可以自己写（函数式接口）</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">RejectPolicy</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue, T task)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="comment">// 实现线程池</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程集合（用hashset是为了去重）</span></span><br><span class="line">    <span class="comment">// Worker是继承自Thread的内部类，下文可以看到</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> coreSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取任务时的超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时时间的单位</span></span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继承自Thread的内部类，里面有Runnable的成员变量、构造方法和run方法</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            <span class="comment">// 1.当 task 不为空，执行任务</span></span><br><span class="line">            <span class="comment">// 2.当 task 执行完毕，再接着从任务队列获取任务并执行</span></span><br><span class="line">            <span class="keyword">while</span>(task != <span class="literal">null</span> || (task = taskQueue.poll(timeout,timeUnit))!= <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;运行任务：&quot;</span>,task);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 运行结束之后让任务为空，这样才可以继续从任务队列中取任务</span></span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从线程集合中删除该Worker</span></span><br><span class="line">            <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;worker 被移除&#123;&#125;&quot;</span>,<span class="built_in">this</span>);</span><br><span class="line">                workers.remove(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPool</span><span class="params">( <span class="type">int</span> coreSize, <span class="type">long</span> timeout, TimeUnit timeUnit, <span class="type">int</span> queueCapacity,RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskQueue = <span class="keyword">new</span> <span class="title class_">BlockingQueue</span>&lt;&gt;(queueCapacity);</span><br><span class="line">        <span class="built_in">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">        <span class="built_in">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="built_in">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池执行线程任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span>&#123;</span><br><span class="line">        <span class="comment">// 当任务数没有超过coreSize时，直接交给worker对象（继承了Thread类）执行（start方法）</span></span><br><span class="line">        <span class="comment">// 如果任务数超过了coreSize时，交给任务队列缓存（如果任务队列满了就执行拒绝策略）</span></span><br><span class="line">        <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">            <span class="keyword">if</span>(workers.size() &lt; coreSize)&#123;</span><br><span class="line">                <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(task);</span><br><span class="line">                log.info(<span class="string">&quot;新增 worker&#123;&#125; , &#123;&#125;&quot;</span>,worker,task);</span><br><span class="line">                <span class="comment">// 往线程池中加入(worker)线程</span></span><br><span class="line">                workers.add(worker);</span><br><span class="line">                <span class="comment">// 运行线程</span></span><br><span class="line">                <span class="comment">// 由Worker类中的run方法可以知道线程运行结束后会自动从线程池中移除</span></span><br><span class="line">                worker.start();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 交给任务队列的拒绝策略</span></span><br><span class="line">                taskQueue.tryPut(rejectPolicy,task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>有界队列和无界队列：</p><ul><li>有界队列：有固定大小的队列，比如设定了固定大小的 LinkedBlockingQueue，又或者大小为 0</li><li>无界队列：没有设置固定大小的队列，这些队列可以直接入队，直到溢出（超过 Integer.MAX_VALUE），所以相当于无界</li></ul><p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：<strong>FIFO 队列</strong></p><ul><li>ArrayBlockQueue：由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue：由链表结构组成的无界（默认大小 Integer.MAX_VALUE）的阻塞队列</li><li>PriorityBlockQueue：支持优先级排序的无界阻塞队列</li><li>DelayedWorkQueue：使用优先级队列实现的延迟无界阻塞队列</li><li>SynchronousQueue：不存储元素的阻塞队列，每一个生产线程会阻塞到有一个 put 的线程放入元素为止</li><li>LinkedTransferQueue：由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：由链表结构组成的<strong>双向</strong>阻塞队列</li></ul><p>与普通队列（LinkedList、ArrayList等）的不同点在于阻塞队列中阻塞添加和阻塞删除方法，以及线程安全：</p><ul><li>阻塞添加 put()：当阻塞队列元素已满时，添加队列元素的线程会被阻塞，直到队列元素不满时才重新唤醒线程执行</li><li>阻塞删除 take()：在队列元素为空时，删除队列元素的线程将被阻塞，直到队列不为空再执行删除操作（一般会返回被删除的元素)</li></ul><h4 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h4><table><thead><tr><th>方法类型</th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入（尾）</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除（头）</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查（队首元素）</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><ul><li>抛出异常组：<ul><li>当阻塞队列满时：在往队列中 add 插入元素会抛出 IIIegalStateException: Queue full</li><li>当阻塞队列空时：再往队列中 remove 移除元素，会抛出 NoSuchException</li></ul></li><li>特殊值组：<ul><li>插入方法：成功 true，失败 false</li><li>移除方法：成功返回出队列元素，队列没有就返回 null</li></ul></li><li>阻塞组：<ul><li>当阻塞队列满时，生产者继续往队列里 put 元素，队列会一直阻塞生产线程直到队列有空间 put 数据或响应中断退出</li><li>当阻塞队列空时，消费者线程试图从队列里 take 元素，队列会一直阻塞消费者线程直到队列中有可用元素</li></ul></li><li>超时退出：当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出</li></ul><h4 id="链表队列"><a href="#链表队列" class="headerlink" title="链表队列"></a>链表队列</h4><h5 id="入队出队"><a href="#入队出队" class="headerlink" title="入队出队"></a>入队出队</h5><p>LinkedBlockingQueue 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedBlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">                        <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 下列三种情况之一</span></span><br><span class="line"><span class="comment">        * - 真正的后继节点</span></span><br><span class="line"><span class="comment">        * - 自己, 发生在出队时</span></span><br><span class="line"><span class="comment">        * - null, 表示是没有后继节点, 是尾节点了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(E x) &#123; item = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入队：<strong>尾插法</strong></p><ul><li>初始化链表 <code>last = head = new Node&lt;E&gt;(null)</code>，<strong>Dummy 节点用来占位</strong>，item 为 null</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认是 Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当一个节点入队：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> &#123;</span><br><span class="line">    <span class="comment">// 从右向左计算</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=OGI2NjY0Mjk4NTczNzJhZTI4ZWYyMzQ4Nzk2Y2E3YzRfZnRRa3NmcVVlQzdyUmxtc004b29yc3Vyc1hneHpRM1FfVG9rZW46Sk1JNGJOSnhBb0Rab294WE5ycmNuenFsbmZjXzE3NDAzMTkzMzA6MTc0MDMyMjkzMF9WNA" alt="img"></p><ul><li>再来一个节点入队 <code>last = last.next = node</code></li></ul><p>出队：<strong>出队头节点</strong>，FIFO</p><ul><li>出队源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    <span class="comment">// 获取临头节点</span></span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    <span class="comment">// 自己指向自己，help GC</span></span><br><span class="line">    h.next = h;</span><br><span class="line">    head = first;</span><br><span class="line">    <span class="comment">// 出队的元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> first.item;</span><br><span class="line">    <span class="comment">// 【当前节点置为 Dummy 节点】</span></span><br><span class="line">    first.item = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>h = head</code> → <code>first = h.next</code></li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=NjdkMmE2M2YxZWYzMDJjM2I3Mjc5M2NhYjA4M2QxNDBfQkY0eEJNeDVxTHh5b0tIdHJRRVJydjE4WkJwcURCR0lfVG9rZW46UHZxVWIzelZRb1FHeXl4WXc0eWNFZUs2bnprXzE3NDAzMTkzMzA6MTc0MDMyMjkzMF9WNA" alt="img"></p><ul><li><code>h.next = h</code> → <code>head = first</code></li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=NGVkM2RjZjYyNzlmODE0N2IzYzE1NWI5MzIyODM3M2FfZ3RoRkp5dE81ako5bEc0dXBIY3lEMHZtU0JZV1hVTE1fVG9rZW46SnlXSmJmQjd0b0liWnF4SmZQQmNaNVFkblpmXzE3NDAzMTkzMzA6MTc0MDMyMjkzMF9WNA" alt="img"></p><ul><li><code>first.item = null</code>：当前节点置为 Dummy 节点</li></ul><h5 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h5><p>用了两把锁和 dummy 节点：</p><ul><li>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</li><li>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行<ul><li>消费者与消费者线程仍然串行</li><li>生产者与生产者线程仍然串行</li></ul></li></ul><p>线程安全分析：</p><ul><li>当节点总数大于 2 时（包括 dummy 节点），<strong>putLock 保证的是 last 节点的<strong><strong>线程安全</strong></strong>，takeLock 保证的是 head 节点的线程安全</strong>，两把锁保证了入队和出队没有竞争</li><li>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</li><li>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于 put(阻塞) offer(非阻塞)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> putLock.newCondition();        <span class="comment">// 阻塞等待不满，说明已经满了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于 take(阻塞) poll(非阻塞)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> takeLock.newCondition();        <span class="comment">// 阻塞等待不空，说明已经是空的</span></span><br></pre></td></tr></table></figure><p>入队出队：</p><ul><li>put 操作：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 把待添加的元素封装为 node 节点</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">    <span class="comment">// 获取全局生产锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    <span class="comment">// count 用来维护元素计数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="comment">// 获取可打断锁，会抛出异常</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 队列满了等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="comment">// 【等待队列不满时，就可以生产数据】，线程处于 Waiting</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有空位, 入队且计数加一，尾插法</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">// 返回自增前的数字</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">// put 完队列还有空位, 唤醒其他生产 put 线程，唤醒一个减少竞争</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// c自增前是0，说明生产了一个元素，唤醒一个 take 线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">signalNotEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 notEmpty.signal()，而不是 notEmpty.signalAll() 是为了减少竞争，因为只剩下一个元素</span></span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>take 操作：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="comment">// 获取全局消费锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    <span class="comment">// 可打断锁</span></span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 没有元素可以出队</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 【阻塞等待队列不空，就可以消费数据】，线程处于 Waiting</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出队，计数减一，FIFO，出队头节点</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">        <span class="comment">// 返回自减前的数字</span></span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="comment">// 队列还有元素</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 唤醒一个消费take线程</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// c 是消费前的数据，消费前满了，消费一个后还剩一个空位，唤醒生产线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        <span class="comment">// 调用的是 notFull.signal() 而不是 notFull.signalAll() 是为了减少竞争</span></span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h5><p>主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较：</p><ul><li>Linked 支持有界，Array 强制有界</li><li>Linked 实现是链表，Array 实现是数组</li><li>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组</li><li>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的</li><li>Linked 两把锁，Array 一把锁</li></ul><h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><h5 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h5><p>SynchronousQueue 是一个不存储元素的 BlockingQueue，<strong>每一个生产者必须阻塞匹配到一个消费者</strong></p><p>成员变量：</p><ul><li>运行当前程序的平台拥有 CPU 的数量：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPUS</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors()</span><br></pre></td></tr></table></figure><ul><li>指定超时时间后，当前线程最大自旋次数：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有一个 CPU 时自旋次数为 0，所有程序都是串行执行，多核 CPU 时自旋 32 次是一个经验值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxTimedSpins</span> <span class="operator">=</span> (NCPUS &lt; <span class="number">2</span>) ? <span class="number">0</span> : <span class="number">32</span>;</span><br></pre></td></tr></table></figure><ul><li>自旋的原因：线程挂起唤醒需要进行上下文切换，涉及到用户态和内核态的转变，是非常消耗资源的。自旋期间线程会一直检查自己的状态是否被匹配到，如果自旋期间被匹配到，那么直接就返回了，如果自旋次数达到某个指标后，还是会将当前线程挂起</li><li>未指定超时时间，当前线程最大自旋次数：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxUntimedSpins</span> <span class="operator">=</span> maxTimedSpins * <span class="number">16</span>;        <span class="comment">// maxTimedSpins 的 16 倍</span></span><br></pre></td></tr></table></figure><ul><li>指定超时限制的阈值，小于该值的线程不会被挂起：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">spinForTimeoutThreshold</span> <span class="operator">=</span> <span class="number">1000L</span>;        <span class="comment">// 纳秒</span></span><br></pre></td></tr></table></figure><ul><li>超时时间设置的小于该值，就会被禁止挂起，阻塞再唤醒的成本太高，不如选择自旋空转</li><li>转换器：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Transferer&lt;E&gt; transferer;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Transferer</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 参数一：可以为 null，null 时表示这个请求是一个 REQUEST 类型的请求，反之是一个 DATA 类型的请求</span></span><br><span class="line"><span class="comment">    * 参数二：如果为 true 表示指定了超时时间，如果为 false 表示不支持超时，会一直阻塞到匹配或者被打断</span></span><br><span class="line"><span class="comment">    * 参数三：超时时间限制，单位是纳秒</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 返回值：返回值如果不为 null 表示匹配成功，DATA 类型的请求返回当前线程 put 的数据</span></span><br><span class="line"><span class="comment">    *              如果返回 null，表示请求超时或被中断</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">abstract</span> E <span class="title function_">transfer</span><span class="params">(E e, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SynchronousQueue</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    <span class="comment">// fair 默认 false</span></span><br><span class="line">    <span class="comment">// 非公平模式实现的数据结构是栈，公平模式的数据结构是队列</span></span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> <span class="title class_">TransferQueue</span>&lt;E&gt;() : <span class="keyword">new</span> <span class="title class_">TransferStack</span>&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>成员方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">return</span> transferer.transfer(e, <span class="literal">true</span>, <span class="number">0</span>) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> transferer.transfer(<span class="literal">null</span>, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非公实现"><a href="#非公实现" class="headerlink" title="非公实现"></a>非公实现</h5><p>TransferStack 是非公平的同步队列，因为所有的请求都被压入栈中，栈顶的元素会最先得到匹配，造成栈底的等待线程饥饿</p><p>TransferStack 类成员变量：</p><ul><li>请求类型：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示 Node 类型为请求类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REQUEST</span>    <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 表示 Node类 型为数据类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DATA</span>       <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 表示 Node 类型为匹配中类型</span></span><br><span class="line"><span class="comment">// 假设栈顶元素为 REQUEST-NODE，当前请求类型为 DATA，入栈会修改类型为 FULFILLING 【栈顶 &amp; 栈顶之下的一个node】</span></span><br><span class="line"><span class="comment">// 假设栈顶元素为 DATA-NODE，当前请求类型为 REQUEST，入栈会修改类型为 FULFILLING 【栈顶 &amp; 栈顶之下的一个node】</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FULFILLING</span> <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li>栈顶元素：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> SNode head;</span><br></pre></td></tr></table></figure><p>内部类 SNode：</p><ul><li>成员变量：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SNode</span> &#123;</span><br><span class="line">    <span class="comment">// 指向下一个栈帧</span></span><br><span class="line">    <span class="keyword">volatile</span> SNode next; </span><br><span class="line">    <span class="comment">// 与当前 node 匹配的节点</span></span><br><span class="line">    <span class="keyword">volatile</span> SNode match;</span><br><span class="line">    <span class="comment">// 假设当前node对应的线程自旋期间未被匹配成功，那么node对应的线程需要挂起，</span></span><br><span class="line">    <span class="comment">// 挂起前 waiter 保存对应的线程引用，方便匹配成功后，被唤醒。</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据域，不为空表示当前 Node 对应的请求类型为 DATA 类型，反之则表示 Node 为 REQUEST 类型</span></span><br><span class="line">    Object item; </span><br><span class="line">    <span class="comment">// 表示当前Node的模式 【DATA/REQUEST/FULFILLING】</span></span><br><span class="line">    <span class="type">int</span> mode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SNode(Object item) &#123;</span><br><span class="line">    <span class="built_in">this</span>.item = item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置方法：设置 Node 对象的 next 字段，此处<strong>对</strong> <strong>CAS</strong> <strong>进行了优化</strong>，提升了 CAS 的效率</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">casNext</span><span class="params">(SNode cmp, SNode val)</span> &#123;</span><br><span class="line">    <span class="comment">//【优化：cmp == next】，可以提升一部分性能。 cmp == next 不相等，就没必要走 cas指令。</span></span><br><span class="line">    <span class="keyword">return</span> cmp == next &amp;&amp; UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, nextOffset, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>匹配方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">tryMatch</span><span class="params">(SNode s)</span> &#123;</span><br><span class="line">    <span class="comment">// 当前 node 尚未与任何节点发生过匹配，CAS 设置 match 字段为 s 节点，表示当前 node 已经被匹配</span></span><br><span class="line">    <span class="keyword">if</span> (match == <span class="literal">null</span> &amp;&amp; UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, matchOffset, <span class="literal">null</span>, s)) &#123;</span><br><span class="line">        <span class="comment">// 当前 node 如果自旋结束，会 park 阻塞，阻塞前将 node 对应的 Thread 保留到 waiter 字段</span></span><br><span class="line">        <span class="comment">// 获取当前 node 对应的阻塞线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">w</span> <span class="operator">=</span> waiter;</span><br><span class="line">        <span class="comment">// 条件成立说明 node 对应的 Thread 正在阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (w != <span class="literal">null</span>) &#123;</span><br><span class="line">            waiter = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 使用 unpark 方式唤醒线程</span></span><br><span class="line">            LockSupport.unpark(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 匹配成功返回 true</span></span><br><span class="line">    <span class="keyword">return</span> match == s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>取消方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消节点的方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">tryCancel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// match 字段指向自己，表示这个 node 是取消状态，取消状态的 node，最终会被强制移除出栈</span></span><br><span class="line">    UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, matchOffset, <span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> match == <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TransferStack 类成员方法：</p><ul><li>snode()：填充节点方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> SNode <span class="title function_">snode</span><span class="params">(SNode s, Object e, SNode next, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 引用指向空时，snode 方法会创建一个 SNode 对象 </span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span>) s = <span class="keyword">new</span> <span class="title class_">SNode</span>(e);</span><br><span class="line">    <span class="comment">// 填充数据</span></span><br><span class="line">    s.mode = mode;</span><br><span class="line">    s.next = next;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>transfer()：核心方法，请求匹配出栈，不匹配阻塞</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">transfer</span><span class="params">(E e, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> &#123;</span><br><span class="line">        <span class="comment">// 包装当前线程的 node</span></span><br><span class="line">    <span class="type">SNode</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 根据元素判断当前的请求类型</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mode</span> <span class="operator">=</span> (e == <span class="literal">null</span>) ? REQUEST : DATA;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取栈顶指针</span></span><br><span class="line">        <span class="type">SNode</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="comment">// 【CASE1】：当前栈为空或者栈顶 node 模式与当前请求模式一致无法匹配，做入栈操作</span></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="literal">null</span> || h.mode == mode) &#123;</span><br><span class="line">            <span class="comment">// 当前请求是支持超时的，但是 nanos &lt;= 0 说明这个请求不支持 “阻塞等待”</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="comment">// 栈顶元素是取消状态</span></span><br><span class="line">                <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.isCancelled())</span><br><span class="line">                    <span class="comment">// 栈顶出栈，设置新的栈顶</span></span><br><span class="line">                    casHead(h, h.next);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 表示【匹配失败】</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 入栈</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class="line">                <span class="comment">// 等待被匹配的逻辑，正常情况返回匹配的节点；取消情况返回当前节点，就是 s</span></span><br><span class="line">                <span class="type">SNode</span> <span class="variable">m</span> <span class="operator">=</span> awaitFulfill(s, timed, nanos);</span><br><span class="line">                <span class="comment">// 说明当前 node 是【取消状态】</span></span><br><span class="line">                <span class="keyword">if</span> (m == s) &#123; </span><br><span class="line">                    <span class="comment">// 将取消节点出栈</span></span><br><span class="line">                    clean(s);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 执行到这说明【匹配成功】了</span></span><br><span class="line">                <span class="comment">// 栈顶有节点并且 匹配节点还未出栈，需要协助出栈</span></span><br><span class="line">                <span class="keyword">if</span> ((h = head) != <span class="literal">null</span> &amp;&amp; h.next == s)</span><br><span class="line">                    casHead(h, s.next);</span><br><span class="line">                <span class="comment">// 当前 node 模式为 REQUEST 类型，返回匹配节点的 m.item 数据域</span></span><br><span class="line">                <span class="comment">// 当前 node 模式为 DATA 类型：返回 node.item 数据域，当前请求提交的数据 e</span></span><br><span class="line">                <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 【CASE2】：逻辑到这说明请求模式不一致，如果栈顶不是 FULFILLING 说明没被其他节点匹配，【当前可以匹配】</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) &#123;</span><br><span class="line">            <span class="comment">// 头节点是取消节点，match 指向自己，协助出栈</span></span><br><span class="line">            <span class="keyword">if</span> (h.isCancelled())</span><br><span class="line">                casHead(h, h.next);</span><br><span class="line">            <span class="comment">// 入栈当前请求的节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">                    <span class="comment">// m 是 s 的匹配的节点</span></span><br><span class="line">                    <span class="type">SNode</span> <span class="variable">m</span> <span class="operator">=</span> s.next;</span><br><span class="line">                    <span class="comment">// m 节点在 awaitFulfill 方法中被中断，clean 了自己</span></span><br><span class="line">                    <span class="keyword">if</span> (m == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 清空栈</span></span><br><span class="line">                        casHead(s, <span class="literal">null</span>);</span><br><span class="line">                        s = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 返回到外层自旋中</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 获取匹配节点的下一个节点</span></span><br><span class="line">                    <span class="type">SNode</span> <span class="variable">mn</span> <span class="operator">=</span> m.next;</span><br><span class="line">                    <span class="comment">// 尝试匹配，【匹配成功】，则将 fulfilling 和 m 一起出栈，并且唤醒被匹配的节点的线程</span></span><br><span class="line">                    <span class="keyword">if</span> (m.tryMatch(s)) &#123;</span><br><span class="line">                        casHead(s, mn);</span><br><span class="line">                        <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">// 匹配失败，出栈 m</span></span><br><span class="line">                        s.casNext(m, mn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 【CASE3】：栈顶模式为 FULFILLING 模式，表示【栈顶和栈顶下面的节点正在发生匹配】，当前请求需要做协助工作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// h 表示的是 fulfilling 节点，m 表示 fulfilling 匹配的节点</span></span><br><span class="line">            <span class="type">SNode</span> <span class="variable">m</span> <span class="operator">=</span> h.next;</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// 清空栈</span></span><br><span class="line">                casHead(h, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">SNode</span> <span class="variable">mn</span> <span class="operator">=</span> m.next;</span><br><span class="line">                <span class="comment">// m 和 h 匹配，唤醒 m 中的线程</span></span><br><span class="line">                <span class="keyword">if</span> (m.tryMatch(h))</span><br><span class="line">                    casHead(h, mn);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    h.casNext(m, mn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>awaitFulfill()：阻塞当前线程等待被匹配，返回匹配的节点，或者被取消的节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">SNode <span class="title function_">awaitFulfill</span><span class="params">(SNode s, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> &#123;</span><br><span class="line">    <span class="comment">// 等待的截止时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">// 当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">w</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 表示当前请求线程在下面的 for(;;) 自旋检查的次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> (shouldSpin(s) ? (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 自旋检查逻辑：是否匹配、是否超时、是否被中断</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 当前线程收到中断信号，需要设置 node 状态为取消状态</span></span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">            s.tryCancel();</span><br><span class="line">        <span class="comment">// 获取与当前 s 匹配的节点</span></span><br><span class="line">        <span class="type">SNode</span> <span class="variable">m</span> <span class="operator">=</span> s.match;</span><br><span class="line">        <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 可能是正常的匹配的，也可能是取消的</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        <span class="comment">// 执行了超时限制就判断是否超时</span></span><br><span class="line">        <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">// 【超时了，取消节点】</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                s.tryCancel();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 说明当前线程还可以进行自旋检查</span></span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 自旋一次 递减 1</span></span><br><span class="line">            spins = shouldSpin(s) ? (spins - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 说明没有自旋次数了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//【把当前 node 对应的 Thread 保存到 node.waiter 字段中，要阻塞了】</span></span><br><span class="line">            s.waiter = w;</span><br><span class="line">        <span class="comment">// 没有超时限制直接阻塞</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// nanos &gt; 1000 纳秒的情况下，才允许挂起当前线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="built_in">this</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">shouldSpin</span><span class="params">(SNode s)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取栈顶</span></span><br><span class="line">    <span class="type">SNode</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 条件一成立说明当前 s 就是栈顶，允许自旋检查</span></span><br><span class="line">    <span class="comment">// 条件二成立说明当前 s 节点自旋检查期间，又来了一个与当前 s 节点匹配的请求，双双出栈后条件会成立</span></span><br><span class="line">    <span class="comment">// 条件三成立前提当前 s 不是栈顶元素，并且当前栈顶正在匹配中，这种状态栈顶下面的元素，都允许自旋检查</span></span><br><span class="line">    <span class="keyword">return</span> (h == s || h == <span class="literal">null</span> || isFulfilling(h.mode));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>clear()：指定节点出栈</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">clean</span><span class="params">(SNode s)</span> &#123;</span><br><span class="line">    <span class="comment">// 清空数据域和关联线程</span></span><br><span class="line">    s.item = <span class="literal">null</span>;</span><br><span class="line">    s.waiter = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取取消节点的下一个节点</span></span><br><span class="line">    <span class="type">SNode</span> <span class="variable">past</span> <span class="operator">=</span> s.next;</span><br><span class="line">    <span class="comment">// 判断后继节点是不是取消节点，是就更新 past</span></span><br><span class="line">    <span class="keyword">if</span> (past != <span class="literal">null</span> &amp;&amp; past.isCancelled())</span><br><span class="line">        past = past.next;</span><br><span class="line"></span><br><span class="line">    SNode p;</span><br><span class="line">    <span class="comment">// 从栈顶开始向下检查，【将栈顶开始向下的 取消状态 的节点全部清理出去】，直到碰到 past 或者不是取消状态为止</span></span><br><span class="line">    <span class="keyword">while</span> ((p = head) != <span class="literal">null</span> &amp;&amp; p != past &amp;&amp; p.isCancelled())</span><br><span class="line">        <span class="comment">// 修改的是内存地址对应的值，p 指向该内存地址所以数据一直在变化</span></span><br><span class="line">        casHead(p, p.next);</span><br><span class="line">        <span class="comment">// 说明中间遇到了不是取消状态的节点，继续迭代下去</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; p != past) &#123;</span><br><span class="line">        <span class="type">SNode</span> <span class="variable">n</span> <span class="operator">=</span> p.next;</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="literal">null</span> &amp;&amp; n.isCancelled())</span><br><span class="line">            p.casNext(n, n.next);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="公平实现"><a href="#公平实现" class="headerlink" title="公平实现"></a>公平实现</h5><p>TransferQueue 是公平的同步队列，采用 FIFO 的队列实现，请求节点与队尾模式不同，需要与队头发生匹配</p><p>TransferQueue 类成员变量：</p><ul><li>指向队列的 dummy 节点：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> QNode head;</span><br></pre></td></tr></table></figure><ul><li>指向队列的尾节点：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> QNode tail;</span><br></pre></td></tr></table></figure><ul><li>被清理节点的前驱节点：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> QNode cleanMe;</span><br></pre></td></tr></table></figure><ul><li>入队操作是两步完成的，第一步是 t.next &#x3D; newNode，第二步是 tail &#x3D; newNode，所以队尾节点出队，是一种非常特殊的情况</li></ul><p>TransferQueue 内部类：</p><ul><li>QNode：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">QNode</span> &#123;</span><br><span class="line">    <span class="comment">// 指向当前节点的下一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> QNode next;</span><br><span class="line">    <span class="comment">// 数据域，Node 代表的是 DATA 类型 item 表示数据，否则 Node 代表的 REQUEST 类型，item == null</span></span><br><span class="line">    <span class="keyword">volatile</span> Object item;</span><br><span class="line">    <span class="comment">// 假设当前 node 对应的线程自旋期间未被匹配成功，那么 node 对应的线程需要挂起，</span></span><br><span class="line">    <span class="comment">// 挂起前 waiter 保存对应的线程引用，方便匹配成功后被唤醒。</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="comment">// true 当前 Node 是一个 DATA 类型，false 表示当前 Node 是一个 REQUEST 类型</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> isData;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建方法</span></span><br><span class="line">    QNode(Object item, <span class="type">boolean</span> isData) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = item;</span><br><span class="line">        <span class="built_in">this</span>.isData = isData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试取消当前 node，取消状态的 node 的 item 域指向自己</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tryCancel</span><span class="params">(Object cmp)</span> &#123;</span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, itemOffset, cmp, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前 node 是否为取消状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item == <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前节点是否 “不在” 队列内，当 next 指向自己时，说明节点已经出队。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isOffList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next == <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TransferQueue 类成员方法：</p><ul><li>设置头尾节点：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">advanceHead</span><span class="params">(QNode h, QNode nh)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置头指针指向新的节点，</span></span><br><span class="line">    <span class="keyword">if</span> (h == head &amp;&amp; UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, headOffset, h, nh))</span><br><span class="line">        <span class="comment">// 老的头节点出队</span></span><br><span class="line">        h.next = h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">advanceTail</span><span class="params">(QNode t, QNode nt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tail == t)</span><br><span class="line">        <span class="comment">// 更新队尾节点为新的队尾</span></span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, tailOffset, t, nt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>transfer()：核心方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">transfer</span><span class="params">(E e, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> &#123;</span><br><span class="line">    <span class="comment">// s 指向当前请求对应的 node</span></span><br><span class="line">    <span class="type">QNode</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 是否是 DATA 类型的请求</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isData</span> <span class="operator">=</span> (e != <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span> || h == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// head 和 tail 同时指向 dummy 节点，说明是空队列</span></span><br><span class="line">        <span class="comment">// 队尾节点与当前请求类型是一致的情况，说明阻塞队列中都无法匹配，</span></span><br><span class="line">        <span class="keyword">if</span> (h == t || t.isData == isData) &#123;</span><br><span class="line">            <span class="comment">// 获取队尾 t 的 next 节点</span></span><br><span class="line">            <span class="type">QNode</span> <span class="variable">tn</span> <span class="operator">=</span> t.next;</span><br><span class="line">            <span class="comment">// 多线程环境中其他线程可能修改尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 已经有线程入队了，更新 tail</span></span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="literal">null</span>) &#123;</span><br><span class="line">                advanceTail(t, tn);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 允许超时，超时时间小于 0，这种方法不支持阻塞等待</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 创建 node 的逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">null</span>)</span><br><span class="line">                s = <span class="keyword">new</span> <span class="title class_">QNode</span>(e, isData);</span><br><span class="line">            <span class="comment">// 将 node 添加到队尾</span></span><br><span class="line">            <span class="keyword">if</span> (!t.casNext(<span class="literal">null</span>, s))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="comment">// 更新队尾指针</span></span><br><span class="line">            advanceTail(t, s);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前节点 等待匹配....</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> awaitFulfill(s, e, timed, nanos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 说明【当前 node 状态为 取消状态】，需要做出队逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (x == s) &#123;</span><br><span class="line">                clean(t, s);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                        <span class="comment">// 说明当前 node 仍然在队列内，匹配成功，需要做出队逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (!s.isOffList()) &#123;</span><br><span class="line">                <span class="comment">// t 是当前 s 节点的前驱节点，判断 t 是不是头节点，是就更新 dummy 节点为 s 节点</span></span><br><span class="line">                advanceHead(t, s);</span><br><span class="line">                <span class="comment">// s 节点已经出队，所以需要把它的 item 域设置为它自己，表示它是个取消状态</span></span><br><span class="line">                <span class="keyword">if</span> (x != <span class="literal">null</span>)</span><br><span class="line">                    s.item = s;</span><br><span class="line">                s.waiter = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="literal">null</span>) ? (E)x : e;</span><br><span class="line">                <span class="comment">// 队尾节点与当前请求节点【互补匹配】</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// h.next 节点，【请求节点与队尾模式不同，需要与队头发生匹配】，TransferQueue 是一个【公平模式】</span></span><br><span class="line">            <span class="type">QNode</span> <span class="variable">m</span> <span class="operator">=</span> h.next;</span><br><span class="line">            <span class="comment">// 并发导致其他线程修改了队尾节点，或者已经把 head.next 匹配走了</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail || m == <span class="literal">null</span> || h != head)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="comment">// 获取匹配节点的数据域保存到 x</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> m.item;</span><br><span class="line">            <span class="comment">// 判断是否匹配成功</span></span><br><span class="line">            <span class="keyword">if</span> (isData == (x != <span class="literal">null</span>) ||</span><br><span class="line">                x == m ||</span><br><span class="line">                !m.casItem(x, e)) &#123;</span><br><span class="line">                advanceHead(h, m);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                        <span class="comment">// 【匹配完成】，将头节点出队，让这个新的头结点成为 dummy 节点</span></span><br><span class="line">            advanceHead(h, m);</span><br><span class="line">            <span class="comment">// 唤醒该匹配节点的线程</span></span><br><span class="line">            LockSupport.unpark(m.waiter);</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="literal">null</span>) ? (E)x : e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>awaitFulfill()：阻塞当前线程等待被匹配</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">awaitFulfill</span><span class="params">(QNode s, E e, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> &#123;</span><br><span class="line">    <span class="comment">// 表示等待截止时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">w</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 自选检查的次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> ((head.next == s) ? (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 被打断就取消节点</span></span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">            s.tryCancel(e);</span><br><span class="line">        <span class="comment">// 获取当前 Node 数据域</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> s.item;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前请求为 DATA 模式时：e 请求带来的数据</span></span><br><span class="line">        <span class="comment">// s.item 修改为 this，说明当前 QNode 对应的线程 取消状态</span></span><br><span class="line">        <span class="comment">// s.item 修改为 null 表示已经有匹配节点了，并且匹配节点拿走了 item 数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前请求为 REQUEST 模式时：e == null</span></span><br><span class="line">        <span class="comment">// s.item 修改为 this，说明当前 QNode 对应的线程 取消状态</span></span><br><span class="line">        <span class="comment">// s.item != null 且 item != this  表示当前 REQUEST 类型的 Node 已经匹配到 DATA 了 </span></span><br><span class="line">        <span class="keyword">if</span> (x != e)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="comment">// 超时检查</span></span><br><span class="line">        <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                s.tryCancel(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自旋次数减一</span></span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">            --spins;</span><br><span class="line">        <span class="comment">// 没有自旋次数了，把当前线程封装进去 waiter</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="literal">null</span>)</span><br><span class="line">            s.waiter = w;</span><br><span class="line">        <span class="comment">// 阻塞</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="built_in">this</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作Pool"><a href="#操作Pool" class="headerlink" title="操作Pool"></a>操作Pool</h3><h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><h5 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h5><p>存放线程的容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Worker&gt;();</span><br></pre></td></tr></table></figure><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure><p>参数介绍：</p><ul><li>corePoolSize：核心线程数，定义了最小可以同时运行的线程数量</li><li>maximumPoolSize：最大线程数，当队列中存放的任务达到队列容量时，当前可以同时运行的数量变为最大线程数，创建线程并立即执行最新的任务，与核心线程数之间的差值又叫救急线程数</li><li>keepAliveTime：救急线程最大存活时间，当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等到 <code>keepAliveTime</code> 时间超过销毁</li><li>unit：<code>keepAliveTime</code> 参数的时间单位</li><li>workQueue：阻塞队列，存放被提交但尚未被执行的任务</li><li>threadFactory：线程工厂，创建新线程时用到，可以为线程创建时起名字</li><li>handler：拒绝策略，线程到达最大线程数仍有新任务时会执行拒绝策略</li><li>RejectedExecutionHandler 下有 4 个实现类：<ul><li>AbortPolicy：让调用者抛出 RejectedExecutionException 异常，<strong>默认策略</strong></li><li>CallerRunsPolicy：让调用者运行的调节机制，将某些任务回退到调用者，从而降低新任务的流量</li><li>DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常</li><li>DiscardOldestPolicy：放弃队列中最早的任务，把当前任务加入队列中尝试再次提交当前任务</li></ul></li><li>补充：其他框架拒绝策略<ul><li>Dubbo：在抛出 RejectedExecutionException 异常前记录日志，并 dump 线程栈信息，方便定位问题</li><li>Netty：创建一个新线程来执行任务</li><li>ActiveMQ：带超时等待（60s）尝试放入队列</li><li>PinPoint：它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li></ul></li></ul><p>工作原理：</p><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=OTI4MjEwNTcwZGIyY2JiOTgzNTkzMDdjMGQ2MzkwNzFfdWZlNzFlOWtpMnJVZVI1RUtOcnZlRkNHT2RDWXJ3TWJfVG9rZW46QUJuSGJHeTNHb3Z6UmF4Z0s1cWNuenlzbjZnXzE3NDAzMTkzMzA6MTc0MDMyMjkzMF9WNA" alt="img"></p><ol><li>创建线程池，这时没有创建线程（<strong>懒惰</strong>），等待提交过来的任务请求，调用 execute 方法才会创建线程</li><li>当调用 execute() 方法添加一个请求任务时，线程池会做如下判断：<ol><li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务</li><li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列</li><li>如果这时队列满了且正在运行的线程数量还小于 maximumPoolSize，那么会创建非核心线程<strong>立刻运行这个任务</strong>，对于阻塞队列中的任务不公平。这是因为创建每个 Worker（线程）对象会绑定一个初始任务，启动 Worker 时会优先执行</li><li>如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和<strong>拒绝策略</strong>来执行</li></ol></li><li>当一个线程完成任务时，会从队列中取下一个任务来执行</li><li>当一个线程空闲超过一定的时间（keepAliveTime）时，线程池会判断：如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉，所以线程池的所有任务完成后最终会收缩到 corePoolSize 大小</li></ol><p>图片来源：<a href="https://space.bilibili.com/457326371/">https://space.bilibili.com/457326371/</a></p><h5 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h5><p>Executors 提供了四种线程池的创建：newCachedThreadPool、newFixedThreadPool、newSingleThreadExecutor、newScheduledThreadPool</p><ul><li>newFixedThreadPool：创建一个拥有 n 个线程的线程池</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间</li><li>LinkedBlockingQueue 是一个单向链表实现的阻塞队列，默认大小为 <code>Integer.MAX_VALUE</code>，也就是无界队列，可以放任意数量的任务，在任务比较多的时候会导致 OOM（内存溢出）</li><li>适用于任务量已知，相对耗时的长期任务</li><li>newCachedThreadPool：创建一个可扩容的线程池</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>核心线程数是 0， 最大线程数是 29 个 1，全部都是救急线程（60s 后可以回收），可能会创建大量线程，从而导致 <strong>OOM</strong></li><li>SynchronousQueue 作为阻塞队列，没有容量，对于每一个 take 的线程会阻塞直到有一个 put 的线程放入元素为止（类似一手交钱、一手交货）</li><li>适合任务数比较密集，但每个任务执行时间较短的情况</li><li>newSingleThreadExecutor：创建一个只有 1 个线程的单线程池</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>保证所有任务按照<strong>指定顺序执行</strong>，线程数固定为 1，任务数多于 1 时会放入无界队列排队，任务执行完毕，这唯一的线程也不会被释放</li></ul><p>对比：</p><ul><li>创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，线程池会新建一个线程，保证池的正常工作</li><li>Executors.newSingleThreadExecutor() 线程个数始终为 1，不能修改。FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法</li><li>原因：父类不能直接调用子类中的方法，需要反射或者创建对象的方式，可以调用子类静态方法</li><li>Executors.newFixedThreadPool(1) 初始时为 1，可以修改。对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmE3ODlhMzczYTJlOTg2N2NlYmI1Nzc4MzRlNTI1ZmRfR0J5cDM3VTBJRXlRcG5YSVVoMkhtYVVLV3ZmbEw3amRfVG9rZW46VkVicWJBbmQ4b0wwSjd4S2dicmMwM0tNbmJkXzE3NDAzMTkzMzA6MTc0MDMyMjkzMF9WNA" alt="img"></p><h5 id="开发要求"><a href="#开发要求" class="headerlink" title="开发要求"></a>开发要求</h5><p>阿里巴巴 Java 开发手册要求：</p><ul><li><strong>线程资源必须通过<strong><strong>线程池</strong></strong>提供，不允许在应用中自行显式创建线程</strong><ul><li>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题</li><li>如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者过度切换的问题</li></ul></li><li>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式更加明确线程池的运行规则，规避资源耗尽的风险</li><li>Executors 返回的线程池对象弊端如下：<ul><li>FixedThreadPool 和 SingleThreadPool：请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM</li><li>CacheThreadPool 和 ScheduledThreadPool：允许创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，导致 OOM</li></ul></li></ul><p>创建多大容量的线程池合适？</p><ul><li>一般来说池中<strong>总<strong><strong>线程数</strong></strong>是核心池线程数量两倍</strong>，确保当核心池有线程停止时，核心池外有线程进入核心池</li><li>过小会导致程序不能充分地利用系统资源、容易导致饥饿</li><li>过大会导致更多的线程上下文切换，占用更多内存</li><li>上下文切换：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态，任务从保存到再加载的过程就是一次上下文切换</li></ul><p>核心线程数常用公式：</p><ul><li><strong>CPU</strong> <strong>密集型任务 (N+1)：</strong> 这种任务消耗的是 CPU 资源，可以将核心线程数设置为 N (CPU 核心数) + 1，比 CPU 核心数多出来的一个线程是为了防止线程发生缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 某个核心就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间</li><li>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如在内存中对大量数据进行分析</li><li><strong>I&#x2F;O</strong> <strong>密集型任务：</strong> 这种系统 CPU 处于阻塞状态，用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用，因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N 或 CPU 核数&#x2F; (1-阻塞系数)，阻塞系数在 0.8~0.9 之间</li><li>IO 密集型就是涉及到网络读取，文件读取此类任务 ，特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上</li></ul><h4 id="提交方法"><a href="#提交方法" class="headerlink" title="提交方法"></a>提交方法</h4><p>ExecutorService 类 API：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void execute(Runnable command)</td><td>执行任务（Executor 类 API）</td></tr><tr><td>Future submit(Runnable task)</td><td>提交任务 task()</td></tr><tr><td>Future submit(Callable task)</td><td>提交任务 task，用返回值 Future 获得任务执行结果</td></tr><tr><td>List<Future> invokeAll(Collection&lt;? extends Callable&gt; tasks)</Future></td><td>提交 tasks 中所有任务</td></tr><tr><td>List<Future> invokeAll(Collection&lt;? extends Callable&gt; tasks, long timeout, TimeUnit unit)</Future></td><td>提交 tasks 中所有任务，超时时间针对所有task，超时会取消没有执行完的任务，并抛出超时异常</td></tr><tr><td>T invokeAny(Collection&lt;? extends Callable&gt; tasks)</td><td>提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</td></tr></tbody></table><p>execute 和 submit 都属于线程池的方法，对比：</p><ul><li>execute 只能执行 Runnable 类型的任务，没有返回值； submit 既能提交 Runnable 类型任务也能提交 Callable 类型任务，底层是<strong>封装成 FutureTask，然后调用 execute 执行</strong></li><li>execute 会直接抛出任务执行时的异常，submit 会吞掉异常，可通过 <strong>Future 的 get 方法将任务执行时的异常重新抛出</strong></li></ul><h4 id="关闭方法"><a href="#关闭方法" class="headerlink" title="关闭方法"></a>关闭方法</h4><p>ExecutorService 类 API：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void shutdown()</td><td>线程池状态变为 SHUTDOWN，等待任务执行完后关闭线程池，不会接收新任务，但已提交任务会执行完，而且也可以添加线程（不绑定任务）</td></tr><tr><td>List shutdownNow()</td><td>线程池状态变为 STOP，用 interrupt 中断正在执行的任务，直接关闭线程池，不会接收新任务，会将队列中的任务返回</td></tr><tr><td>boolean isShutdown()</td><td>不在 RUNNING 状态的线程池，此执行者已被关闭，方法返回 true</td></tr><tr><td>boolean isTerminated()</td><td>线程池状态是否是 TERMINATED，如果所有任务在关闭后完成，返回 true</td></tr><tr><td>boolean awaitTermination(long timeout, TimeUnit unit)</td><td>调用 shutdown 后，由于调用线程不会等待所有任务运行结束，如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待</td></tr></tbody></table><h4 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h4><p>execute 会直接抛出任务执行时的异常，submit 会吞掉异常，有两种处理方法</p><p>方法 1：主动捉异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>方法 2：使用 Future 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">Future&lt;?&gt; future = pool.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h4><p>ThreadPoolExecutor 使用 int 的<strong>高 3 位来表示<strong><strong>线程池</strong></strong>状态，低 29 位表示线程数量</strong>。这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 CAS 原子操作进行赋值</p><ul><li>状态表示：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高3位：表示当前线程池运行状态，除去高3位之后的低位：表示当前线程池中所拥有的线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 表示在 ctl 中，低 COUNT_BITS 位，是用于存放当前线程数量的位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 低 COUNT_BITS 位所能表达的最大数值，000 11111111111111111111 =&gt; 5亿多</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=NmNhYjZjOWVkYmEwNjRmMGM2NDE1MDkwOGQxOTgwZDhfYnNIVnZIN3NuU2VBUmc0U2YxejlYRnR1bFh4eHZqMnNfVG9rZW46Q1Vtc2I3d1JIb3ZEb014Skp0WWNBMUZibjZmXzE3NDAzMTkzMzA6MTc0MDMyMjkzMF9WNA" alt="img"></p><ul><li>四种状态：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 111 000000000000000000，转换成整数后其实就是一个【负数】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 000 000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 001 000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 010 000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 011 000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><table><thead><tr><th>状态</th><th>高3位</th><th>接收新任务</th><th>处理阻塞任务队列</th><th>说明</th></tr></thead><tbody><tr><td>RUNNING</td><td>111</td><td>Y</td><td>Y</td><td></td></tr><tr><td>SHUTDOWN</td><td>000</td><td>N</td><td>Y</td><td>不接收新任务，但处理阻塞队列剩余任务</td></tr><tr><td>STOP</td><td>001</td><td>N</td><td>N</td><td>中断正在执行的任务，并抛弃阻塞队列任务</td></tr><tr><td>TIDYING</td><td>010</td><td>-</td><td>-</td><td>任务全执行完毕，活动线程为 0 即将进入终结</td></tr><tr><td>TERMINATED</td><td>011</td><td>-</td><td>-</td><td>终止状态</td></tr></tbody></table><ul><li>获取当前线程池运行状态：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ~CAPACITY = ~000 11111111111111111111 = 111 000000000000000000000（取反）</span></span><br><span class="line"><span class="comment">// c == ctl = 111 000000000000000000111</span></span><br><span class="line"><span class="comment">// 111 000000000000000000111</span></span><br><span class="line"><span class="comment">// 111 000000000000000000000</span></span><br><span class="line"><span class="comment">// 111 000000000000000000000        获取到了运行状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br></pre></td></tr></table></figure><ul><li>获取当前线程池线程数量：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        c = 111 000000000000000000111</span></span><br><span class="line"><span class="comment">// CAPACITY = 000 111111111111111111111</span></span><br><span class="line"><span class="comment">//            000 000000000000000000111 =&gt; 7</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br></pre></td></tr></table></figure><ul><li>重置当前线程池状态 ctl：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rs 表示线程池状态，wc 表示当前线程池中 worker（线程）数量，相与以后就是合并后的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><ul><li>比较当前线程池 ctl 所表示的状态：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较当前线程池 ctl 所表示的状态，是否小于某个状态 s</span></span><br><span class="line"><span class="comment">// 状态对比：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateLessThan</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> &#123; <span class="keyword">return</span> c &lt; s; &#125;</span><br><span class="line"><span class="comment">// 比较当前线程池 ctl 所表示的状态，是否大于等于某个状态s</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateAtLeast</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> &#123; <span class="keyword">return</span> c &gt;= s; &#125;</span><br><span class="line"><span class="comment">// 小于 SHUTDOWN 的一定是 RUNNING，SHUTDOWN == 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">(<span class="type">int</span> c)</span> &#123; <span class="keyword">return</span> c &lt; SHUTDOWN; &#125;</span><br></pre></td></tr></table></figure><ul><li>设置线程池 ctl：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 CAS 方式 让 ctl 值 +1 ，成功返回 true, 失败返回 false</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndIncrementWorkerCount</span><span class="params">(<span class="type">int</span> expect)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 CAS 方式 让 ctl 值 -1 ，成功返回 true, 失败返回 false</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndDecrementWorkerCount</span><span class="params">(<span class="type">int</span> expect)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 ctl 值减一，do while 循环会一直重试，直到成功为止</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">decrementWorkerCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (!compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="成员属性-1"><a href="#成员属性-1" class="headerlink" title="成员属性"></a>成员属性</h4><p>成员变量</p><ul><li><strong>线程池****中存放 Worker 的容器</strong>：线程池没有初始化，直接往池中加线程即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Worker&gt;();</span><br></pre></td></tr></table></figure><ul><li>线程全局锁：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加减少 worker 或者时修改线程池运行状态需要持有 mainLock</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure><ul><li>可重入锁的条件变量：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当外部线程调用 awaitTermination() 方法时，会等待当前线程池状态为 Termination 为止</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">termination</span> <span class="operator">=</span> mainLock.newCondition()</span><br></pre></td></tr></table></figure><ul><li>线程池相关参数：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> corePoolSize;                                <span class="comment">// 核心线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> maximumPoolSize;                        <span class="comment">// 线程池最大线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> keepAliveTime;                        <span class="comment">// 空闲线程存活时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;        <span class="comment">// 创建线程时使用的线程工厂，默认是 DefaultThreadFactory</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<span class="comment">// 【超过核心线程提交任务就放入 阻塞队列】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;        <span class="comment">// 拒绝策略，juc包提供了4中方式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">defaultHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbortPolicy</span>();<span class="comment">// 默认策略</span></span><br></pre></td></tr></table></figure><ul><li>记录线程池相关属性的数值：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> largestPoolSize;                <span class="comment">// 记录线程池生命周期内线程数最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> completedTaskCount;        <span class="comment">// 记录线程池所完成任务总数，当某个 worker 退出时将完成的任务累加到该属性</span></span><br></pre></td></tr></table></figure><ul><li>控制<strong>核心线程数量内的线程是否可以被回收</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// false（默认）代表不可以，为 true 时核心线程空闲超过 keepAliveTime 也会被回收</span></span><br><span class="line"><span class="comment">// allowCoreThreadTimeOut(boolean value) 方法可以设置该值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> allowCoreThreadTimeOut;</span><br></pre></td></tr></table></figure><p>内部类：</p><ul><li>Worker 类：<strong>每个 Worker 对象会绑定一个初始任务</strong>，启动 Worker 时优先执行，这也是造成线程池不公平的原因。Worker 继承自 AQS，本身具有锁的特性，采用独占锁模式，state &#x3D; 0 表示未被占用，&gt; 0 表示被占用，&lt; 0 表示初始状态不能被抢锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread;                        <span class="comment">// worker 内部封装的工作线程</span></span><br><span class="line">    Runnable firstTask;                                <span class="comment">// worker 第一个执行的任务，普通的 Runnable 实现类或者是 FutureTask</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;        <span class="comment">// 记录当前 worker 所完成任务数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="comment">// 设置AQS独占模式为初始化中状态，这个状态不能被抢占锁</span></span><br><span class="line">               setState(-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// firstTask不为空时，当worker启动后，内部线程会优先执行firstTask，执行完后会到queue中去获取下个任务</span></span><br><span class="line">        <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 使用线程工厂创建一个线程，并且【将当前worker指定为Runnable】，所以thread启动时会调用 worker.run()</span></span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 【不可重入锁】</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">    <span class="comment">// 将当前 worker 指定为 thread 的执行方法，线程调用 start 会调用 r.run()</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r, namePrefix + threadNumber.getAndIncrement(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">        t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">        t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>拒绝策略相关的内部类</li></ul><h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><h5 id="提交方法-1"><a href="#提交方法-1" class="headerlink" title="提交方法"></a>提交方法</h5><ul><li>AbstractExecutorService#submit()：提交任务，<strong>把</strong> <strong>Runnable</strong> <strong>或</strong> <strong>Callable</strong> <strong>任务封装成 FutureTask 执行</strong>，可以通过方法返回的任务对象，调用 get 阻塞获取任务执行的结果或者异常，源码分析在笔记的 Future 部分</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="comment">// 空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 把 Runnable 封装成未来任务对象，执行结果就是 null，也可以通过参数指定 FutureTask#get 返回数据</span></span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 执行方法</span></span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 把 Callable 封装成未来任务对象</span></span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    <span class="comment">// 执行方法</span></span><br><span class="line">    execute(ftask);        </span><br><span class="line">    <span class="comment">// 返回未来任务对象，用来获取返回值</span></span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> &#123;</span><br><span class="line">    <span class="comment">// Runnable 封装成 FutureTask，【指定返回值】</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> &#123;</span><br><span class="line">    <span class="comment">// Callable 直接封装成 FutureTask</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>execute()：执行任务，<strong>但是没有返回值，没办法获取任务执行结果</strong>，出现异常会直接抛出任务执行时的异常。根据线程池中的线程数，选择添加任务时的处理方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// command 可以是普通的 Runnable 实现类，也可以是 FutureTask，不能是 Callable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="comment">// 非空判断</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">          <span class="comment">// 获取 ctl 最新值赋值给 c，ctl 高 3 位表示线程池状态，低位表示当前线程池线程数量。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">// 【1】当前线程数量小于核心线程数，此次提交任务直接创建一个新的 worker，线程池中多了一个新的线程</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// addWorker 为创建线程的过程，会创建 worker 对象并且将 command 作为 firstTask，优先执行</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行到这条语句，说明 addWorker 一定是失败的，存在并发现象或者线程池状态被改变，重新获取状态</span></span><br><span class="line">        <span class="comment">// SHUTDOWN 状态下也有可能创建成功，前提 firstTask == null 而且当前 queue 不为空（特殊情况）</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 【2】执行到这说明当前线程数量已经达到核心线程数量 或者 addWorker 失败</span></span><br><span class="line">    <span class="comment">//         判断当前线程池是否处于running状态，成立就尝试将 task 放入到 workQueue 中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 条件一成立说明线程池状态被外部线程给修改了，可能是执行了 shutdown() 方法，该状态不能接收新提交的任务</span></span><br><span class="line">        <span class="comment">// 所以要把刚提交的任务删除，删除成功说明提交之后线程池中的线程还未消费（处理）该任务</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">// 任务出队成功，走拒绝策略</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 执行到这说明线程池是 running 状态，获取线程池中的线程数量，判断是否是 0</span></span><br><span class="line">        <span class="comment">// 【担保机制】，保证线程池在 running 状态下，最起码得有一个线程在工作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 【3】offer失败说明queue满了</span></span><br><span class="line">    <span class="comment">// 如果线程数量尚未达到 maximumPoolSize，会创建非核心 worker 线程直接执行 command，【这也是不公平的原因】</span></span><br><span class="line">    <span class="comment">// 如果当前线程数量达到 maximumPoolSiz，这里 addWorker 也会失败，走拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加线程"><a href="#添加线程" class="headerlink" title="添加线程"></a>添加线程</h5><ul><li>prestartAllCoreThreads()：<strong>提前预热</strong>，创建所有的核心线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">prestartAllCoreThreads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (addWorker(<span class="literal">null</span>, <span class="literal">true</span>))</span><br><span class="line">        ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>addWorker()：<strong>添加线程到****线程池</strong>，返回 true 表示创建 Worker 成功，且线程启动。首先判断线程池是否允许添加线程，允许就让线程数量 + 1，然后去创建 Worker 加入线程池</li><li>注意：SHUTDOWN 状态也能添加线程，但是要求新加的 Woker 没有 firstTask，而且当前 queue 不为空，所以创建一个线程来帮助线程池执行队列中的任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core == true 表示采用核心线程数量限制，false 表示采用 maximumPoolSize</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    <span class="comment">// 自旋【判断当前线程池状态是否允许创建线程】，允许就设置线程数量 + 1</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取 ctl 的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 获取当前线程池运行状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前线程池状态【是否允许添加线程】</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前线程池是 SHUTDOWN 状态，但是队列里面还有任务尚未处理完，需要处理完 queue 中的任务</span></span><br><span class="line">        <span class="comment">// 【不允许再提交新的 task，所以 firstTask 为空，但是可以继续添加 worker】</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span> &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取线程池中线程数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="comment">// 条件一一般不成立，CAPACITY是5亿多，根据 core 判断使用哪个大小限制线程数量，超过了返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 记录线程数量已经加 1，类比于申请到了一块令牌，条件失败说明其他线程修改了数量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="comment">// 申请成功，跳出了 retry 这个 for 自旋</span></span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// CAS 失败，没有成功的申请到令牌</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">            <span class="comment">// 判断当前线程池状态是否发生过变化，被其他线程修改了，可能其他线程调用了 shutdown() 方法</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="comment">// 返回外层循环检查是否能创建线程，在 if 语句中返回 false</span></span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【令牌申请成功，开始创建线程】</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行标记，表示创建的 worker 是否已经启动，false未启动  true启动</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 添加标记，表示创建的 worker 是否添加到池子中了，默认false未添加，true是添加。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 【创建 Worker，底层通过线程工厂 newThread 方法创建执行线程，指定了首先执行的任务】</span></span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="comment">// 将新创建的 worker 节点中的线程赋值给 t</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="comment">// 这里的判断为了防止 程序员自定义的 ThreadFactory 实现类有 bug，创造不出线程</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            <span class="comment">// 加互斥锁，要添加 worker 了</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取最新线程池运行状态保存到 rs</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">                                <span class="comment">// 判断线程池是否为RUNNING状态，不是再【判断当前是否为SHUTDOWN状态且firstTask为空，特殊情况】</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 当线程start后，线程isAlive会返回true，这里还没开始启动线程，如果被启动了就需要报错</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//【将新建的 Worker 添加到线程池中】</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                                        <span class="comment">// 当前池中的线程数量是一个新高，更新 largestPoolSize</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    <span class="comment">// 添加标记置为 true</span></span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 解锁啊</span></span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加成功就【启动线程执行任务】</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// Thread 类中持有 Runnable 任务对象，调用的是 Runnable 的 run ，也就是 FutureTask</span></span><br><span class="line">                t.start();</span><br><span class="line">                <span class="comment">// 运行标记置为 true</span></span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果启动线程失败，做清理工作</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新创建的线程是否启动</span></span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>addWorkerFailed()：清理任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addWorkerFailed</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    <span class="comment">// 持有线程池全局锁，因为操作的是线程池相关的东西</span></span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//条件成立需要将 worker 在 workers 中清理出去。</span></span><br><span class="line">        <span class="keyword">if</span> (w != <span class="literal">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        <span class="comment">// 将线程池计数 -1，相当于归还令牌。</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        <span class="comment">// 尝试停止线程池</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放线程池全局锁。</span></span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h5><ul><li>Worker#run：Worker 实现了 Runnable 接口，当线程启动时，会调用 Worker 的 run() 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ThreadPoolExecutor#runWorker()</span></span><br><span class="line">    runWorker(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>runWorker()：线程启动就要<strong>执行任务</strong>，会一直 while 循环获取任务并执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();        </span><br><span class="line">    <span class="comment">// 获取 worker 的 firstTask</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    <span class="comment">// 引用置空，【防止复用该线程时重复执行该任务】</span></span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 初始化 worker 时设置 state = -1，表示不允许抢占锁</span></span><br><span class="line">    <span class="comment">// 这里需要设置 state = 0 和 exclusiveOwnerThread = null，开始独占模式抢锁</span></span><br><span class="line">    w.unlock();</span><br><span class="line">    <span class="comment">// true 表示发生异常退出，false 表示正常退出。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// firstTask 不是 null 就直接运行，否则去 queue 中获取任务</span></span><br><span class="line">        <span class="comment">// 【getTask 如果是阻塞获取任务，会一直阻塞在take方法，直到获取任务，不会走返回null的逻辑】</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// worker 加锁，shutdown 时会判断当前 worker 状态，【根据独占锁状态判断是否空闲】</span></span><br><span class="line">            w.lock();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 说明线程池状态大于 STOP，目前处于 STOP/TIDYING/TERMINATION，此时给线程一个中断信号</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 <span class="comment">// 说明线程处于 RUNNING 或者 SHUTDOWN 状态，清除打断标记</span></span><br><span class="line">                 (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())</span><br><span class="line">                <span class="comment">// 中断线程，设置线程的中断标志位为 true</span></span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 钩子方法，【任务执行的前置处理】</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 【执行任务】</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception x) &#123;</span><br><span class="line">                         <span class="comment">//.....</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 钩子方法，【任务执行的后置处理】</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;                <span class="comment">// 将局部变量task置为null，代表任务执行完成</span></span><br><span class="line">                w.completedTasks++;        <span class="comment">// 更新worker完成任务数量</span></span><br><span class="line">                w.unlock();                        <span class="comment">// 解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// getTask()方法返回null时会走到这里，表示queue为空并且线程空闲超过保活时间，【当前线程执行退出逻辑】</span></span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;        </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 正常退出 completedAbruptly = false</span></span><br><span class="line">               <span class="comment">// 异常退出 completedAbruptly = true，【从 task.run() 内部抛出异常】时，跳到这一行</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>unlock()：重置锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123; release(<span class="number">1</span>); &#125;</span><br><span class="line"><span class="comment">// 外部不会直接调用这个方法 这个方法是 AQS 内调用的，外部调用 unlock 时触发此方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">    setExclusiveOwnerThread(<span class="literal">null</span>);                <span class="comment">// 设置持有者为 null</span></span><br><span class="line">    setState(<span class="number">0</span>);                                                <span class="comment">// 设置 state = 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>getTask()：获取任务，线程空闲时间超过 keepAliveTime 就会被回收，判断的依据是<strong>当前线程阻塞获取任务超过保活时间</strong>，方法返回 null 就代表当前线程要被回收了，返回到 runWorker 执行线程退出逻辑。线程池具有担保机制，对于 RUNNING 状态下的超时回收，要保证线程池中最少有一个线程运行，或者任务阻塞队列已经是空</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 超时标记，表示当前线程获取任务是否超时，true 表示已超时</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 获取线程池当前运行状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【tryTerminate】打断线程后执行到这，此时线程池状态为STOP或者线程池状态为SHUTDOWN并且队列已经是空</span></span><br><span class="line">        <span class="comment">// 所以下面的 if 条件一定是成立的，可以直接返回 null，线程就应该退出了</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">// 使用 CAS 自旋的方式让 ctl 值 -1</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取线程池中的线程数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程没有明确的区分谁是核心或者非核心线程，是根据当前池中的线程数量判断</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// timed = false 表示当前这个线程 获取task时不支持超时机制的，当前线程会使用 queue.take() 阻塞获取</span></span><br><span class="line">        <span class="comment">// timed = true 表示当前这个线程 获取task时支持超时机制，使用 queue.poll(xxx,xxx) 超时获取</span></span><br><span class="line">        <span class="comment">// 条件一代表允许回收核心线程，那就无所谓了，全部线程都执行超时回收</span></span><br><span class="line">        <span class="comment">// 条件二成立说明线程数量大于核心线程数，当前线程认为是非核心线程，有保活时间，去超时获取任务</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果线程数量是否超过最大线程数，直接回收</span></span><br><span class="line">        <span class="comment">// 如果当前线程【允许超时回收并且已经超时了】，就应该被回收了，由于【担保机制】还要做判断：</span></span><br><span class="line">        <span class="comment">//           wc &gt; 1 说明线程池还用其他线程，当前线程可以直接回收</span></span><br><span class="line">        <span class="comment">//    workQueue.isEmpty() 前置条件是 wc = 1，【如果当前任务队列也是空了，最后一个线程就可以退出】</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">// 使用 CAS 机制将 ctl 值 -1 ,减 1 成功的线程，返回 null，代表可以退出</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据当前线程是否需要超时回收，【选择从队列获取任务的方法】是超时获取或者阻塞获取</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();</span><br><span class="line">            <span class="comment">// 获取到任务返回任务，【阻塞获取会阻塞到获取任务为止】，不会返回 null</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 获取任务为 null 说明超时了，将超时标记设置为 true，下次自旋时返 null</span></span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">// 阻塞线程被打断后超时标记置为 false，【说明被打断不算超时】，要继续获取，直到超时或者获取到任务</span></span><br><span class="line">            <span class="comment">// 如果线程池 SHUTDOWN 状态下的打断，会在循环获取任务前判断，返回 null</span></span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>processWorkerExit()：<strong>线程退出****线程池</strong>，也有担保机制，保证队列中的任务被执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常退出 completedAbruptly = false，异常退出为 true</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line">    <span class="comment">// 条件成立代表当前 worker 是发生异常退出的，task 任务执行过程中向上抛出异常了</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) </span><br><span class="line">        <span class="comment">// 从异常时到这里 ctl 一直没有 -1，需要在这里 -1</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前 worker 完成的 task 数量，汇总到线程池的 completedTaskCount</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">                <span class="comment">// 将 worker 从线程池中移除</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();        <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 尝试停止线程池，唤醒下一个线程</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">// 线程池不是停止状态就应该有线程运行【担保机制】</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="comment">// 正常退出的逻辑，是对空闲线程回收，不是执行出错</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="comment">// 根据是否回收核心线程确定【线程池中的线程数量最小值】</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="comment">// 最小值为 0，但是线程队列不为空，需要一个线程来完成任务担保机制</span></span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; !workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 线程池中的线程数量大于最小值可以直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行 task 时发生异常，有个线程因为异常终止了，需要添加</span></span><br><span class="line">        <span class="comment">// 或者线程池中的数量小于最小值，这里要创建一个新 worker 加进线程池</span></span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="停止方法"><a href="#停止方法" class="headerlink" title="停止方法"></a>停止方法</h5><ul><li>shutdown()：停止线程池</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    <span class="comment">// 获取线程池全局锁</span></span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 设置线程池状态为 SHUTDOWN，如果线程池状态大于 SHUTDOWN，就不会设置直接返回</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 中断空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        <span class="comment">// 空方法，子类可以扩展</span></span><br><span class="line">        onShutdown(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放线程池全局锁</span></span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>interruptIdleWorkers()：shutdown 方法会<strong>中断所有空闲线程</strong>，根据是否可以获取 AQS 独占锁判断是否处于工作状态。线程之所以空闲是因为阻塞队列没有任务，不会中断正在运行的线程，所以 shutdown 方法会让所有的任务执行完毕</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onlyOne == true 说明只中断一个线程 ，false 则中断所有线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interruptIdleWorkers</span><span class="params">(<span class="type">boolean</span> onlyOne)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    / /持有全局锁</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历所有 worker</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            <span class="comment">// 获取当前 worker 的线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">            <span class="comment">// 条件一成立：说明当前迭代的这个线程尚未中断</span></span><br><span class="line">            <span class="comment">// 条件二成立：说明【当前worker处于空闲状态】，阻塞在poll或者take，因为worker执行task时是要加锁的</span></span><br><span class="line">            <span class="comment">//           每个worker有一个独占锁，w.tryLock()尝试加锁，加锁成功返回 true</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 中断线程，处于 queue 阻塞的线程会被唤醒，进入下一次自旋，返回 null，执行退出相逻辑</span></span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放worker的独占锁</span></span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// false，代表中断所有的线程</span></span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放全局锁</span></span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>shutdownNow()：直接关闭线程池，不会等待任务执行完成</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 返回值引用</span></span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    <span class="comment">// 获取线程池全局锁</span></span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 设置线程池状态为STOP</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 中断线程池中【所有线程】</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 从阻塞队列中导出未处理的task</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="comment">// 返回当前任务队列中 未处理的任务。</span></span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>tryTerminate()：设置为 TERMINATED 状态 if either (SHUTDOWN and pool and queue empty) or (STOP and pool empty)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryTerminate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取 ctl 的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 线程池正常，或者有其他线程执行了状态转换的方法，当前线程直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) || runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            <span class="comment">// 线程池是 SHUTDOWN 并且任务队列不是空，需要去处理队列中的任务</span></span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行到这里说明线程池状态为 STOP 或者线程池状态为 SHUTDOWN 并且队列已经是空</span></span><br><span class="line">        <span class="comment">// 判断线程池中线程的数量</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 【中断一个空闲线程】，在 queue.take() | queue.poll() 阻塞空闲</span></span><br><span class="line">            <span class="comment">// 唤醒后的线程会在getTask()方法返回null，</span></span><br><span class="line">            <span class="comment">// 执行 processWorkerExit 退出逻辑时会再次调用 tryTerminate() 唤醒下一个空闲线程</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="comment">// 池中的线程数量为 0 来到这里</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        <span class="comment">// 加全局锁</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置线程池状态为 TIDYING 状态，线程数量为 0</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 结束线程池</span></span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 设置线程池状态为TERMINATED状态。</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    <span class="comment">// 【唤醒所有调用 awaitTermination() 方法的线程】</span></span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 释放线程池全局锁</span></span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><h5 id="线程使用"><a href="#线程使用" class="headerlink" title="线程使用"></a>线程使用</h5><p>FutureTask 未来任务对象，继承 Runnable、Future 接口，用于包装 Callable 对象，实现任务的提交</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    FutureTask&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();        <span class="comment">//启动线程</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> task.get();        <span class="comment">//获取返回任务数据</span></span><br><span class="line">    System.out.println(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.callable = callable;        <span class="comment">// 属性注入</span></span><br><span class="line">    <span class="built_in">this</span>.state = NEW;                         <span class="comment">// 任务状态设置为 new</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Runnable runnable, V result)</span> &#123;</span><br><span class="line">    <span class="comment">// 适配器模式</span></span><br><span class="line">    <span class="built_in">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="built_in">this</span>.state = NEW;       </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="title function_">callable</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 使用装饰者模式将 runnable 转换成 callable 接口，外部线程通过 get 获取</span></span><br><span class="line">    <span class="comment">// 当前任务执行结果时，结果可能为 null 也可能为传进来的值，【传进来什么返回什么】</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Runnable task;</span><br><span class="line">    <span class="keyword">final</span> T result;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        <span class="built_in">this</span>.task = task;</span><br><span class="line">        <span class="built_in">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实则调用 Runnable#run 方法</span></span><br><span class="line">        task.run();</span><br><span class="line">        <span class="comment">// 返回值为构造 FutureTask 对象时传入的返回值或者是 null</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="成员属性-2"><a href="#成员属性-2" class="headerlink" title="成员属性"></a>成员属性</h5><p>FutureTask 类的成员属性：</p><ul><li>任务状态：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示当前task状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"><span class="comment">// 当前任务尚未执行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NEW</span>          <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 当前任务正在结束，尚未完全结束，一种临界状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COMPLETING</span>   <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 当前任务正常结束</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORMAL</span>       <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 当前任务执行过程中发生了异常，内部封装的 callable.run() 向上抛出异常了</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCEPTIONAL</span>  <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 当前任务被取消</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span>    <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 当前任务中断中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTING</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 当前任务已中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTED</span>  <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure><ul><li>任务对象：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;        <span class="comment">// Runnable 使用装饰者模式伪装成 Callable</span></span><br></pre></td></tr></table></figure><ul><li><strong>存储任务执行的结果</strong>，这是 run 方法返回值是 void 也可以获取到执行结果的原因：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常情况下：任务正常执行结束，outcome 保存执行结果，callable 返回值</span></span><br><span class="line"><span class="comment">// 非正常情况：callable 向上抛出异常，outcome 保存异常</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; </span><br></pre></td></tr></table></figure><ul><li>执行当前任务的线程对象：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;        <span class="comment">// 当前任务被线程执行期间，保存当前执行任务的线程对象引用</span></span><br></pre></td></tr></table></figure><ul><li><strong>线程阻塞队列的头节点</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会有很多线程去 get 当前任务的结果，这里使用了一种数据结构头插头取（类似栈）的一个队列来保存所有的 get 线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br></pre></td></tr></table></figure><ul><li>内部类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WaitNode</span> &#123;</span><br><span class="line">    <span class="comment">// 单向链表</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">    WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h5><p>FutureTask 类的成员方法：</p><ul><li><strong>FutureTask#run</strong>：任务执行入口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//条件一：成立说明当前 task 已经被执行过了或者被 cancel 了，非 NEW 状态的任务，线程就不需要处理了</span></span><br><span class="line">    <span class="comment">//条件二：线程是 NEW 状态，尝试设置当前任务对象的线程是当前线程，设置失败说明其他线程抢占了该任务，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset, <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行到这里，当前 task 一定是 NEW 状态，而且【当前线程也抢占 task 成功】</span></span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="comment">// 判断任务是否为空，防止空指针异常；判断 state 状态，防止外部线程在此期间 cancel 掉当前任务</span></span><br><span class="line">        <span class="comment">// 【因为 task 的执行者已经设置为当前线程，所以这里是线程安全的】</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="comment">// true 表示 callable.run 代码块执行成功 未抛出异常</span></span><br><span class="line">            <span class="comment">// false 表示 callable.run 代码块执行失败 抛出异常</span></span><br><span class="line">            <span class="type">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// 【调用自定义的方法，执行结果赋值给 result】</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                <span class="comment">// 没有出现异常</span></span><br><span class="line">                ran = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">// 出现异常，返回值置空，ran 置为 false</span></span><br><span class="line">                result = <span class="literal">null</span>;</span><br><span class="line">                ran = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 设置返回的异常</span></span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 代码块执行正常</span></span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                <span class="comment">// 设置返回的结果</span></span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 任务执行完成，取消线程的引用，help GC</span></span><br><span class="line">        runner = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="comment">// 判断任务是不是被中断</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            <span class="comment">// 执行中断处理方法</span></span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>FutureTask#set：设置正常返回值，首先将任务状态设置为 COMPLETING 状态代表完成中，逻辑执行完设置为 NORMAL 状态代表任务正常执行完成，最后唤醒 get() 阻塞线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(V v)</span> &#123;</span><br><span class="line">    <span class="comment">// CAS 方式设置当前任务状态为完成中，设置失败说明其他线程取消了该任务</span></span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        <span class="comment">// 【将结果赋值给 outcome】</span></span><br><span class="line">        outcome = v;</span><br><span class="line">        <span class="comment">// 将当前任务状态修改为 NORMAL 正常结束状态。</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, NORMAL);</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>FutureTask#setException：设置异常返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setException</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        <span class="comment">// 赋值给返回结果，用来向上层抛出来的异常</span></span><br><span class="line">        outcome = t;</span><br><span class="line">        <span class="comment">// 将当前任务的状态 修改为 EXCEPTIONAL</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, EXCEPTIONAL);</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>FutureTask#finishCompletion：<strong>唤醒 get() 阻塞线程</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">finishCompletion</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历所有的等待的节点，q 指向头节点</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="literal">null</span>;) &#123;</span><br><span class="line">        <span class="comment">// 使用cas设置 waiters 为 null，防止外部线程使用cancel取消当前任务，触发finishCompletion方法重复执行</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, waitersOffset, q, <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 自旋</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 获取当前 WaitNode 节点封装的 thread</span></span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> q.thread;</span><br><span class="line">                <span class="comment">// 当前线程不为 null，唤醒当前 get() 等待获取数据的线程</span></span><br><span class="line">                <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="literal">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取当前节点的下一个节点</span></span><br><span class="line">                <span class="type">WaitNode</span> <span class="variable">next</span> <span class="operator">=</span> q.next;</span><br><span class="line">                <span class="comment">// 当前节点是最后一个节点了</span></span><br><span class="line">                <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 断开链表</span></span><br><span class="line">                q.next = <span class="literal">null</span>; <span class="comment">// help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    done();</span><br><span class="line">    callable = <span class="literal">null</span>;        <span class="comment">// help GC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>FutureTask#handlePossibleCancellationInterrupt：任务中断处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePossibleCancellationInterrupt</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">        <span class="comment">// 中断状态中</span></span><br><span class="line">        <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">            <span class="comment">// 等待中断完成</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>FutureTask#get</strong>：获取任务执行的返回值，执行 run 和 get 的不是同一个线程，一般有多个线程 get，只有一个线程 run</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    <span class="comment">// 获取当前任务状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">    <span class="comment">// 条件成立说明任务还没执行完成</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        <span class="comment">// 返回 task 当前状态，可能当前线程在里面已经睡了一会</span></span><br><span class="line">        s = awaitDone(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>FutureTask#awaitDone：<strong>get 线程封装成 WaitNode 对象进入阻塞队列阻塞等待</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">awaitDone</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 0 不带超时</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">// 引用当前线程，封装成 WaitNode 对象</span></span><br><span class="line">    <span class="type">WaitNode</span> <span class="variable">q</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 表示当前线程 waitNode 对象，是否进入阻塞队列</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">queued</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 【三次自旋开始休眠】</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 判断当前 get() 线程是否被打断，打断返回 true，清除打断标记</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">// 当前线程对应的等待 node 出队，</span></span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="comment">// 获取任务状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="comment">// 条件成立说明当前任务执行完成已经有结果了</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="comment">// 条件成立说明已经为当前线程创建了 WaitNode，置空 help GC</span></span><br><span class="line">            <span class="keyword">if</span> (q != <span class="literal">null</span>)</span><br><span class="line">                q.thread = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 返回当前的状态</span></span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 条件成立说明当前任务接近完成状态，这里让当前线程释放一下 cpu ，等待进行下一次抢占 cpu</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) </span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        <span class="comment">// 【第一次自旋】，当前线程还未创建 WaitNode 对象，此时为当前线程创建 WaitNode对象</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="literal">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> <span class="title class_">WaitNode</span>();</span><br><span class="line">        <span class="comment">// 【第二次自旋】，当前线程已经创建 WaitNode 对象了，但是node对象还未入队</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">// waiters 指向队首，让当前 WaitNode 成为新的队首，【头插法】，失败说明其他线程修改了新的队首</span></span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, waitersOffset, q.next = waiters, q);</span><br><span class="line">        <span class="comment">// 【第三次自旋】，会到这里，或者 else 内</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 阻塞指定的时间</span></span><br><span class="line">            LockSupport.parkNanos(<span class="built_in">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 条件成立：说明需要阻塞</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 【当前 get 操作的线程被 park 阻塞】，除非有其它线程将唤醒或者将当前线程中断</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>FutureTask#report：封装运行结果，可以获取 run() 方法中设置的成员变量 outcome，<strong>这是 run 方法的返回值是 void 也可以获取到任务执行的结果的原因</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">report</span><span class="params">(<span class="type">int</span> s)</span> <span class="keyword">throws</span> ExecutionException &#123;</span><br><span class="line">    <span class="comment">// 获取执行结果，是在一个 futuretask 对象中的属性，可以直接获取</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> outcome;</span><br><span class="line">    <span class="comment">// 当前任务状态正常结束</span></span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;        <span class="comment">// 直接返回 callable 的逻辑结果</span></span><br><span class="line">    <span class="comment">// 当前任务被取消或者中断</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CancellationException</span>();                <span class="comment">// 抛出异常</span></span><br><span class="line">    <span class="comment">// 执行到这里说明自定义的 callable 中的方法有异常，使用 outcome 上层抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutionException</span>((Throwable)x);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>FutureTask#cancel：任务取消，打断正在执行该任务的线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span> &#123;</span><br><span class="line">    <span class="comment">// 条件一：表示当前任务处于运行中或者处于线程池任务队列中</span></span><br><span class="line">    <span class="comment">// 条件二：表示修改状态，成功可以去执行下面逻辑，否则返回 false 表示 cancel 失败</span></span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp;</span><br><span class="line">          UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW,</span><br><span class="line">                                   mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果任务已经被执行，是否允许打断</span></span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取执行当前 FutureTask 的线程</span></span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> runner;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 打断执行的线程</span></span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 设置任务状态为【中断完成】</span></span><br><span class="line">                UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 唤醒所有 get() 阻塞的线程</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>Timer 实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">    <span class="type">TimerTask</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task 1&quot;</span>);</span><br><span class="line">            <span class="comment">//int i = 1 / 0;//任务一的出错会导致任务二无法执行</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">TimerTask</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task 2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 使用 timer 添加两个任务，希望它们都在 1s 后执行</span></span><br><span class="line">        <span class="comment">// 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此任务1的延时，影响了任务2的执行</span></span><br><span class="line">    timer.schedule(task1, <span class="number">1000</span>);<span class="comment">//17:45:56 c.ThreadPool [Timer-0] - task 1</span></span><br><span class="line">    timer.schedule(task2, <span class="number">1000</span>);<span class="comment">//17:45:58 c.ThreadPool [Timer-0] - task 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Scheduled"><a href="#Scheduled" class="headerlink" title="Scheduled"></a>Scheduled</h4><p>任务调度线程池 ScheduledThreadPoolExecutor 继承 ThreadPoolExecutor：</p><ul><li>使用内部类 ScheduledFutureTask 封装任务</li><li>使用内部类 DelayedWorkQueue 作为线程池队列</li><li>重写 onShutdown 方法去处理 shutdown 后的任务</li><li>提供 decorateTask 方法作为 ScheduledFutureTask 的修饰方法，以便开发者进行扩展</li></ul><p>构造方法：<code>Executors.newScheduledThreadPool(int corePoolSize)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 最大线程数固定为 Integer.MAX_VALUE，保活时间 keepAliveTime 固定为 0</span></span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="comment">// 阻塞队列是 DelayedWorkQueue</span></span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用 API：</p><ul><li><code>ScheduledFuture&lt;?&gt; schedule(Runnable/Callable&lt;V&gt;, long delay, TimeUnit u)</code>：延迟执行任务</li><li><code>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable/Callable&lt;V&gt;, long initialDelay, long period, TimeUnit unit)</code>：定时执行周期任务，不考虑执行的耗时，参数为初始延迟时间、间隔时间、单位</li><li><code>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable/Callable&lt;V&gt;, long initialDelay, long delay, TimeUnit unit)</code>：定时执行周期任务，考虑执行的耗时，参数为初始延迟时间、间隔时间、单位</li></ul><p>基本使用：</p><ul><li>延迟任务，但是出现异常并不会在控制台打印，也不会影响其他线程的执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">// 线程池大小为1时也是串行执行</span></span><br><span class="line">    <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 添加两个任务，都在 1s 后同时执行</span></span><br><span class="line">    executor.schedule(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务1，执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="comment">//int i = 1 / 0;</span></span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">2000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    executor.schedule(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务2，执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定时任务 scheduleAtFixedRate：<strong>一次任务的启动到下一次任务的启动</strong>之间只要大于等于间隔时间，抢占到 CPU 就会立即执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;start...&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">    pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;running...&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*start...Sat Apr 24 18:08:12 CST 2021</span></span><br><span class="line"><span class="comment">running...Sat Apr 24 18:08:13 CST 2021</span></span><br><span class="line"><span class="comment">running...Sat Apr 24 18:08:15 CST 2021</span></span><br><span class="line"><span class="comment">running...Sat Apr 24 18:08:17 CST 2021</span></span><br></pre></td></tr></table></figure><ul><li>定时任务 scheduleWithFixedDelay：<strong>一次任务的结束到下一次任务的启动之间</strong>等于间隔时间，抢占到 CPU 就会立即执行，这个方法才是真正的设置两个任务之间的间隔</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;start...&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">    pool.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;running...&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*start...Sat Apr 24 18:11:41 CST 2021</span></span><br><span class="line"><span class="comment">running...Sat Apr 24 18:11:42 CST 2021</span></span><br><span class="line"><span class="comment">running...Sat Apr 24 18:11:45 CST 2021</span></span><br><span class="line"><span class="comment">running...Sat Apr 24 18:11:48 CST 2021</span></span><br></pre></td></tr></table></figure><h4 id="成员属性-3"><a href="#成员属性-3" class="headerlink" title="成员属性"></a>成员属性</h4><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><ul><li>shutdown 后是否继续执行周期任务：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> continueExistingPeriodicTasksAfterShutdown;</span><br></pre></td></tr></table></figure><ul><li>shutdown 后是否继续执行延迟任务：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">executeExistingDelayedTasksAfterShutdown</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ul><li>取消方法是否将该任务从队列中移除：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认 false，不移除，等到线程拿到任务之后抛弃</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">removeOnCancel</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><ul><li>任务的序列号，可以用来比较优先级：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">sequencer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br></pre></td></tr></table></figure><h5 id="延迟任务"><a href="#延迟任务" class="headerlink" title="延迟任务"></a>延迟任务</h5><p>ScheduledFutureTask 继承 FutureTask，实现 RunnableScheduledFuture 接口，具有延迟执行的特点，覆盖 FutureTask 的 run 方法来实现对<strong>延时执行、周期执行</strong>的支持。对于延时任务调用 FutureTask#run，而对于周期性任务则调用 FutureTask#runAndReset 并且在成功之后根据 fixed-delay&#x2F;fixed-rate 模式来设置下次执行时间并重新将任务塞到工作队列</p><p>在调度线程池中无论是 runnable 还是 callable，无论是否需要延迟和定时，所有的任务都会被封装成 ScheduledFutureTask</p><p>成员变量：</p><ul><li>任务序列号：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> sequenceNumber;</span><br></pre></td></tr></table></figure><ul><li>执行时间：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> time;                        <span class="comment">// 任务可以被执行的时间，交付时间，以纳秒表示</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> period;        <span class="comment">// 0 表示非周期任务，正数表示 fixed-rate 模式的周期，负数表示 fixed-delay 模式</span></span><br></pre></td></tr></table></figure><ul><li>fixed-rate：两次开始启动的间隔，fixed-delay：一次执行结束到下一次开始启动</li><li>实际的任务对象：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RunnableScheduledFuture&lt;V&gt; outerTask = <span class="built_in">this</span>;</span><br></pre></td></tr></table></figure><ul><li>任务在队列数组中的索引下标：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DelayedWorkQueue 底层使用的数据结构是最小堆，记录当前任务在堆中的索引，-1 代表删除</span></span><br><span class="line"><span class="type">int</span> heapIndex;</span><br></pre></td></tr></table></figure><p>成员方法：</p><ul><li>构造方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="type">long</span> ns, <span class="type">long</span> period) &#123;</span><br><span class="line">    <span class="built_in">super</span>(r, result);</span><br><span class="line">    <span class="comment">// 任务的触发时间</span></span><br><span class="line">    <span class="built_in">this</span>.time = ns;</span><br><span class="line">    <span class="comment">// 任务的周期，多长时间执行一次</span></span><br><span class="line">    <span class="built_in">this</span>.period = period;</span><br><span class="line">    <span class="comment">// 任务的序号</span></span><br><span class="line">    <span class="built_in">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>compareTo()：ScheduledFutureTask 根据执行时间 time 正序排列，如果执行时间相同，在按照序列号 sequenceNumber 正序排列，任务需要放入 DelayedWorkQueue，延迟队列中使用该方法按照从小到大进行排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Delayed other)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (other == <span class="built_in">this</span>) <span class="comment">// compare zero if same object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">        <span class="comment">// 类型强转</span></span><br><span class="line">        ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</span><br><span class="line">        <span class="comment">// 比较者 - 被比较者的执行时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">diff</span> <span class="operator">=</span> time - x.time;</span><br><span class="line">        <span class="comment">// 比较者先执行</span></span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 被比较者先执行</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 比较者的序列号小</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不是 ScheduledFutureTask 类型时，根据延迟时间排序</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">diff</span> <span class="operator">=</span> getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);</span><br><span class="line">    <span class="keyword">return</span> (diff &lt; <span class="number">0</span>) ? -<span class="number">1</span> : (diff &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>run()：执行任务，非周期任务直接完成直接结束，<strong>周期任务执行完后会设置下一次的执行时间，重新放入<strong><strong>线程池</strong></strong>的阻塞队列</strong>，如果线程池中的线程数量少于核心线程，就会添加 Worker 开启新线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 是否周期性，就是判断 period 是否为 0</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">periodic</span> <span class="operator">=</span> isPeriodic();</span><br><span class="line">    <span class="comment">// 根据是否是周期任务检查当前状态能否执行任务，不能执行就取消任务</span></span><br><span class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class="line">        cancel(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 非周期任务，直接调用 FutureTask#run 执行</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">        ScheduledFutureTask.<span class="built_in">super</span>.run();</span><br><span class="line">    <span class="comment">// 周期任务的执行，返回 true 表示执行成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="built_in">super</span>.runAndReset()) &#123;</span><br><span class="line">        <span class="comment">// 设置周期任务的下一次执行时间</span></span><br><span class="line">        setNextRunTime();</span><br><span class="line">        <span class="comment">// 任务的下一次执行安排，如果当前线程池状态可以执行周期任务，加入队列，并开启新线程</span></span><br><span class="line">        reExecutePeriodic(outerTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>周期任务正常完成后<strong>任务的状态不会变化</strong>，依旧是 NEW，不会设置 outcome 属性。但是如果本次任务执行出现异常，会进入 setException 方法将任务状态置为异常，把异常保存在 outcome 中，方法返回 false，后续的该任务将不会再周期的执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">runAndReset</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 任务不是新建的状态了，或者被别的线程执行了，直接返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset, <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ran</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; s == NEW) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行方法，没有返回值</span></span><br><span class="line">                c.call();</span><br><span class="line">                ran = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">// 出现异常，把任务设置为异常状态，唤醒所有的 get 阻塞线程</span></span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 执行完成把执行线程引用置为 null</span></span><br><span class="line">        runner = <span class="literal">null</span>;</span><br><span class="line">        s = state;</span><br><span class="line">        <span class="comment">// 如果线程被中断进行中断处理</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果正常执行，返回 true，并且任务状态没有被取消</span></span><br><span class="line">    <span class="keyword">return</span> ran &amp;&amp; s == NEW;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务下一次的触发时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setNextRunTime</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">p</span> <span class="operator">=</span> period;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// fixed-rate 模式，【时间设置为上一次执行任务的时间 + p】，两次任务执行的时间差</span></span><br><span class="line">        time += p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// fixed-delay 模式，下一次执行时间是【当前这次任务结束的时间（就是现在） + delay 值】</span></span><br><span class="line">        time = triggerTime(-p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>reExecutePeriodic()<strong>：准备任务的下一次执行，重新放入阻塞任务队列</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ScheduledThreadPoolExecutor#reExecutePeriodic</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">reExecutePeriodic</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (canRunInCurrentRunState(<span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// 【放入任务队列】</span></span><br><span class="line">        <span class="built_in">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="comment">// 如果提交完任务之后，线程池状态变为了 shutdown 状态，需要再次检查是否可以执行，</span></span><br><span class="line">        <span class="comment">// 如果不能执行且任务还在队列中未被取走，则取消任务</span></span><br><span class="line">        <span class="keyword">if</span> (!canRunInCurrentRunState(<span class="literal">true</span>) &amp;&amp; remove(task))</span><br><span class="line">            task.cancel(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 当前线程池状态可以执行周期任务，加入队列，并【根据线程数量是否大于核心线程数确定是否开启新线程】</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>cancel()：取消任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用父类 FutureTask#cancel 来取消任务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">cancelled</span> <span class="operator">=</span> <span class="built_in">super</span>.cancel(mayInterruptIfRunning);</span><br><span class="line">    <span class="comment">// removeOnCancel 用于控制任务取消后是否应该从阻塞队列中移除</span></span><br><span class="line">    <span class="keyword">if</span> (cancelled &amp;&amp; removeOnCancel &amp;&amp; heapIndex &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 从等待队列中删除该任务，并调用 tryTerminate() 判断是否需要停止线程池</span></span><br><span class="line">        remove(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> cancelled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h5><p>DelayedWorkQueue 是支持延时获取元素的阻塞队列，内部采用优先队列 PriorityQueue（小根堆、满二叉树）存储元素</p><p>其他阻塞队列存储节点的数据结构大都是链表，<strong>延迟队列是数组</strong>，所以延迟队列出队头元素后需要<strong>让其他元素（尾）替换到头节点</strong>，防止空指针异常</p><p>成员变量：</p><ul><li>容量：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;                        <span class="comment">// 初始容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;                                                                        <span class="comment">// 节点数量</span></span><br><span class="line"><span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt;[] queue = </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">RunnableScheduledFuture</span>&lt;?&gt;[INITIAL_CAPACITY];        <span class="comment">// 存放节点</span></span><br></pre></td></tr></table></figure><ul><li>锁：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();        <span class="comment">// 控制并发</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">available</span> <span class="operator">=</span> lock.newCondition();<span class="comment">// 条件队列</span></span><br></pre></td></tr></table></figure><ul><li>阻塞等待头节点的线程：线程池内的某个线程去 take() 获取任务时，如果延迟队列顶层节点不为 null（队列内有任务），但是节点任务还不到触发时间，线程就去检查<strong>队列的</strong> <strong>leader****字段</strong>是否被占用<ul><li>如果未被占用，则当前线程占用该字段，然后当前线程到 available 条件队列指定超时时间 <code>堆顶任务.time - now()</code> 挂起</li><li>如果被占用，当前线程直接到 available 条件队列不指定超时时间的挂起</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leader 在 available 条件队列内是首元素，它超时之后会醒过来，然后再次将堆顶元素获取走，获取走之后，take()结束之前，会调用是 available.signal() 唤醒下一个条件队列内的等待者，然后释放 lock，下一个等待者被唤醒后去到 AQS 队列，做 acquireQueue(node) 逻辑</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Thread</span> <span class="variable">leader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>成员方法</p><ul><li>offer()：插入节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Runnable x)</span> &#123;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;</span><br><span class="line">    <span class="comment">// 队列锁，增加删除数据时都要加锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="comment">// 队列数量大于存放节点的数组长度，需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">            <span class="comment">// 扩容为原来长度的 1.5 倍</span></span><br><span class="line">            grow();</span><br><span class="line">        size = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当前是第一个要插入的节点</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            queue[<span class="number">0</span>] = e;</span><br><span class="line">            <span class="comment">// 修改 ScheduledFutureTask 的 heapIndex 属性，表示该对象在队列里的下标</span></span><br><span class="line">            setIndex(e, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 向上调整元素的位置，并更新 heapIndex </span></span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 情况1：当前任务是第一个加入到 queue 内的任务，所以在当前任务加入到 queue 之前，take() 线程会直接</span></span><br><span class="line">        <span class="comment">//                到 available 队列不设置超时的挂起，并不会去占用 leader 字段，这时需会唤醒一个线程 让它去消费</span></span><br><span class="line">               <span class="comment">// 情况2：当前任务【优先级最高】，原堆顶任务可能还未到触发时间，leader 线程设置超时的在 available 挂起</span></span><br><span class="line">        <span class="comment">//                原先的 leader 等待的是原先的头节点，所以 leader 已经无效，需要将 leader 线程唤醒，</span></span><br><span class="line">        <span class="comment">//                唤醒之后它会检查堆顶，如果堆顶任务可以被消费，则直接获取走，否则继续成为 leader 等待新堆顶任务</span></span><br><span class="line">        <span class="keyword">if</span> (queue[<span class="number">0</span>] == e) &#123;</span><br><span class="line">            <span class="comment">// 将 leader 设置为 null</span></span><br><span class="line">            leader = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 直接随便唤醒等待头结点的阻塞线程</span></span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入新节点后对堆进行调整，进行节点上移，保持其特性【节点的值小于子节点的值】，小顶堆</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父节点，就是堆排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; e = queue[parent];</span><br><span class="line">        <span class="comment">// key 和父节点比，如果大于父节点可以直接返回，否则就继续上浮</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        setIndex(e, k);</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">    setIndex(key, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>poll()：非阻塞获取头结点，<strong>获取执行时间最近并且可以执行的</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非阻塞获取</span></span><br><span class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; poll() &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取队头节点，因为是小顶堆</span></span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 头结点为空或者的延迟时间没到返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 头结点达到延迟时间，【尾节点成为替代节点下移调整堆结构】，返回头结点</span></span><br><span class="line">            <span class="keyword">return</span> finishPoll(first);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt; finishPoll(RunnableScheduledFuture&lt;?&gt; f) &#123;</span><br><span class="line">    <span class="comment">// 获取尾索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> --size;</span><br><span class="line">    <span class="comment">// 获取尾节点</span></span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; x = queue[s];</span><br><span class="line">    <span class="comment">// 将堆结构最后一个节点占用的 slot 设置为 null，因为该节点要尝试升级成堆顶，会根据特性下调</span></span><br><span class="line">    queue[s] = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// s == 0 说明 当前堆结构只有堆顶一个节点，此时不需要做任何的事情</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 从索引处 0 开始向下调整</span></span><br><span class="line">        siftDown(<span class="number">0</span>, x);</span><br><span class="line">    <span class="comment">// 出队的元素索引设置为 -1</span></span><br><span class="line">    setIndex(f, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>take()：阻塞获取头节点，读取当前堆中最小的也就是触发时间最近的任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 保证线程安全</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 头节点</span></span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// 等待队列不空，直至有任务通过 offer 入队并唤醒</span></span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 获取头节点的延迟时间是否到时</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 到达触发时间，获取头节点并调整堆，重新选择延迟时间最小的节点放入头部</span></span><br><span class="line">                    <span class="keyword">return</span> finishPoll(first);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 逻辑到这说明头节点的延迟时间还没到</span></span><br><span class="line">                first = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 说明有 leader 线程在等待获取头节点，当前线程直接去阻塞等待</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="literal">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 没有 leader 线程，【当前线程作为leader线程，并设置头结点的延迟时间作为阻塞时间】</span></span><br><span class="line">                    <span class="type">Thread</span> <span class="variable">thisThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 在条件队列 available 使用带超时的挂起（堆顶任务.time - now() 纳秒值..）</span></span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                        <span class="comment">// 到达阻塞时间时，当前线程会从这里醒来来</span></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// t堆顶更新，leader 置为 null，offer 方法释放锁后，</span></span><br><span class="line">                        <span class="comment">// 有其它线程通过 take/poll 拿到锁,读到 leader == null，然后将自身更新为leader。</span></span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            <span class="comment">// leader 置为 null 用以接下来判断是否需要唤醒后继线程</span></span><br><span class="line">                            leader = <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 没有 leader 线程，头结点不为 null，唤醒阻塞获取头节点的线程，</span></span><br><span class="line">        <span class="comment">// 【如果没有这一步，就会出现有了需要执行的任务，但是没有线程去执行】</span></span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="literal">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="literal">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>remove()：删除节点，堆移除一个元素的时间复杂度是 O(log n)，<strong>延迟任务维护了 heapIndex</strong>，直接访问的时间复杂度是 O(1)，从而可以更快的移除元素，任务在队列中被取消后会进入该逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object x)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 查找对象在队列数组中的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexOf(x);</span><br><span class="line">        <span class="comment">// 节点不存在，返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 修改元素的 heapIndex，-1 代表删除</span></span><br><span class="line">        setIndex(queue[i], -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 尾索引是长度-1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> --size;</span><br><span class="line">        <span class="comment">// 尾节点作为替代节点</span></span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; replacement = queue[s];</span><br><span class="line">        queue[s] = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// s == i 说明头节点就是尾节点，队列空了</span></span><br><span class="line">        <span class="keyword">if</span> (s != i) &#123;</span><br><span class="line">            <span class="comment">// 向下调整</span></span><br><span class="line">            siftDown(i, replacement);</span><br><span class="line">            <span class="comment">// 说明没发生调整</span></span><br><span class="line">            <span class="keyword">if</span> (queue[i] == replacement)</span><br><span class="line">                <span class="comment">// 上移和下移不可能同时发生，替代节点大于子节点时下移，否则上移</span></span><br><span class="line">                siftUp(i, replacement);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="成员方法-2"><a href="#成员方法-2" class="headerlink" title="成员方法"></a>成员方法</h4><h5 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h5><ul><li>schedule()：延迟执行方法，并指定执行的时间，默认是当前时间</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="comment">// 以零延时任务的形式实现</span></span><br><span class="line">    schedule(command, <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="type">long</span> delay, TimeUnit unit) &#123;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span> || unit == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 没有做任何操作，直接将 task 返回，该方法主要目的是用于子类扩展，并且【根据延迟时间设置任务触发的时间点】</span></span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command, <span class="keyword">new</span> <span class="title class_">ScheduledFutureTask</span>&lt;Void&gt;(</span><br><span class="line">                                                                                                command, <span class="literal">null</span>, triggerTime(delay, unit)));</span><br><span class="line">    <span class="comment">// 延迟执行</span></span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回【当前时间 + 延迟时间】，就是触发当前任务执行的时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">triggerTime</span><span class="params">(<span class="type">long</span> delay, TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置触发的时间</span></span><br><span class="line">    <span class="keyword">return</span> triggerTime(unit.toNanos((delay &lt; <span class="number">0</span>) ? <span class="number">0</span> : delay));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="title function_">triggerTime</span><span class="params">(<span class="type">long</span> delay)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 delay &lt; Long.Max_VALUE/2，则下次执行时间为当前时间 +delay</span></span><br><span class="line">    <span class="comment">// 否则为了避免队列中出现由于溢出导致的排序紊乱,需要调用overflowFree来修正一下delay</span></span><br><span class="line">    <span class="keyword">return</span> now() + ((delay &lt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>)) ? delay : overflowFree(delay));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>overflowFree 的原因：如果某个任务的 delay 为负数，说明当前可以执行（其实早该执行了）。阻塞队列中维护任务顺序是基于 compareTo 比较的，比较两个任务的顺序会用 time 相减。那么可能出现一个 delay 为正数减去另一个为负数的 delay，结果上溢为负数，则会导致 compareTo 产生错误的结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">overflowFree</span><span class="params">(<span class="type">long</span> delay)</span> &#123;</span><br><span class="line">    <span class="type">Delayed</span> <span class="variable">head</span> <span class="operator">=</span> (Delayed) <span class="built_in">super</span>.getQueue().peek();</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">headDelay</span> <span class="operator">=</span> head.getDelay(NANOSECONDS);</span><br><span class="line">        <span class="comment">// 判断一下队首的delay是不是负数，如果是正数就不用管，怎么减都不会溢出</span></span><br><span class="line">        <span class="comment">// 否则拿当前 delay 减去队首的 delay 来比较看，如果不出现上溢，排序不会乱</span></span><br><span class="line">                <span class="comment">// 不然就把当前 delay 值给调整为 Long.MAX_VALUE + 队首 delay</span></span><br><span class="line">        <span class="keyword">if</span> (headDelay &lt; <span class="number">0</span> &amp;&amp; (delay - headDelay &lt; <span class="number">0</span>))</span><br><span class="line">            delay = Long.MAX_VALUE + headDelay;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>scheduleAtFixedRate()：定时执行，一次任务的启动到下一次任务的启动的间隔</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="type">long</span> initialDelay, <span class="type">long</span> period,</span><br><span class="line">                                              TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span> || unit == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="comment">// 任务封装，【指定初始的延迟时间和周期时间】</span></span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft =<span class="keyword">new</span> <span class="title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="literal">null</span>,</span><br><span class="line">                                      triggerTime(initialDelay, unit), unit.toNanos(period));</span><br><span class="line">    <span class="comment">// 默认返回本身</span></span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    <span class="comment">// 开始执行这个任务</span></span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>scheduleWithFixedDelay()：定时执行，一次任务的结束到下一次任务的启动的间隔</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="type">long</span> initialDelay, <span class="type">long</span> delay,</span><br><span class="line">                                                 TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span> || unit == <span class="literal">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="comment">// 任务封装，【指定初始的延迟时间和周期时间】，周期时间为 - 表示是 fixed-delay 模式</span></span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft = <span class="keyword">new</span> <span class="title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="literal">null</span>,</span><br><span class="line">                                      triggerTime(initialDelay, unit), unit.toNanos(-delay));</span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行任务"><a href="#运行任务" class="headerlink" title="运行任务"></a>运行任务</h5><ul><li>delayedExecute()：<strong>校验<strong><strong>线程池</strong></strong>状态</strong>，延迟或周期性任务的主要执行方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> &#123;</span><br><span class="line">    <span class="comment">// 线程池是 SHUTDOWN 状态，需要执行拒绝策略</span></span><br><span class="line">    <span class="keyword">if</span> (isShutdown())</span><br><span class="line">        reject(task);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 把当前任务放入阻塞队列，因为需要【获取执行时间最近的】，当前任务需要比较</span></span><br><span class="line">        <span class="built_in">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="comment">// 线程池状态为 SHUTDOWN 并且不允许执行任务了，就从队列删除该任务，并设置任务的状态为取消状态</span></span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp; !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp; remove(task))</span><br><span class="line">            task.cancel(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 可以执行</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ensurePrestart()：<strong>开启线程执行任务</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor#ensurePrestart</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">ensurePrestart</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(ctl.get());</span><br><span class="line">    <span class="comment">// worker数目小于corePoolSize，则添加一个worker。</span></span><br><span class="line">    <span class="keyword">if</span> (wc &lt; corePoolSize)</span><br><span class="line">        <span class="comment">// 第二个参数 true 表示采用核心线程数量限制，false 表示采用 maximumPoolSize</span></span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// corePoolSize = 0的情况，至少开启一个线程，【担保机制】</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wc == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>canRunInCurrentRunState()：任务运行时都会被调用以校验当前状态是否可以运行任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">canRunInCurrentRunState</span><span class="params">(<span class="type">boolean</span> periodic)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据是否是周期任务判断，在线程池 shutdown 后是否继续执行该任务，默认非周期任务是继续执行的</span></span><br><span class="line">    <span class="keyword">return</span> isRunningOrShutdown(periodic ? continueExistingPeriodicTasksAfterShutdown :</span><br><span class="line">                               executeExistingDelayedTasksAfterShutdown);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>onShutdown()：删除并取消工作队列中的不需要再执行的任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">onShutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; q = <span class="built_in">super</span>.getQueue();</span><br><span class="line">    <span class="comment">// shutdown 后是否仍然执行延时任务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">keepDelayed</span> <span class="operator">=</span> getExecuteExistingDelayedTasksAfterShutdownPolicy();</span><br><span class="line">    <span class="comment">// shutdown 后是否仍然执行周期任务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">keepPeriodic</span> <span class="operator">=</span> getContinueExistingPeriodicTasksAfterShutdownPolicy();</span><br><span class="line">    <span class="comment">// 如果两者皆不可，则对队列中【所有任务】调用 cancel 取消并清空队列</span></span><br><span class="line">    <span class="keyword">if</span> (!keepDelayed &amp;&amp; !keepPeriodic) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object e : q.toArray())</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RunnableScheduledFuture&lt;?&gt;)</span><br><span class="line">                ((RunnableScheduledFuture&lt;?&gt;) e).cancel(<span class="literal">false</span>);</span><br><span class="line">        q.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object e : q.toArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RunnableScheduledFuture) &#123;</span><br><span class="line">                RunnableScheduledFuture&lt;?&gt; t = (RunnableScheduledFuture&lt;?&gt;)e;</span><br><span class="line">                <span class="comment">// 不需要执行的任务删除并取消，已经取消的任务也需要从队列中删除</span></span><br><span class="line">                <span class="keyword">if</span> ((t.isPeriodic() ? !keepPeriodic : !keepDelayed) ||</span><br><span class="line">                    t.isCancelled()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (q.remove(t))</span><br><span class="line">                        t.cancel(<span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为任务被从队列中清理掉，所以需要调用 tryTerminate 尝试【改变线程池的状态】</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h3><p>Fork&#x2F;Join：线程池的实现，体现是分治思想，适用于能够进行任务拆分的 CPU 密集型运算，用于<strong>并行计算</strong></p><p>任务拆分：将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列都可以用分治思想进行求解</p><ul><li>Fork&#x2F;Join 在<strong>分治<strong><strong>的基础上加入了</strong></strong>多线程</strong>，把每个任务的分解和合并交给不同的线程来完成，提升了运算效率</li><li>ForkJoin 使用 ForkJoinPool 来启动，是一个特殊的线程池，默认会创建与 CPU 核心数大小相同的线程池</li><li>任务有返回值继承 RecursiveTask，没有返回值继承 RecursiveAction</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">4</span>);</span><br><span class="line">    System.out.println(pool.invoke(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="number">5</span>)));</span><br><span class="line">    <span class="comment">//拆分  5 + MyTask(4) --&gt; 4 + MyTask(3) --&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1~ n 之间整数的和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyTask&#123;&quot;</span> + <span class="string">&quot;n=&quot;</span> + n + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 n 已经为 1，可以求得结果了</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将任务进行拆分(fork)</span></span><br><span class="line">        <span class="type">MyTask</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(n - <span class="number">1</span>);</span><br><span class="line">        t1.fork();</span><br><span class="line">        <span class="comment">// 合并(join)结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> n + t1.join();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续拆分优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AddTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="type">int</span> begin;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddTask</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.begin = begin;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> + begin + <span class="string">&quot;,&quot;</span> + end + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 5, 5</span></span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> begin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4, 5  防止多余的拆分  提高效率</span></span><br><span class="line">        <span class="keyword">if</span> (end - begin == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> end + begin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1 5</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (end + begin) / <span class="number">2</span>; <span class="comment">// 3</span></span><br><span class="line">        <span class="type">AddTask</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask</span>(begin, mid); <span class="comment">// 1,3</span></span><br><span class="line">        t1.fork();</span><br><span class="line">        <span class="type">AddTask</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask</span>(mid + <span class="number">1</span>, end); <span class="comment">// 4,5</span></span><br><span class="line">        t2.fork();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> t1.join() + t2.join();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ForkJoinPool 实现了<strong>工作窃取算法</strong>来提高 CPU 的利用率：</p><ul><li>每个线程都维护了一个<strong>双端队列</strong>，用来存储需要执行的任务</li><li>工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行</li><li>窃取的必须是<strong>最晚的任务</strong>，避免和队列所属线程发生竞争，但是队列中只有一个任务时还是会发生竞争</li></ul><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>享元模式（Flyweight pattern）： 用于减少创建对象的数量，以减少内存占用和提高性能，这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式</p><p>异步模式：让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务，也可将其归类为分工模式，典型实现就是<strong>线程池</strong></p><p>工作机制：享元模式尝试<strong>重用现有的同类对象</strong>，<strong>如果未找到匹配的对象，则创建新对象</strong></p><p>自定义连接池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Pool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pool</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> pool.borrow();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            pool.free(con);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pool</span> &#123;</span><br><span class="line">    <span class="comment">//连接池的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> poolSize;</span><br><span class="line">    <span class="comment">//连接对象的数组</span></span><br><span class="line">    <span class="keyword">private</span> Connection[] connections;</span><br><span class="line">    <span class="comment">//连接状态数组 0表示空闲  1表示繁忙</span></span><br><span class="line">    <span class="keyword">private</span> AtomicIntegerArray states;  <span class="comment">//int[] -&gt; AtomicIntegerArray</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pool</span><span class="params">(<span class="type">int</span> poolSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.poolSize = poolSize;</span><br><span class="line">        <span class="built_in">this</span>.connections = <span class="keyword">new</span> <span class="title class_">Connection</span>[poolSize];</span><br><span class="line">        <span class="built_in">this</span>.states = <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[poolSize]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            connections[i] = <span class="keyword">new</span> <span class="title class_">MockConnection</span>(<span class="string">&quot;连接&quot;</span> + (i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用连接</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">borrow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (states.get(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (states.compareAndSet(i, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; borrow &quot;</span> +  connections[i]);</span><br><span class="line">                        <span class="keyword">return</span> connections[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有空闲连接，当前线程等待</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; wait...&quot;</span>);</span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归还连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(Connection con)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connections[i] == con) &#123;<span class="comment">//判断是否是同一个对象</span></span><br><span class="line">                states.set(i, <span class="number">0</span>);<span class="comment">//不用cas的原因是只会有一个线程使用该连接</span></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; free &quot;</span> + con);</span><br><span class="line">                    <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MockConnection</span> <span class="keyword">implements</span> <span class="title class_">Connection</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM快速入门</title>
      <link href="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>本笔记基于视频 <a href="https://www.bilibili.com/video/BV1yE411Z7AP%EF%BC%8C%E6%97%A8%E5%9C%A8%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8JVM%E3%80%82">https://www.bilibili.com/video/BV1yE411Z7AP，旨在快速入门JVM。</a></p><p>笔记借 <a href="https://blog.csdn.net/qq/_45966440/article/details/120824295?spm=1001.2014.3001.5502">https://blog.csdn.net/qq\_45966440/article/details/120824295?spm=1001.2014.3001.5502</a></p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-12.png"></p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-14.png"></p><ul><li><p>ClassLoader：Java 代码编译成二进制后，会经过类加载器，这样才能加载到 JVM 中运行。</p></li><li><p>Method Area：类是放在方法区中。</p></li><li><p>Heap：类的实例对象。</p></li></ul><p>当类调用方法时，会用到 JVM Stack、PC Register、本地方法栈。</p><p>方法执行时的每行代码是有执行引擎中的解释器逐行执行，方法中的热点代码频繁调用的方法，由 JIT 编译器优化后执行，GC 会对堆中不用的对象进行回收。需要和操作系统打交道就需要使用到本地方法接口。</p><h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h1><h2 id="程序计数器PC-Register"><a href="#程序计数器PC-Register" class="headerlink" title="程序计数器PC Register"></a>程序计数器PC Register</h2><p>和操作系统中的程序计数器类似，作用是记录吓一跳jvm指令的执行地址<strong>行号</strong>。</p><p>特点：</p><ul><li><p><strong>线程私有(每一个线程有一个程序计数器)</strong></p></li><li><p><strong>不存在内存溢出(jvm规范规定的，程序计数器是 JVM 内存区域中唯一一个不会抛出 <code>OutOfMemoryError</code> 的区域。)</strong></p></li></ul><p>如下图所示，以下是java代码以及对应编译成的二进制字节码(jvm指令)。这些指令在不同操作系统下依旧一样，这些字节码还要通过解释器将其转换为机器码才能够被CPU执行。</p><p>多线程的环境下，如果两个线程发生了上下文切换(比如说CPU的时间轮转算法结束之后换线程)，那么程序计数器会记录线程下一行指令的地址行号，以便于接着往下执行(每个线程对应一个程序计数器)。</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li><p><strong>每个线程运行需要的内存空间，称为虚拟机栈</strong></p></li><li><p><strong>每个栈由多个栈帧（Frame）组成，对应着每次调用方法时所占用的内存。</strong></p></li></ol><p>&#x20;     可以想一下，一个frame对应一个方法的调用，每个方法运行时所需要的内存就称为一个frame(如方法中的参数、局部变量、返回值等都需要内存，划分一个frame)，frame出栈就代表frame被释放。</p><p>&#x20;      一个栈可以有多个frame组成，因为一个方法可以调用其他方法。</p><ul><li><strong>每个线程只能有一个活动栈帧，对应着当前正在执行的方法</strong></li></ul><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-11.png"></p><p>问题辨析：</p><ol><li>垃圾回收是否涉及栈内存？</li></ol><p>不会。栈内存是方法调用产生的，方法调用结束后会弹出栈。</p><ul><li>栈内存分配越大越好吗？</li></ul><p>不是。因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</p><p>如何手动定义栈的大小呢？</p><p>可以设置-Xss参数，例如-Xss1m</p><ul><li>方法的局部变量是否保证线程安全？</li></ul><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-10.png"></p><p>对于以上代码如果多个线程同时调用这个方法，会造成冲突吗？</p><ul><li><strong>如果方法内部的变量没有逃离方法的作用访问，它是线程安全的。</strong></li></ul><p>如上图所示，不同的线程会创建不同的局部变量存到各自的frame中，他们是隔离的</p><ul><li><strong>如果是局部变量引用了对象，并逃离了方法的访问，那就要考虑线程安全问题。&#x20;</strong></li></ul><p>比如我定一个static，那他就是共享的了，就不安全了。</p><h3 id="分析以下代码是否会是线程安全的？"><a href="#分析以下代码是否会是线程安全的？" class="headerlink" title="分析以下代码是否会是线程安全的？"></a>分析以下代码是否会是线程安全的？</h3><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-9.png"></p><p>第一个不会，他是局部变量。</p><p>第二个会，因为他是作为参数存进来的，可能有两个线程同时使用同一个对象作为参数调用该函数。</p><p>第三个也不行，他讲局部变量作为返回值返回来了，可能被不同的线程修改。</p><h3 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h3><p>栈内存溢出的情况：</p><ol><li><p>栈帧frame过多</p></li><li><p>栈帧过大</p></li></ol><p>注意，只要调用了一个方法，不管他是不是static，是不是自己调用自己都是会新建一个栈帧的。</p><h3 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h3><ol><li>CPU占用过多</li></ol><ul><li><p>在linux中，先用top定位那个进程对cpu的占用过高</p></li><li><p>再用ps H -eo pid,tid,%cpu | grep 进程id进一步定位那个线程引起的CPU占用过高。</p></li><li><p>jstack 进程 id 通过查看进程中的线程的 nid ，刚才通过 ps 命令看到的 tid 来对比定位，注意 jstack 查找出的线程 id 是 16 进制的，需要转换。</p></li><li><p>程序运行很长时间没有结果</p></li></ul><p>使用jstack查看是否存在死锁</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-13.png"></p><p>一些带有 native 关键字的方法就是需要 JAVA 去调用本地的C或者C++方法，因为 JAVA 有时候没法直接和操作系统底层交互，所以需要用到本地方法栈，服务于带 native 关键字的方法。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>Heap 堆</p><p>通过new关键字创建的对象都会被放在堆内存</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>它是线程共享，堆内存中的对象都需要考虑线程安全问题</p><p>有垃圾回收机制</p><p>2）堆内存溢出</p><p>java.lang.OutofMemoryError ：java heap space. 堆内存溢出</p><p>可以使用 -Xmx8m 来指定堆内存大小。</p><p>3）堆内存诊断</p><p>jps 工具</p><p>查看当前系统中有哪些 java 进程</p><p>jmap 工具</p><p>查看堆内存占用情况 jmap - heap 进程id</p><p>jconsole 工具</p><p>图形界面的，多功能的监测工具，可以连续监测</p><p>jvisualvm 工具</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区是各个<strong>线程共享</strong>的内存区域，它用于存储已被<strong>虚拟机加载的类信息(比如class文件)、常量、静态变量</strong>、即时编译器编译后的代码等数据。（什么是类信息：<strong>类版本号、方法、接口</strong>。）</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-8.png"></p><ul><li><p><strong>永久代</strong>用的<strong>堆内存</strong></p></li><li><p><strong>元空间</strong>用的<strong>本地内存</strong></p></li></ul><h4 id="方法区内存溢出"><a href="#方法区内存溢出" class="headerlink" title="方法区内存溢出"></a>方法区内存溢出</h4><ul><li><p>1.8以前会导致<strong>永久代</strong>内存溢出<code>java.lang.OutOfMemoryError: PermGen space</code></p></li><li><p>1.8以后会导致<strong>元空间</strong>内存溢出<code>java.lang.OutOfMemoryError: Metaspace</code></p></li></ul><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul><li><p>属于操作系统，常见于NIO操作时，用于数据缓冲区(如Bytebuffer)</p></li><li><p>分配回收成本较高，但读写性能高</p></li><li><p><strong>不受JVM内存回收管理</strong></p></li></ul><h4 id="分配和回收原理"><a href="#分配和回收原理" class="headerlink" title="分配和回收原理"></a>分配和回收原理</h4><p>读写过程</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-6.png"></p><p>系统缓冲区在内核态，可以简单理解为page cache。</p><p>使用了directbuffer</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-7.png"></p><p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<code>unsafe.freeMemory</code>来<strong>手动释放</strong></p><p>通过申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p><p>基于以上代码，过程如下：</p><p><strong>allocateDirect的实现</strong>：</p><p><strong>DirectByteBuffer类</strong></p><p>这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存</p><h3 id="使用-XX-DisableExplicitGC禁用显示GC"><a href="#使用-XX-DisableExplicitGC禁用显示GC" class="headerlink" title="使用-XX:+DisableExplicitGC禁用显示GC"></a>使用-XX:+DisableExplicitGC禁用显示GC</h3><p>如图</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-2.png"></p><p>显式的垃圾回收涉及到Full GC，会挥手新生代和老年代。</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-5.png"></p><ul><li><p>新生代（Young Generation）:新生代分为Eden Space和Survivor Space。在Eden Space中， 大多数新创建的对象首先存放在这里。Eden区相对较小，当Eden区满时，会触发一次Minor GC（新生代垃圾回收）。在Survivor Spaces中，通常分为两个相等大小的区域，称为S0（Survivor 0）和S1（Survivor 1）。在每次Minor GC后，存活下来的对象会被移动到其中一个Survivor空间，以继续它们的生命周期。这两个区域轮流充当对象的中转站，帮助区分短暂存活的对象和长期存活的对象。</p></li><li><p>老年代（Old Generation&#x2F;Tenured Generation）:存放过一次或多次Minor GC仍存活的对象会被移动到老年代。老年代中的对象生命周期较长，因此Major GC（也称为Full GC，涉及老年代的垃圾回收）发生的频率相对较低，但其执行时间通常比Minor GC长。老年代的空间通常比新生代大，以存储更多的长期存活对象。</p></li></ul><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="判断对象是否可以回收"><a href="#判断对象是否可以回收" class="headerlink" title="判断对象是否可以回收"></a>判断对象是否可以回收</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><ul><li><p>当一个对象被其他变量引用，该对象计数加一，当某个变量不再引用该对象，其计数减一</p></li><li><p>当一个对象引用没有被其他变量引用时，即计数变为0时，该对象就可以被回收</p></li></ul><p><strong>缺点</strong>：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-4.png"></p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</p><p>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果找不到，则表示可以回收</p><p>可以作为GC Root的对象</p><p>大致分为下图，加锁的对象有：</p><ul><li><p>系统的类对象，如hashmap这些</p></li><li><p>Native stack</p></li><li><p>活动的线程对象</p></li><li><p>加同步锁的对象</p></li></ul><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-1.png"></p><p>将上面来拆分，可分成这些常用的：</p><ul><li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象。</p></li><li><p>方法区中类静态属性引用的对象</p></li><li><p>方法区中常量引用的对象</p></li><li><p>本地方法栈中JNI（即一般说的Native方法）引用的对象</p></li><li><p>所有被同步锁（synchronized关键字）持有的对象。</p></li></ul><h3 id="java中的五种引用"><a href="#java中的五种引用" class="headerlink" title="java中的五种引用"></a>java中的五种引用</h3><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-3.png"></p><ol><li>强引用</li></ol><p>只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</p><ul><li>软引用</li></ul><p>仅有【软引用】引用该对象时，在垃圾回收后，内存仍不足时会再次出现垃圾回收，回收软引用对象</p><p>可以配合【引用队列】来释放软引用自身</p><ul><li>弱引用</li></ul><p>仅有【弱引用】引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</p><p>可以配合【引用队列】来释放弱引用自身</p><ul><li>虚引用</li></ul><p><strong>必须配合【引用队列】使用</strong>，主要配合 ByteBuffer 使用，被引用对象回收时，会将【虚引用】入队， 由 Reference Handler 线程调用虚引用相关方法释放【直接内存】</p><p>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</p><ul><li>终结器引用</li></ul><p>无需手动编码，但其内部配合【引用队列】使用，在垃圾回收时，【终结器引用】入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过【终结器引用】找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象</p><p>如上图，B对象不再引用A4对象。这时终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p><p>之前说ByteBuffer的时候说过他会创建一个Cleaner的虚引用对象，并将直接内存地址传递给虚引用对象。将来如果butebuffer被回收的时候，虚引用对象进入引用队列，后台的referencehandler的定时线程找是否有新入队列的这个cleaner，然后执行unsafe.freememory删除直接内存</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image.png"></p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-29.png"></p><h4 id="软引用实例"><a href="#软引用实例" class="headerlink" title="软引用实例"></a>软引用实例</h4><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-28.png"></p><p>如果我不想因为软引用被释放后，软引用队列中有null，可以使用引用队列。</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-25.png"></p><h4 id="弱引用实例"><a href="#弱引用实例" class="headerlink" title="弱引用实例"></a>弱引用实例</h4><p>弱引用只要没有强引用，每次垃圾回收都会尝试回收，但可能不会全部对象都被回收，而软引用是只有内存不足时并且不被强引用才会尝试回收。</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-27.png"></p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-26.png"></p><p><strong>这里之所以没有前面的所有都被回收是因为被放进了老年代（空间分配担保），老年代只有Full GC才会回收垃圾。</strong></p><p>可以看这篇文章</p><p><a href="https://developer.aliyun.com/article/1134938">https://developer.aliyun.com/article/1134938</a></p><p>写到进入老年代的一种方式是：<strong>动态对象年龄判定</strong>（按照空间区计算迁移条件）</p><ul><li>虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升到老年代，<strong>如果在Survivor区中相同年龄（设年龄为age）的对象的所有大小之和超过Survivor空间的一半，年龄大于或等于该年龄（age）的对象就可以直接进入老年代</strong>，无需等到<strong>MaxTenuringThreshold中要求的年龄</strong>。</li></ul><h4 id="弱引用作缓存"><a href="#弱引用作缓存" class="headerlink" title="弱引用作缓存"></a>弱引用作缓存</h4><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="1-标记清除算法"><a href="#1-标记清除算法" class="headerlink" title="1.标记清除算法"></a>1.标记清除算法</h3><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-24.png"></p><p><strong>定义</strong>：在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p><p>注意：这里的清除并不是将内存空间字节清零，而是记录这段内存的起始地址，下次分配内存的时候，会直接覆盖这段内存。</p><p><strong>优点</strong>：速度快</p><p><strong>缺点</strong>：容易产生内存碎片。一旦分配较大内存的对象，由于内存不连续，导致无法分配，最后就会造成内存溢出问题</p><h3 id="2-标记整理算法"><a href="#2-标记整理算法" class="headerlink" title="2.标记整理算法"></a>2.标记整理算法</h3><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-23.png"></p><p><strong>定义</strong>：在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后整理剩余的对象，将可用的对象移动到一起，使内存更加紧凑，连续的空间就更多。</p><p><strong>优点</strong>：不会有内存碎片</p><p><strong>缺点</strong>：速度慢</p><h3 id="3-复制算法"><a href="#3-复制算法" class="headerlink" title="3.复制算法"></a>3.复制算法</h3><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-22.png"></p><p>定义：将内存分为等大小的两个区域，FROM和TO（TO中为空）。将被GC Root引用的对象从FROM放入TO中，<strong>再回收不被GC Root引用的对象</strong>。然后<strong>交换FROM和TO</strong>。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p><p>优点：不会有内存碎片</p><p>缺点：会占用双倍的内存空间。</p><h2 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h2><h3 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h3><p>将堆内存分为<strong>新生代</strong>和<strong>老年代</strong>，新生代有划分为<strong>伊甸园</strong>，<strong>幸存区To</strong>，<strong>幸存区From</strong>。</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-21.png"></p><p>对象首先分配在伊甸园区域</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20.png"></p><p>伊甸园空间不足时，触发 <strong>Minor GC</strong>，伊甸园和 from 存活的对象使用 copy 复制到<strong>幸存区To</strong> 中，存活的对象<strong>年龄加 1</strong>并且交换 from to</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-19.png"></p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-18.png"></p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-16.png"></p><p>再次创建对象，若新生代的伊甸园又满了，则会再次触发 Minor GC（minor gc 会引发 <strong>stop the world</strong>，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行，因为回收的时候涉及到对象的地址发生改变），这时<strong>不仅会回收伊甸园中的垃圾，还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象寿命加1</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-17.png"></p><p>当对象寿命超过阈值时，会晋升至老年代，最大寿命是<strong>15</strong>（4bit）</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-15.png"></p><p>当老年代空间不足，会先尝试触发<strong>Minor GC</strong>，如果之后空间仍不足，那么触发 <strong>Full GC</strong>，<strong>stop the world</strong>的时间更长</p><h3 id="相关VM参数"><a href="#相关VM参数" class="headerlink" title="相关VM参数"></a>相关VM参数</h3><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-43.png"></p><h3 id="GC分析——大对象"><a href="#GC分析——大对象" class="headerlink" title="GC分析——大对象"></a>GC分析——大对象</h3><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-44.png"></p><p>如图，大对象在老年代空间足够但是新生代空间不够的时候会直接进入老年代，而不会在超过阈值之后再进入老年代。</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-41.png"></p><p>如果新生代+老年代都装不下，就会oom</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-42.png"></p><p>如果线程内存oom发生异常，进程不会崩溃（一个线程中的oom）。</p><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>相关概念：</p><p><strong>并行收集</strong>：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态</p><p><strong>并发收集</strong>：指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。用户程序在继续运行，而垃圾收集程序运行在另一个CPU上</p><p><strong>吞吐量</strong>：即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量 &#x3D; 运行用户代码时间 &#x2F; ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p><ol><li>串行</li></ol><ul><li><p>单线程</p></li><li><p>堆内存较小，适合个人电脑</p></li></ul><ul><li>吞吐量优先</li></ul><ul><li><p>多线程</p></li><li><p>堆内存较大，多核cpu</p></li><li><p>让单位时间内，STW（stop the world）的时间最短</p></li></ul><ul><li>响应时间优先</li></ul><ul><li><p>多线程</p></li><li><p>堆内存较大，多核cpu</p></li><li><p>尽可能让单次STW的时间最短</p></li></ul><h3 id="串行的垃圾回收器"><a href="#串行的垃圾回收器" class="headerlink" title="串行的垃圾回收器"></a>串行的垃圾回收器</h3><p>-XX: +UserSerialGC &#x3D; Serial + SerialOld</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-40.png"></p><p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象。</p><p><strong>阻塞</strong>：因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p><p><strong>Serial 收集器</strong>：</p><ul><li><p>定义：Serial收集器是最基本的、发展历史最悠久的收集器</p></li><li><p>特点：<strong>单线程</strong>收集器。采用<strong>复制</strong>算法。工作在<strong>新生代</strong></p></li></ul><p><strong>Serial Old收集器</strong>：</p><ul><li><p>定义：Serial Old是Serial收集器的老年代版本</p></li><li><p>特点：<strong>单线程</strong>收集器。采用<strong>标记-整理</strong>算法。工作在<strong>老年代</strong></p></li></ul><h3 id="吞吐量优先的垃圾回收器"><a href="#吞吐量优先的垃圾回收器" class="headerlink" title="吞吐量优先的垃圾回收器"></a>吞吐量优先的垃圾回收器</h3><ul><li><p>多线程</p></li><li><p>堆内存较大，多核cpu</p></li><li><p>让<strong>单位时间内</strong>暂停时间（STW）最短</p></li><li><p><strong>JDK1.8默认使用</strong>的垃圾回收器</p></li></ul><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-39.png"></p><p>注意jdk1.8之后第一行的垃圾回收器是默认开启的</p><p><strong>Parallel 收集器</strong>：</p><ul><li><p>定义：与吞吐量关系密切，故也称为吞吐量优先收集器</p></li><li><p>特点：<strong>并行的</strong>，工作于<strong>新生代</strong>，采用<strong>复制</strong>算法</p></li></ul><p><strong>Parallel Old 收集器</strong>：</p><ul><li><p>定义：是Parallel 收集器的老年代版本</p></li><li><p>特点：<strong>并行的</strong>，工作与<strong>老年代</strong>，采用<strong>标记-整理算法</strong></p></li></ul><p>GCTimeRatio的计算公式如下，ratio是除去垃圾回收的时间，如果时间不够，系统会调大堆的大小。</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-38.png"></p><h3 id="响应时间优先的垃圾回收器"><a href="#响应时间优先的垃圾回收器" class="headerlink" title="响应时间优先的垃圾回收器"></a>响应时间优先的垃圾回收器</h3><ul><li><p>多线程</p></li><li><p>堆内存较大，多核cpu</p></li><li><p>尽可能让<strong>单次的</strong>暂停时间（STW）最短</p></li></ul><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-30.png"></p><p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快，存在Stop The World</p><p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p><p><strong>重新标记</strong>：为了<strong>修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录</strong>。存在Stop The World</p><p><strong>并发清理</strong>：对标记的对象进行清除回收</p><p><strong>CMS收集器：</strong></p><p>定义：Concurrent Mark Sweep（并发，标记，清除）</p><p>特点：基于标记-清除算法的垃圾回收器。是并发的。工作在<strong>老年代</strong>。</p><p><strong>ParNew 收集器：</strong></p><p>定义：ParNew收集器其实就是<strong>Serial收集器的多线程版本</strong></p><p>特点：工作在新生代，基于复制算法的垃圾回收器。</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-31.png"></p><p>这个是设置当老年代中垃圾到达某一个比例时触发垃圾回收，留空间给最后的浮动垃圾。</p><p>CMS有一个特点就是会有内存碎片（注意他名字里的是sweep），可能导致之后的并发失败，退化到serialold进行整理。</p><h2 id="G1垃圾回收器"><a href="#G1垃圾回收器" class="headerlink" title="G1垃圾回收器"></a>G1垃圾回收器</h2><p><strong>定义</strong>：Garbage First</p><ul><li>JDK 9<strong>以后默认使用，而且替代了CMS 收集器</strong></li></ul><p><strong>适用场景</strong>：</p><ul><li><p>同时注重<strong>吞吐量</strong>（Throughput）和<strong>低延迟</strong>（Low latency），<strong>默认的暂停目标是 200 ms</strong></p></li><li><p>超大堆内存，会将<strong>堆划分为多个大小相等的 Region</strong></p></li><li><p>整体上是 <strong>标记+整理</strong> 算法（和CMS不一样，不会有内存碎片），两个区域（region）之间&#x662F;<strong>&#x20;复制</strong> 算法</p></li></ul><p><strong>相关参数</strong>：JDK8 并不是默认开启的，所需要参数开启</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-32.png"></p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-33.png"></p><p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;混合收集，回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收（重新开始）</p><ol><li><strong>Young Collection：存在Stop The World</strong></li></ol><p>分区算法region：分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p><p>E：伊甸园 S：幸存区 O：老年代</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-37.png"></p><ul><li><strong>Young Collection + CM</strong>：</li></ul><ul><li><p>CM：并发标记</p></li><li><p>在 Young GC 时会<strong>对 GC Root 进行初始标记</strong></p></li><li><p>在<strong>老年代占用堆内存的比例达到阈值时</strong>，对进行并发标记（不会STW），阈值可以根据用户来进行设定</p></li></ul><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-34.png"></p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-35.png"></p><ul><li><strong>Mixed Collection</strong>：</li></ul><p>会对E S O 进行<strong>全面的回收</strong></p><ul><li><p>最终标记（Remark）会STW</p></li><li><p>拷贝存活（Evacuation）会STW</p></li><li><p><code>-XX:MaxGCPauseMills:xxx</code> ：用于<strong>指定最长的停顿时间</strong></p></li></ul><p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p><p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-36.png"></p><h3 id="不同垃圾回收器何时触发Full-GC："><a href="#不同垃圾回收器何时触发Full-GC：" class="headerlink" title="不同垃圾回收器何时触发Full GC："></a><strong>不同垃圾回收器何时触发Full GC：</strong></h3><p>SerialGC</p><p>新生代内存不足发生的垃圾收集 - minor gc</p><p>老年代内存不足发生的垃圾收集 - full gc</p><p>ParallelGC</p><p>新生代内存不足发生的垃圾收集 - minor gc</p><p>老年代内存不足发生的垃圾收集 - full gc</p><p>CMS</p><p>新生代内存不足发生的垃圾收集 - minor gc</p><p>老年代内存不足</p><p>G1</p><p>新生代内存不足发生的垃圾收集 - minor gc</p><p>老年代内存不足（老年代所占内存超过阈值）</p><p>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</p><p>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</p><h3 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h3><p>重新标记阶段</p><p>黑色：已被处理，需要保留的</p><p>灰色：正在处理中的</p><p>白色：还未处理的</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-45.png"></p><p>但是在并发标记过程中，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p><p>之前C未被引用，这时A引用了C，就会给C加一个<strong>写屏障</strong>，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 处理中 状态</p><p>在并发标记阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-46.png"></p><p><strong>JDK 8u20 字符串去重：</strong></p><p>优点：节省大量内存</p><p>缺点：略微多占用了 cpu 时间，新生代回收时间略微增加</p><p>例如：</p><p>将所有新分配的字符串（底层是char[]）放入一个队列</p><p>当新生代回收时，G1并发检查是否有重复的字符串</p><p>如果字符串的值一样，就让他们引用同一个字符串对象</p><p>注意，其与String.intern的区别</p><p>intern关注的是字符串对象</p><p>字符串去重关注的是char[]</p><p>在JVM内部，使用了不同的字符串表</p><p><strong>JDK 8u40 并发标记类卸载：</strong></p><p>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类 -XX:+ClassUnloadingWithConcurrentMark 默认启用</p><p><strong>JDK 8u60 回收巨型对象：</strong></p><p>JDK 8u60 回收巨型对象一个对象大于 region 的一半时，称之为巨型对象</p><p>G1 不会对巨型对象进行拷贝</p><p>回收时被优先考虑回收巨型对象</p><p>G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0的巨型对象就可以在新生代垃圾回收时处理掉</p><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-47.png"></p><p><strong>JDK 9 并发标记起始时间的调整：</strong></p><p>并发标记必须在堆空间占满前完成，否则退化为 FullGC</p><p>JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent(默认45%)</p><p>JDK 9 可以<strong>动态调整</strong></p><p>-XX:InitiatingHeapOccupancyPercent 用来设置初始值</p><p>进行数据采样并动态调整</p><p>总会添加一个安全的空档空间</p><h2 id="gc调优"><a href="#gc调优" class="headerlink" title="gc调优"></a>gc调优</h2><p><strong>5-1 调优领域</strong></p><p>内存</p><p>锁竞争</p><p>CPU占用</p><p>IO</p><p>GC</p><p><strong>5-2 确定目标</strong></p><p>【低延迟】还是【高吞吐量】，选择合适的回收器</p><p>CMS，G1，ZGC （低延迟，响应时间优先）</p><p>ParallelGC</p><p>Zing</p><p><strong>5-3 最快的 GC</strong></p><p>最快的GC是不发生GC</p><p>查看Full GC前后的内存占用，考虑以下几个问题：</p><p>数据是不是太多？</p><p>resultSet &#x3D; statement.executeQuery(“select * from 大表”)</p><p>数据表示是否太臃肿？</p><p>对象图</p><p>对象大小</p><p>是否存在内存泄漏？</p><p><strong>5-4 新生代调优</strong></p><p>新生代的特点</p><p>所有的new操作分配内存都是非常廉价的</p><p>TLAB thread-local allocation buffer（可防止多个线程创建对象时的干扰）</p><p>死亡对象回收零代价</p><p>大部分对象用过即死（朝生夕死）</p><p>MInor GC 所用时间远小于Full GC</p><p>新生代内存越大越好么？</p><p>不是</p><p>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</p><p>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</p><p>新生代内存设置为能容&#x7EB3;<strong>[并发量*(请求-响应)]</strong>&#x7684;数据为宜</p><p>幸存区大到能保留【当前活跃对象+需要晋升对象】</p><p>晋升阈值配置得当，让长时间存活对象尽快晋升</p><p><strong>5-5 老年代调优</strong></p><p>以 CMS 为例 ：</p><p>CMS 的老年代内存越大越好</p><p>先尝试不做调优，如果没有 Full GC 那么已经…，否则先尝试调优新生代</p><p>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1&#x2F;4 ~ 1&#x2F;3</p><p>-XX:CMSInitiatingOccupancyFraction&#x3D;percent</p><h1 id="字节码与类加载"><a href="#字节码与类加载" class="headerlink" title="字节码与类加载"></a>字节码与类加载</h1><p>当你执行代码：</p><p>并使用 <code>javap</code> 反编译查看它的字节码时，你会看到类似下面的内容。为了说明，我们先假设类名是 <code>Demo3</code>。</p><h2 id="A-new-String-“kkk”-在方法区和运行时常量池如何存储？"><a href="#A-new-String-“kkk”-在方法区和运行时常量池如何存储？" class="headerlink" title="A &#x3D; new String(“kkk”)在方法区和运行时常量池如何存储？"></a>A &#x3D; new String(“kkk”)在方法区和运行时常量池如何存储？</h2><p>解释</p><p>1. <strong><code>ldc</code> 指令</strong></p><ul><li><p><code>ldc #2</code> 表示将字符串常量 <code>&quot;kkk&quot;</code> 推送到操作数栈中。这里的常量 <code>&quot;kkk&quot;</code> 是一个常量池中的字符串，在编译时已经确定，因此会存储在类的常量池中。</p></li><li><p><code>#2</code> 是常量池的索引，指向 <code>&quot;kkk&quot;</code> 字符串常量。</p></li></ul><p>2. <strong><code>new</code></strong> 和 <strong><code>invokespecial</code></strong></p><ul><li><p><code>new #3</code>：这行代码表示要创建一个新的 <code>String</code> 对象，<code>#3</code> 是常量池中 <code>String</code> 类的索引，表示创建 <code>String</code> 对象。</p></li><li><p><code>dup</code>：这条指令是复制栈顶的对象引用。它用于确保在创建对象时，我们能够继续使用这个对象引用进行初始化。</p></li><li><p><code>aload_1</code>：从局部变量表加载变量 <code>a</code>（即 <code>kkk</code> 字符串）到操作数栈。</p></li><li><p><code>invokespecial #4</code>：调用 <code>String</code> 类的构造方法 <code>String(String)</code>，将之前从栈上加载的字符串传递给构造方法。这个方法会创建一个新的 <code>String</code> 对象。</p></li></ul><p>3. <strong><code>astore_2</code></strong></p><ul><li>最终，使用 <code>astore_2</code> 把创建出来的新 <code>String</code> 对象保存到变量 <code>a</code> 中。</li></ul><p>常见的关键点：</p><ul><li><p><code>&quot;kkk&quot;</code> 字符串常量首先会通过 <code>ldc</code> 指令加载到操作数栈中，它是一个常量池中的常量。</p></li><li><p><code>new String(&quot;kkk&quot;)</code> 创建了一个新的 <code>String</code> 对象，调用了 <code>String</code> 的构造函数。</p></li><li><p>这个过程中，字符串 <code>&quot;kkk&quot;</code> 是常量池中的一个对象，但通过 <code>new</code> 创建的 <code>String</code> 对象是堆上的一个新对象。</p></li></ul><p>总结</p><p>在 <code>javap</code> 反编译的字节码中，你会看到：</p><ul><li><p>字符串 <code>&quot;kkk&quot;</code> 被加载到栈上（通过 <code>ldc</code>）。</p></li><li><p>通过 <code>new String(&quot;kkk&quot;)</code> 创建了一个新的 <code>String</code> 对象。</p></li><li><p><code>new String(&quot;kkk&quot;)</code> 实际上是在堆内存中创建了一个新的 <code>String</code> 对象，而 <code>&quot;kkk&quot;</code> 字符串本身是常量池中的一个字符串。</p></li></ul><h2 id="invokevirtual为什么实现的是多态调用？"><a href="#invokevirtual为什么实现的是多态调用？" class="headerlink" title="invokevirtual为什么实现的是多态调用？"></a>invokevirtual为什么实现的是多态调用？</h2><p><img src="/2025/02/13/JVM%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-48.png"></p><p>invokevirtual作用的是类中的public方法，在编译的时候不知道他要继承的是父类还是子类（这是要通过字节码调用构造函数之后才知道的），所以是动态绑定。</p><p>不同方法在调用时，对应的虚拟机指令有所区别：</p><ul><li><p>私有、构造、被final修饰的方法，在调用时都使用invokespecial指令，属于静态绑定</p></li><li><p>普通成员方法在调用时，使用invokevirtual指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定，属于动态绑定，即支持多态</p></li><li><p>静态方法在调用时使用invokestatic指令</p></li></ul><h2 id="多态的原理"><a href="#多态的原理" class="headerlink" title="多态的原理"></a>多态的原理</h2><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用invokevirtual指令</p><p>在执行invokevirtual指令时，经历了以下几个步骤</p><ul><li><p>先通过栈帧中对象的引用找到对象</p></li><li><p>分析对象头，找到对象实际的Class</p></li><li><p>Class结构中有vtable，它在类加载的链接阶段就已经根据方法的重写规则生成好了</p></li><li><p>查询vtable找到方法的具体地址</p></li><li><p>执行方法的字节码</p></li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="Try-catch"><a href="#Try-catch" class="headerlink" title="Try-catch"></a>Try-catch</h3><p>对应的字节码文件（为了抓住重点，下面的字节码省略了局部变量表等一些不重要的部分）：</p><ul><li><p>可以看到多出来一个 Exception table 的结构，[from, to) 是前闭后开（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</p></li><li><p>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</p></li></ul><h3 id="多个single-catch"><a href="#多个single-catch" class="headerlink" title="多个single-catch"></a>多个single-catch</h3><ul><li>因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong></li></ul><h3 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h3><p>可以看到 finally 中的代码被复制了 3 份，分别放入 try 流程，catch 流程以及 catch 剩余的异常类型流程</p><blockquote><p>注意：</p><p>虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码<strong>只会被执行一次</strong></p></blockquote><h3 id="finally中的return"><a href="#finally中的return" class="headerlink" title="finally中的return"></a>finally中的return</h3><ul><li><p>由于 finally 中的 ireturn 被插入了所有可能的流程，因此返回结果肯定以 finally 的为准</p></li><li><p>跟前一个中的 finally 相比，发现没有 athrow 了，这告诉我们：如果在 finally 中出现了 return，会吞掉异常</p></li></ul><p>运行下面的代码，不会抛出异常：</p><h3 id="finally不带return"><a href="#finally不带return" class="headerlink" title="finally不带return"></a>finally不带return</h3>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC_无锁</title>
      <link href="/2025/02/13/JUC-%E6%97%A0%E9%94%81/"/>
      <url>/2025/02/13/JUC-%E6%97%A0%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>无锁编程：Lock Free</p><p>CAS 的全称是 Compare-And-Swap，是 <strong>CPU</strong> <strong>并发原语</strong></p><ul><li>CAS 并发原语体现在 Java 语言中就是 sun.misc.Unsafe 类的各个方法，调用 UnSafe 类中的 CAS 方法，JVM 会实现出 CAS 汇编指令，这是一种完全依赖于硬件的功能，实现了原子操作</li><li>CAS 是一种系统原语，原语属于操作系统范畴，是由若干条指令组成 ，用于完成某个功能的一个过程，并且原语的执行必须是连续的，执行过程中不允许被中断，所以 CAS 是一条 CPU 的原子指令，不会造成数据不一致的问题，是线程安全的</li></ul><p>底层原理：CAS 的底层是 <code>lock cmpxchg</code> 指令（X86 架构），在单核和多核 CPU 下都能够保证比较交换的原子性</p><ul><li>程序是在单核处理器上运行，会省略 lock 前缀，单处理器自身会维护处理器内的顺序一致性，不需要 lock 前缀的内存屏障效果</li><li>程序是在多核处理器上运行，会为 cmpxchg 指令加上 lock 前缀。当某个核执行到带 lock 的指令时，CPU 会执行<strong>总线锁定或缓存锁定</strong>，将修改的变量写入到主存，这个过程不会被线程的调度机制所打断，保证了多个线程对内存操作的原子性</li></ul><p>作用：比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否则继续比较直到主内存和工作内存的值一致为止</p><p>CAS 特点：</p><ul><li>CAS 体现的是<strong>无锁并发、无阻塞并发</strong>，线程不会陷入阻塞，线程不需要频繁切换状态（上下文切换，系统调用）</li><li>CAS 是基于乐观锁的思想</li></ul><p>CAS 缺点：</p><ul><li>执行的是循环操作，如果比较不成功一直在循环，最差的情况某个线程一直取到的值和预期值都不一样，就会无限循环导致饥饿，<strong>使用</strong> <strong>CAS</strong> <strong>线程数****不要超过</strong> <strong>CPU</strong> <strong>的核心数</strong>，采用分段 CAS 和自动迁移机制</li><li>只能保证一个共享变量的原子操作<ul><li>对于一个共享变量执行操作时，可以通过循环 CAS 的方式来保证原子操作</li><li>对于多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候<strong>只能用锁来保证原子性</strong></li></ul></li><li>引出来 ABA 问题</li></ul><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>CAS 与 synchronized 总结：</p><ul><li>synchronized 是从悲观的角度出发：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程），因此 synchronized 也称之为悲观锁，ReentrantLock 也是一种悲观锁，性能较差</li><li>CAS 是从乐观的角度出发：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。<strong>如果别人修改过，则获取现在最新的值，如果别人没修改过，直接修改共享数据的值</strong>，CAS 这种机制也称之为乐观锁，综合性能较好</li></ul><h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p>常见原子类：AtomicInteger、AtomicBoolean、AtomicLong</p><p>构造方法：</p><ul><li><code>public AtomicInteger()</code>：初始化一个默认值为 0 的原子型 Integer</li><li><code>public AtomicInteger(int initialValue)</code>：初始化一个指定值的原子型 Integer</li></ul><p>常用API：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>public final int get()</td><td>获取 AtomicInteger 的值</td></tr><tr><td>public final int getAndIncrement()</td><td>以原子方式将当前值加 1，返回的是自增前的值</td></tr><tr><td>public final int incrementAndGet()</td><td>以原子方式将当前值加 1，返回的是自增后的值</td></tr><tr><td>public final int getAndSet(int value)</td><td>以原子方式设置为 newValue 的值，返回旧值</td></tr><tr><td>public final int addAndGet(int data)</td><td>以原子方式将输入的数值与实例中的值相加并返回 实例：AtomicInteger 里的 value</td></tr></tbody></table><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p><strong>AtomicInteger 原理</strong>：自旋锁 + CAS 算法</p><p>CAS 算法：有 3 个操作数（内存值 V， 旧的预期值 A，要修改的值 B）</p><ul><li>当旧的预期值 A &#x3D;&#x3D; 内存值 V 此时可以修改，将 V 改为 B</li><li>当旧的预期值 A !&#x3D; 内存值 V 此时不能修改，并重新获取现在的最新值，重新获取的动作就是自旋</li></ul><p>分析 getAndSet 方法：</p><ul><li>AtomicInteger：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * this:                 当前对象</span></span><br><span class="line"><span class="comment">    * valueOffset:        内存偏移量，内存地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetInt(<span class="built_in">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>valueOffset：偏移量表示该变量值相对于当前对象地址的偏移，Unsafe 就是根据内存偏移地址获取数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line"><span class="comment">//调用本地方法   --&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">objectFieldOffset</span><span class="params">(Field var1)</span>;</span><br></pre></td></tr></table></figure><ul><li>unsafe 类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// val1: AtomicInteger对象本身，var2: 该对象值得引用地址，var4: 需要变动的数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSetInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// var5: 用 var1 和 var2 找到的内存中的真实值</span></span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>var5：从主内存中拷贝到工作内存中的值（每次都要从主内存拿到最新的值到本地内存），然后执行 <code>compareAndSwapInt()</code> 再和主内存的值进行比较，假设方法返回 false，那么就一直执行 while 方法，直到期望的值和真实值一样，修改数据</li><li>变量 value 用 volatile 修饰，保证了多线程之间的内存可见性，避免线程从工作缓存中获取失效的变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value</span><br></pre></td></tr></table></figure><ul><li><strong>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现比较并交换的效果</strong></li></ul><p>分析 getAndUpdate 方法：</p><ul><li>getAndUpdate：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndUpdate</span><span class="params">(IntUnaryOperator updateFunction)</span> &#123;</span><br><span class="line">    <span class="type">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();        <span class="comment">//当前值，cas的期望值</span></span><br><span class="line">        next = updateFunction.applyAsInt(prev);<span class="comment">//期望值更新到该值</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));<span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数式接口：可以自定义操作逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">a.getAndUpdate(i -&gt; i + <span class="number">10</span>);</span><br></pre></td></tr></table></figure><ul><li>compareAndSet：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * this:                 当前对象</span></span><br><span class="line"><span class="comment">    * valueOffset:        内存偏移量，内存地址</span></span><br><span class="line"><span class="comment">    * expect:                期望的值</span></span><br><span class="line"><span class="comment">    * update:                 更新的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h4><p>原子引用：对 Object 进行原子操作，提供一种读和写都是原子性的对象引用变量</p><p>原子引用类：AtomicReference、AtomicStampedReference、AtomicMarkableReference</p><p>AtomicReference 类：</p><ul><li>构造方法：<code>AtomicReference&lt;T&gt; atomicReference = new AtomicReference&lt;T&gt;()</code></li><li>常用 API：<ul><li><code>public final boolean compareAndSet(V expectedValue, V newValue)</code>：CAS 操作</li><li><code>public final void set(V newValue)</code>：将值设置为 newValue</li><li><code>public final V get()</code>：返回当前值</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">33</span>, <span class="string">&quot;z3&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建原子引用包装类</span></span><br><span class="line">        AtomicReference&lt;Student&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置主内存共享变量为s1</span></span><br><span class="line">        atomicReference.set(s1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较并交换，如果现在主物理内存的值为 z3，那么交换成 l4</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">44</span>, <span class="string">&quot;l4&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (atomicReference.compareAndSet(s1, s2)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(atomicReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//。。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h4><p>原子数组类：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p><p>AtomicIntegerArray 类方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   i                the index</span></span><br><span class="line"><span class="comment">* expect         the expected value</span></span><br><span class="line"><span class="comment">* update         the new value</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> compareAndSetRaw(checkedByteOffset(i), expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原子更新器"><a href="#原子更新器" class="headerlink" title="原子更新器"></a>原子更新器</h4><p>原子更新器类：AtomicReferenceFieldUpdater、AtomicIntegerFieldUpdater、AtomicLongFieldUpdater</p><p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常 <code>IllegalArgumentException: Must be volatile type</code></p><p>常用 API：</p><ul><li><code>static &lt;U&gt; AtomicIntegerFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; c, String fieldName)</code>：构造方法</li><li><code>abstract boolean compareAndSet(T obj, int expect, int update)</code>：CAS</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UpdateDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> field;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicIntegerFieldUpdater</span> <span class="variable">fieldUpdater</span> <span class="operator">=</span> AtomicIntegerFieldUpdater</span><br><span class="line">                            .newUpdater(UpdateDemo.class, <span class="string">&quot;field&quot;</span>);</span><br><span class="line">        <span class="type">UpdateDemo</span> <span class="variable">updateDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateDemo</span>();</span><br><span class="line">        fieldUpdater.compareAndSet(updateDemo, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(updateDemo.field);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h4><p>原子累加器类：LongAdder、DoubleAdder、LongAccumulator、DoubleAccumulator</p><p>LongAdder 和 LongAccumulator 区别：</p><p>相同点：</p><ul><li>LongAddr 与 LongAccumulator 类都是使用非阻塞算法 CAS 实现的</li><li>LongAddr 类是 LongAccumulator 类的一个特例，只是 LongAccumulator 提供了更强大的功能，可以自定义累加规则，当accumulatorFunction 为 null 时就等价于 LongAddr</li></ul><p>不同点：</p><ul><li>调用 casBase 时，LongAccumulator 使用 function.applyAsLong(b &#x3D; base, x) 来计算，LongAddr 使用 casBase(b &#x3D; base, b + x)</li><li>LongAccumulator 类功能更加强大，构造方法参数中<ul><li>accumulatorFunction 是一个双目运算器接口，可以指定累加规则，比如累加或者相乘，其根据输入的两个参数返回一个计算值，LongAdder 内置累加规则</li><li>identity 则是 LongAccumulator 累加器的初始值，LongAccumulator 可以为累加器提供非0的初始值，而 LongAdder 只能提供默认的 0</li></ul></li></ul><h3 id="Adder"><a href="#Adder" class="headerlink" title="Adder"></a>Adder</h3><h4 id="优化机制"><a href="#优化机制" class="headerlink" title="优化机制"></a>优化机制</h4><p>LongAdder 是 Java8 提供的类，跟 AtomicLong 有相同的效果，但对 CAS 机制进行了优化，尝试使用分段 CAS 以及自动分段迁移的方式来大幅度提升多线程高并发执行 CAS 操作的性能</p><p>CAS 底层实现是在一个循环中不断地尝试修改目标值，直到修改成功。如果竞争不激烈修改成功率很高，否则失败率很高，失败后这些重复的原子性操作会耗费性能（导致大量线程<strong>空循环，自旋转</strong>）</p><p>优化核心思想：数据分离，将 AtomicLong 的<strong>单点的更新压力分担到各个节点，空间换时间</strong>，在低并发的时候直接更新，可以保障和 AtomicLong 的性能基本一致，而在高并发的时候通过分散减少竞争，提高了性能</p><p><strong>分段 CAS 机制</strong>：</p><ul><li>在发生竞争时，创建 Cell 数组用于将不同线程的操作离散（通过 hash 等算法映射）到不同的节点上</li><li>设置多个累加单元（会根据需要扩容，最大为 CPU 核数），Therad-0 累加 Cell[0]，而 Thread-1 累加 Cell[1] 等，最后将结果汇总</li><li>在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能</li></ul><p><strong>自动分段迁移机制</strong>：某个 Cell 的 value 执行 CAS 失败，就会自动寻找另一个 Cell 分段内的 value 值进行 CAS 操作</p><h4 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h4><p>Cell 为累加单元：数组访问索引是通过 Thread 里的 threadLocalRandomProbe 域取模实现的，这个域是 ThreadLocalRandom 更新的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Striped64.Cell</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">    Cell(<span class="type">long</span> x) &#123; value = x; &#125;</span><br><span class="line">    <span class="comment">// 用 cas 方式进行累加, prev 表示旧值, next 表示新值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">cas</span><span class="params">(<span class="type">long</span> prev, <span class="type">long</span> next)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="built_in">this</span>, valueOffset, prev, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略不重要代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cell 是数组形式，<strong>在内存中是连续存储的</strong>，64 位系统中，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），每一个 cache line 为 64 字节，因此缓存行可以存下 2 个的 Cell 对象，当 Core-0 要修改 Cell[0]、Core-1 要修改 Cell[1]，无论谁修改成功都会导致当前缓存行失效，从而导致对方的数据失效，需要重新去主存获取，影响效率</p><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDEwOTBhMTE0MjJkYTBiNmZjMDBiY2NkZjE2MWMyNjZfZ0JJYUpNeHlmMkw4ZUd2b1oxb2J6MUVrcnE5Vlg2aDZfVG9rZW46UHdpMGJTd09pb3lDcUZ4S2ZxNWNYczZnbjgxXzE3NDAzMTg1NzE6MTc0MDMyMjE3MV9WNA" alt="img"></p><p>@sun.misc.Contended：防止缓存行伪共享，在使用此注解的对象或字段的前后各增加 128 字节大小的 padding，使用 2 倍于大多数硬件缓存行让 CPU 将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样就不会造成对方缓存行的失效</p><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=MDk3ZTY4MDljYzFmZTUyMzU2ZWJkMjEyODljY2Y1NjBfQTBTNk5KS1I2cDlsNWU3RDZMOGx4T0llWXA1cW0xc3JfVG9rZW46SXp3dGJWVGhKb3k1bTV4UXl1MGMzbTRybnBmXzE3NDAzMTg1NzE6MTc0MDMyMjE3MV9WNA" alt="img"></p><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>Striped64 类成员属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示当前计算机CPU数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors()</span><br><span class="line"><span class="comment">// 累加单元数组, 懒惰初始化</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"><span class="comment">// 基础值, 如果没有竞争, 则用 cas 累加这个域，当 cells 扩容时，也会将数据写到 base 中</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;</span><br><span class="line"><span class="comment">// 在 cells 初始化或扩容时只能有一个线程执行, 通过 CAS 更新 cellsBusy 置为 1 来实现一个锁</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br></pre></td></tr></table></figure><p>工作流程：</p><ul><li>cells 占用内存是相对比较大的，是惰性加载的，在无竞争或者其他线程正在初始化 cells 数组的情况下，直接更新 base 域</li><li>在第一次发生竞争时（casBase 失败）会创建一个大小为 2 的 cells 数组，将当前累加的值包装为 Cell 对象，放入映射的槽位上</li><li>分段累加的过程中，如果当前线程对应的 cells 槽位为空，就会新建 Cell 填充，如果出现竞争，就会重新计算线程对应的槽位，继续自旋尝试修改</li><li>分段迁移后还出现竞争就会扩容 cells 数组长度为原来的两倍，然后 rehash，<strong>数组长度总是 2 的 n 次幂</strong>，默认最大为 CPU 核数，但是可以超过，如果核数是 6 核，数组最长是 8</li></ul><p>方法分析：</p><ul><li>LongAdder#add：累加方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// as 为累加单元数组的引用，b 为基础值，v 表示期望值</span></span><br><span class="line">    <span class="comment">// m 表示 cells 数组的长度 - 1，a 表示当前线程命中的 cell 单元格</span></span><br><span class="line">    Cell[] as; <span class="type">long</span> b, v; <span class="type">int</span> m; Cell a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cells 不为空说明 cells 已经被初始化，线程发生了竞争，去更新对应的 cell 槽位</span></span><br><span class="line">    <span class="comment">// 进入 || 后的逻辑去更新 base 域，更新失败表示发生竞争进入条件</span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="comment">// uncontended 为 true 表示 cell 没有竞争</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 条件一: true 说明 cells 未初始化，多线程写 base 发生竞争需要进行初始化 cells 数组</span></span><br><span class="line">        <span class="comment">//                  fasle 说明 cells 已经初始化，进行下一个条件寻找自己的 cell 去累加</span></span><br><span class="line">        <span class="comment">// 条件二: getProbe() 获取 hash 值，&amp; m 的逻辑和 HashMap 的逻辑相同，保证散列的均匀性</span></span><br><span class="line">        <span class="comment">//                   true 说明当前线程对应下标的 cell 为空，需要创建 cell</span></span><br><span class="line">        <span class="comment">//        false 说明当前线程对应的 cell 不为空，进行下一个条件【将 x 值累加到对应的 cell 中】</span></span><br><span class="line">        <span class="comment">// 条件三: 有取反符号，false 说明 cas 成功，直接返回，true 说明失败，当前线程对应的 cell 有竞争</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            longAccumulate(x, <span class="literal">null</span>, uncontended);</span><br><span class="line">                <span class="comment">// 【uncontended 在对应的 cell 上累加失败的时候才为 false，其余情况均为 true】</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Striped64#longAccumulate：cell 数组创建</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">                                                        <span class="comment">// x                          null                         false | true</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn, <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// 当前线程还没有对应的 cell, 需要随机生成一个 hash 值用来将当前线程绑定到 cell</span></span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化 probe，获取 hash 值</span></span><br><span class="line">        ThreadLocalRandom.current(); </span><br><span class="line">        h = getProbe();        </span><br><span class="line">        <span class="comment">// 默认情况下 当前线程肯定是写入到了 cells[0] 位置，不把它当做一次真正的竞争</span></span><br><span class="line">        wasUncontended = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 表示【扩容意向】，false 一定不会扩容，true 可能会扩容</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// as 表示cells引用，a 表示当前线程命中的 cell，n 表示 cells 数组长度，v 表示 期望值</span></span><br><span class="line">        Cell[] as; Cell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line">        <span class="comment">// 【CASE1】: 表示 cells 已经初始化了，当前线程应该将数据写入到对应的 cell 中</span></span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// CASE1.1: true 表示当前线程对应的索引下标的 Cell 为 null，需要创建 new Cell</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断 cellsBusy 是否被锁</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;   </span><br><span class="line">                    <span class="comment">// 创建 cell, 初始累加值为 x</span></span><br><span class="line">                    <span class="type">Cell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(x);  </span><br><span class="line">                    <span class="comment">// 加锁</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                        <span class="comment">// 创建成功标记，进入【创建 cell 逻辑】</span></span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;        </span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Cell[] rs; <span class="type">int</span> m, j;</span><br><span class="line">                            <span class="comment">// 把当前 cells 数组赋值给 rs，并且不为 null</span></span><br><span class="line">                            <span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                <span class="comment">// 再次判断防止其它线程初始化过该位置，当前线程再次初始化该位置会造成数据丢失</span></span><br><span class="line">                                <span class="comment">// 因为这里是线程安全的判断，进行的逻辑不会被其他线程影响</span></span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 把新创建的 cell 填充至当前位置</span></span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="literal">true</span>;        <span class="comment">// 表示创建完成</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;                <span class="comment">// 解锁</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (created)                        <span class="comment">// true 表示创建完成，可以推出循环了</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// CASE1.2: 条件成立说明线程对应的 cell 有竞争, 改变线程对应的 cell 来重试 cas</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)</span><br><span class="line">                wasUncontended = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// CASE 1.3: 当前线程 rehash 过，如果新命中的 cell 不为空，就尝试累加，false 说明新命中也有竞争</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// CASE 1.4: cells 长度已经超过了最大长度 CPU 内核的数量或者已经扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                collide = <span class="literal">false</span>;                 <span class="comment">// 扩容意向改为false，【表示不能扩容了】</span></span><br><span class="line">            <span class="comment">// CASE 1.5: 更改扩容意向，如果 n &gt;= NCPU，这里就永远不会执行到，case1.4 永远先于 1.5 执行</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// CASE 1.6: 【扩容逻辑】，进行加锁</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 线程安全的检查，防止期间被其他线程扩容了</span></span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123;     </span><br><span class="line">                        <span class="comment">// 扩容为以前的 2 倍</span></span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="comment">// 遍历移动值</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        <span class="comment">// 把扩容后的引用给 cells</span></span><br><span class="line">                        cells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;        <span class="comment">// 解锁</span></span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;        <span class="comment">// 扩容意向改为 false，表示不扩容了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重置当前线程 Hash 值，这就是【分段迁移机制】</span></span><br><span class="line">            h = advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【CASE2】: 运行到这说明 cells 还未初始化，as 为null</span></span><br><span class="line">        <span class="comment">// 判断是否没有加锁，没有加锁就用 CAS 加锁</span></span><br><span class="line">        <span class="comment">// 条件二判断是否其它线程在当前线程给 as 赋值之后修改了 cells，这里不是线程安全的判断</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            <span class="comment">// 初始化标志，开始 【初始化 cells 数组】</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line">                       <span class="comment">// 再次判断 cells == as 防止其它线程已经提前初始化了，当前线程再次初始化导致丢失数据</span></span><br><span class="line">                <span class="comment">// 因为这里是【线程安全的，重新检查，经典 DCL】</span></span><br><span class="line">                <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                    Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[<span class="number">2</span>];        <span class="comment">// 初始化数组大小为2</span></span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cell</span>(x);        <span class="comment">// 填充线程对应的cell</span></span><br><span class="line">                    cells = rs;</span><br><span class="line">                    init = <span class="literal">true</span>;                                <span class="comment">// 初始化成功，标记置为 true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;                                        <span class="comment">// 解锁啊</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;                                                        <span class="comment">// 初始化成功直接跳出自旋</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 【CASE3】: 运行到这说明其他线程在初始化 cells，当前线程将值累加到 base，累加成功直接结束自旋</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x :</span><br><span class="line">                                    fn.applyAsLong(v, x))))</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sum：获取最终结果通过 sum 整合，<strong>保证最终一致性，不保证强一致性</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历 累加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h3><p>ABA 问题：当进行获取主内存值时，该内存值在写入主内存时已经被修改了 N 次，但是最终又改成原来的值</p><p>其他线程先把 A 改成 B 又改回 A，主线程<strong>仅能判断出共享变量的值与最初值 A 是否相同</strong>，不能感知到这种从 A 改为 B 又 改回 A 的情况，这时 CAS 虽然成功，但是过程存在问题</p><ul><li>构造方法：<ul><li><code>public AtomicStampedReference(V initialRef, int initialStamp)</code>：初始值和初始版本号</li></ul></li><li>常用API：<ul><li><code>public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp)</code>：<strong>期望引用和期望版本号都一致</strong>才进行 CAS 修改数据</li><li><code>public void set(V newReference, int newStamp)</code>：设置值和版本号</li><li><code>public V getReference()</code>：返回引用的值</li><li><code>public int getStamp()</code>：返回当前版本号</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    AtomicStampedReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">startStamp</span> <span class="operator">=</span> atomicReference.getStamp();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicReference.getStamp();</span><br><span class="line">        atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">        stamp = atomicReference.getStamp();</span><br><span class="line">        atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">200</span>, startStamp, startStamp + <span class="number">1</span>)) &#123;</span><br><span class="line">            System.out.println(atomicReference.getReference());<span class="comment">//100</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程修改失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><p>Unsafe 是 CAS 的核心类，由于 Java 无法直接访问底层系统，需要通过本地（Native）方法来访问</p><p>Unsafe 类存在 sun.misc 包，其中所有方法都是 native 修饰的，都是直接调用<strong>操作系统底层资源</strong>执行相应的任务，基于该类可以直接操作特定的内存数据，其内部方法操作类似 C 的指针</p><p>模拟实现原子整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyAtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyAtomicInteger</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (atomicInteger.compareAndSwap(<span class="number">20</span>)) &#123;</span><br><span class="line">        System.out.println(atomicInteger.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAtomicInteger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> VALUE_OFFSET;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Unsafe unsafe = Unsafe.getUnsafe()这样会报错，需要反射获取</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            UNSAFE = (Unsafe) theUnsafe.get(<span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 获取 value 属性的内存地址，value 属性指向该地址，直接设置该地址的值可以修改 value 的值</span></span><br><span class="line">            VALUE_OFFSET = UNSAFE.objectFieldOffset(</span><br><span class="line">                                   MyAtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAtomicInteger</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSwap</span><span class="params">(<span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="built_in">this</span>.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> update;</span><br><span class="line">            <span class="comment">//                                                        当前对象  内存偏移量    期望值 更新值</span></span><br><span class="line">            <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, VALUE_OFFSET, prev, update)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;CAS成功&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFinal</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: aload_0</span><br><span class="line"><span class="number">1</span>: invokespecial #<span class="number">1</span> <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">4</span>: aload_0</span><br><span class="line"><span class="number">5</span>: bipush <span class="number">20</span>                <span class="comment">// 将值直接放入栈中</span></span><br><span class="line"><span class="number">7</span>: putfield #<span class="number">2</span>                 <span class="comment">// Field a:I</span></span><br><span class="line">&lt;-- 写屏障</span><br><span class="line"><span class="number">10</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>final 变量的赋值通过 putfield 指令来完成，在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为 0 的情况</p><p>其他线程访问 final 修饰的变量</p><ul><li><strong>复制一份放入栈中</strong>直接访问，效率高</li><li>大于 short 最大值会将其复制到类的常量池，访问时从常量池获取</li></ul><h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><p>不可变：如果一个对象不能够修改其内部状态（属性），那么就是不可变对象</p><p>不可变对象线程安全的，不存在并发修改和可见性问题，是另一种避免竞争的方式</p><p>String 类也是不可变的，该类和类中所有属性都是 final 的</p><ul><li>类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</li><li>无写入方法（set）确保外部不能对内部属性进行修改</li><li>属性用 final 修饰保证了该属性是只读的，不能修改</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>更改 String 类数据时，会构造新字符串对象，生成新的 char[] value，通过<strong>创建副本对象来避免共享的方式称之为保护性拷贝</strong></li></ul><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>无状态：成员变量保存的数据也可以称为状态信息，无状态就是没有成员变量</p><p>Servlet 为了保证其线程安全，一般不为 Servlet 设置成员变量，这种没有任何成员变量的类是线程安全的</p><h3 id="Local"><a href="#Local" class="headerlink" title="Local"></a>Local</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>ThreadLocal 类用来提供线程内部的局部变量，这种变量在多线程环境下访问（通过 get 和 set 方法访问）时能保证各个线程的变量相对独立于其他线程内的变量，分配在堆内的 <strong>TLAB</strong> 中</p><p>ThreadLocal 实例通常来说都是 <code>private static</code> 类型的，属于一个线程的本地变量，用于关联线程和线程上下文。每个线程都会在 ThreadLocal 中保存一份该线程独有的数据，所以是线程安全的</p><p>ThreadLocal 作用：</p><ul><li>线程并发：应用在多线程并发的场景下</li><li>传递数据：通过 ThreadLocal 实现在同一线程不同函数或组件中传递公共变量，减少传递复杂度</li><li>线程隔离：每个线程的变量都是独立的，不会互相影响</li></ul><p>对比 synchronized：</p><table><thead><tr><th></th><th>synchronized</th><th>ThreadLocal</th></tr></thead><tbody><tr><td>原理</td><td>同步机制采用<strong>以时间换空间</strong>的方式，只提供了一份变量，让不同的线程排队访问</td><td>ThreadLocal 采用<strong>以空间换时间</strong>的方式，为每个线程都提供了一份变量的副本，从而实现同时访问而相不干扰</td></tr><tr><td>侧重点</td><td>多个线程之间访问资源的同步</td><td>多线程中让每个线程之间的数据相互隔离</td></tr></tbody></table><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>ThreadLocal&lt;&gt;()</td><td>创建 ThreadLocal 对象</td></tr><tr><td>protected T initialValue()</td><td>返回当前线程局部变量的初始值</td></tr><tr><td>public void set( T value)</td><td>设置当前线程绑定的局部变量</td></tr><tr><td>public T get()</td><td>获取当前线程绑定的局部变量</td></tr><tr><td>public void remove()</td><td>移除当前线程绑定的局部变量</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程绑定的变量</span></span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="comment">// 变量content绑定到当前线程</span></span><br><span class="line">        tl.set(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 设置数据</span></span><br><span class="line">                    demo.setContent(Thread.currentThread().getName() + <span class="string">&quot;的数据&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + demo.getContent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(<span class="string">&quot;线程&quot;</span> + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>ThreadLocal 适用于下面两种场景：</p><ul><li>每个线程需要有自己单独的实例</li><li>实例需要在多个方法中共享，但不希望被多线程共享</li></ul><p>ThreadLocal 方案有两个突出的优势：</p><ol><li>传递数据：保存每个线程绑定的数据，在需要的地方可以直接获取，避免参数直接传递带来的代码耦合问题</li><li>线程隔离：各线程之间的数据相互隔离却又具备并发性，避免同步方式带来的性能损失</li></ol><p>ThreadLocal 用于数据连接的事务管理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcUtils</span> &#123;</span><br><span class="line">    <span class="comment">// ThreadLocal对象，将connection绑定在当前线程中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">    <span class="comment">// c3p0 数据库连接池对象属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ComboPooledDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">//取出当前线程绑定的connection对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> tl.get();</span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果没有，则从连接池中取出</span></span><br><span class="line">            conn = ds.getConnection();</span><br><span class="line">            <span class="comment">//再将connection对象绑定到当前线程中，非常重要的操作</span></span><br><span class="line">            tl.set(conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 ThreadLocal 使 SimpleDateFormat 从独享变量变成单个线程变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDateUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;DateFormat&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> DateFormat <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">parse</span><span class="params">(String dateStr)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get().parse(dateStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">format</span><span class="params">(Date date)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get().format(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h5><p>JDK8 以前：每个 ThreadLocal 都创建一个 Map，然后用线程作为 Map 的 key，要存储的局部变量作为 Map 的 value，达到各个线程的局部变量隔离的效果。这种结构会造成 Map 结构过大和内存泄露，因为 Thread 停止后无法通过 key 删除对应的数据</p><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=NzE4NzQ1OTk3MTkwN2M3NGM3ODJiNDkwMDNkNDJiZGNfWnB1U2FEUmswRmcyb1liNjVVdG0wU0JyVmxFVDZ3aUFfVG9rZW46QWVVemJadEhkb1p3eW14Y0xTRGNlRmFTbndjXzE3NDAzMTg1NzE6MTc0MDMyMjE3MV9WNA" alt="img"></p><p>JDK8 以后：每个 Thread 维护一个 ThreadLocalMap，这个 Map 的 key 是 ThreadLocal 实例本身，value 是真正要存储的值</p><ul><li><strong>每个 Thread 线程内部都有一个 Map (ThreadLocalMap)</strong></li><li>Map 里面存储 ThreadLocal 对象（key）和线程的私有变量（value）</li><li>Thread 内部的 Map 是由 ThreadLocal 维护的，由 ThreadLocal 负责向 map 获取和设置线程的变量值</li><li>对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成副本的隔离，互不干扰</li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=YWIzMzYzYmJiZGI1NWJlMDdjZmM1MDE5YWNkMmU4YmVfQnBpS0xSaXhYRjJwdGRKZGhWMEF6b3Rqb1Y1cmdNc2ZfVG9rZW46WDlYeGJrQzJib1pwVG54eE9EQWNFTzM4bkpnXzE3NDAzMTg1NzE6MTc0MDMyMjE3MV9WNA" alt="img"></p><p>JDK8 前后对比：</p><ul><li>每个 Map 存储的 Entry 数量会变少，因为之前的存储数量由 Thread 的数量决定，现在由 ThreadLocal 的数量决定，在实际编程当中，往往 ThreadLocal 的数量要少于 Thread 的数量</li><li>当 Thread 销毁之后，对应的 ThreadLocalMap 也会随之销毁，能减少内存的使用，<strong>防止内存泄露</strong></li></ul><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><ul><li>Thread 类的相关属性：<strong>每一个线程持有一个 ThreadLocalMap 对象</strong>，存放由 ThreadLocal 和数据组成的 Entry 键值对</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><ul><li>计算 ThreadLocal 对象的哈希值：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadLocalHashCode</span> <span class="operator">=</span> nextHashCode()</span><br></pre></td></tr></table></figure><ul><li>使用 <code>threadLocalHashCode &amp; (table.length - 1)</code> 计算当前 entry 需要存放的位置</li><li>每创建一个 ThreadLocal 对象就会使用 nextHashCode 分配一个 hash 值给这个对象：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">nextHashCode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>()</span><br></pre></td></tr></table></figure><ul><li>斐波那契数也叫黄金分割数，hash 的<strong>增量</strong>就是这个数字，带来的好处是 hash 分布非常均匀：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span></span><br></pre></td></tr></table></figure><h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><p>方法都是线程安全的，因为 ThreadLocal 属于一个线程的，ThreadLocal 中的方法，逻辑都是获取当前线程维护的 ThreadLocalMap 对象，然后进行数据的增删改查，没有指定初始值的 threadlcoal 对象默认赋值为 null</p><ul><li>initialValue()：返回该线程局部变量的初始值<ul><li>延迟调用的方法，在执行 get 方法时才执行</li><li>该方法缺省（默认）实现直接返回一个 null</li><li>如果想要一个初始值，可以重写此方法， 该方法是一个 <code>protected</code> 的方法，为了让子类覆盖而设计的</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>nextHashCode()：计算哈希值，ThreadLocal 的散列方式称之为<strong>斐波那契散列</strong>，每次获取哈希值都会加上 HASH_INCREMENT，这样做可以尽量避免 hash 冲突，让哈希值能均匀的分布在 2 的 n 次方的数组中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextHashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 哈希值自增一个 HASH_INCREMENT 数值</span></span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>set()：修改当前线程与当前 threadlocal 对象相关联的线程局部变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象中维护的 ThreadLocalMap 对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 判断 map 是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 调用 threadLocalMap.set 方法进行重写或者添加</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// map 为空，调用 createMap 进行 ThreadLocalMap 对象的初始化。参数1是当前线程，参数2是局部变量</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取当前线程 Thread 对应维护的 ThreadLocalMap </span></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建当前线程Thread对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    <span class="comment">// 【这里的 this 是调用此方法的 threadLocal】，创建一个新的 Map 并设置第一个数据</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>get()：获取当前线程与当前 ThreadLocal 对象相关联的线程局部变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 如果此map存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 以当前的 ThreadLocal 为 key，调用 getEntry 获取对应的存储实体 e</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 对 e 进行判空 </span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取存储实体 e 对应的 value值</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*有两种情况有执行当前代码</span></span><br><span class="line"><span class="comment">      第一种情况: map 不存在，表示此线程没有维护的 ThreadLocalMap 对象</span></span><br><span class="line"><span class="comment">      第二种情况: map 存在, 但是【没有与当前 ThreadLocal 关联的 entry】，就会设置为默认值 */</span></span><br><span class="line">    <span class="comment">// 初始化当前线程与当前 threadLocal 对象相关联的 value</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用initialValue获取初始化的值，此方法可以被子类重写, 如果不重写默认返回 null</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 判断 map 是否初始化过</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 存在则调用 map.set 设置此实体 entry，value 是默认的值</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 调用 createMap 进行 ThreadLocalMap 对象的初始化中</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="comment">// 返回线程与当前 threadLocal 关联的局部变量</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>remove()：移除当前线程与当前 threadLocal 对象相关联的线程局部变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象中维护的 ThreadLocalMap 对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// map 存在则调用 map.remove，this时当前ThreadLocal，以this为key删除对应的实体</span></span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LocalMap"><a href="#LocalMap" class="headerlink" title="LocalMap"></a>LocalMap</h4><h5 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h5><p>ThreadLocalMap 是 ThreadLocal 的内部类，没有实现 Map 接口，用独立的方式实现了 Map 的功能，其内部 Entry 也是独立实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化当前 map 内部散列表数组的初始长度 16</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放数据的table，数组长度必须是2的整次幂。</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组里面 entrys 的个数，可以用于判断 table 当前使用量是否超过阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行扩容的阈值，表使用量大于它的时候进行扩容。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> threshold;</span><br></pre></td></tr></table></figure><p>存储结构 Entry：</p><ul><li>Entry 继承 WeakReference，key 是弱引用，目的是将 ThreadLocal 对象的生命周期和线程生命周期解绑</li><li>Entry 限制只能用 ThreadLocal 作为 key，key 为 null (entry.get() &#x3D;&#x3D; null) 意味着 key 不再被引用，entry 也可以从 table 中清除</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="comment">// this.referent = referent = key;</span></span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法：延迟初始化的，线程第一次存储 threadLocal - value 时才会创建 threadLocalMap 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">// 初始化table，创建一个长度为16的Entry数组</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">    <span class="comment">// 【寻址算法】计算索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 创建 entry 对象，存放到指定位置的 slot 中</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">    <span class="comment">// 数据总量是 1</span></span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 将阈值设置为 （当前数组长度 * 2）/ 3。</span></span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h5><ul><li>set()：添加数据，ThreadLocalMap 使用<strong>线性探测法来解决哈希冲突</strong><ul><li>该方法会一直探测下一个地址，直到有空的地址后插入，若插入后 Map 数量超过阈值，数组会扩容为原来的 2 倍</li><li>假设当前 table 长度为16，计算出来 key 的 hash 值为 14，如果 table[14] 上已经有值，并且其 key 与当前 key 不一致，那么就发生了 hash 冲突，这个时候将 14 加 1 得到 15，取 table[15] 进行判断，如果还是冲突会回到 0，取 table[0]，以此类推，直到可以插入，可以把 Entry[] table 看成一个<strong>环形数组</strong></li><li>线性探测法会出现<strong>堆积问题</strong>，可以采取平方探测法解决</li><li>在探测过程中 ThreadLocal 会复用 key 为 null 的脏 Entry 对象，并进行垃圾清理，防止出现内存泄漏</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取散列表</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">// 哈希寻址</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 使用线性探测法向后查找元素，碰到 entry 为空时停止探测</span></span><br><span class="line">    <span class="keyword">for</span> (ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="comment">// 获取当前元素 key</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// ThreadLocal 对应的 key 存在，【直接覆盖之前的值】</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 【这两个条件谁先成立不一定，所以 replaceStaleEntry 中还需要判断 k == key 的情况】</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// key 为 null，但是值不为 null，说明之前的 ThreadLocal 对象已经被回收了，当前是【过期数据】</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 【碰到一个过期的 slot，当前数据复用该槽位，替换过期数据】</span></span><br><span class="line">            <span class="comment">// 这个方法还进行了垃圾清理动作，防止内存泄漏</span></span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 逻辑到这说明碰到 slot == null 的位置，则在空元素的位置创建一个新的 Entry</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="comment">// 数量 + 1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【做一次启发式清理】，如果没有清除任何 entry 并且【当前使用量达到了负载因子所定义，那么进行 rehash</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取【环形数组】的下一个索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="comment">// 索引越界后从 0 开始继续获取</span></span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在指定位置插入指定的数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value, <span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取散列表</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line">        <span class="comment">// 探测式清理的开始下标，默认从当前 staleSlot 开始</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line">    <span class="comment">// 以当前 staleSlot 开始【向前迭代查找】，找到索引靠前过期数据，找到以后替换 slotToExpunge 值</span></span><br><span class="line">    <span class="comment">// 【保证在一个区间段内，从最前面的过期数据开始清理】</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以 staleSlot 【向后去查找】，直到碰到 null 为止，还是线性探测</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">        <span class="comment">// 获取当前节点的 key</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                <span class="comment">// 条件成立说明是【替换逻辑】</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="comment">// 因为本来要在 staleSlot 索引处插入该数据，现在找到了i索引处的key与数据一致</span></span><br><span class="line">            <span class="comment">// 但是 i 位置距离正确的位置更远，因为是向后查找，所以还是要在 staleSlot 位置插入当前 entry</span></span><br><span class="line">            <span class="comment">// 然后将 table[staleSlot] 这个过期数据放到当前循环到的 table[i] 这个位置，</span></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 条件成立说明向前查找过期数据并未找到过期的 entry，但 staleSlot 位置已经不是过期数据了，i 位置才是</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 【清理过期数据，expungeStaleEntry 探测式清理，cleanSomeSlots 启发式清理】</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="comment">// 条件成立说明当前遍历的 entry 是一个过期数据，并且该位置前面也没有过期数据</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            <span class="comment">// 探测式清理过期数据的开始下标修改为当前循环的 index，因为 staleSlot 会放入要添加的数据</span></span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 向后查找过程中并未发现 k == key 的 entry，说明当前是一个【取代过期数据逻辑】</span></span><br><span class="line">    <span class="comment">// 删除原有的数据引用，防止内存泄露</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// staleSlot 位置添加数据，【上面的所有逻辑都不会更改 staleSlot 的值】</span></span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 条件成立说明除了 staleSlot 以外，还发现其它的过期 slot，所以要【开启清理数据的逻辑】</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=NzMwNmJlYmU2NzU2NGY3M2Q1ZDk3ODc4OGFlYjJiZDJfbXREUTg0Z0EyVG84aEZFSG0wWnM1VlVyZGFKZnlpVzZfVG9rZW46SjU1WWI0WVFBb25rbzV4RlQzdWN2RU9EbjdlXzE3NDAzMTg1NzE6MTc0MDMyMjE3MV9WNA" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">prevIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="comment">// 形成一个环绕式的访问，头索引越界后置为尾索引</span></span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>getEntry()：ThreadLocal 的 get 方法以当前的 ThreadLocal 为 key，调用 getEntry 获取对应的存储实体 e</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="comment">// 哈希寻址</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 访问散列表中指定指定位置的 slot </span></span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="comment">// 条件成立，说明 slot 有值并且 key 就是要寻找的 key，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 进行线性探测</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线性探测寻址</span></span><br><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取散列表</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始遍历，碰到 slot == null 的情况，搜索结束</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取当前 slot 中 entry 对象的 key</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 条件成立说明找到了，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">             <span class="comment">// 过期数据，【探测式过期数据回收】</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 更新 index 继续向后走</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        <span class="comment">// 获取下一个槽位中的 entry</span></span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 说明当前区段没有找到相应数据</span></span><br><span class="line">    <span class="comment">// 【因为存放数据是线性的向后寻找槽位，都是紧挨着的，不可能越过一个 空槽位 在后面放】，可以减少遍历的次数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>rehash()：触发一次全量清理，如果数组长度大于等于长度的 <code>2/3 * 3/4 = 1/2</code>，则进行 resize</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 清楚当前散列表内的【所有】过期的数据</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// threshold = len * 2 / 3，就是 2/3 * (1 - 1/4)</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expungeStaleEntries</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">// 【遍历所有的槽位，清理过期数据】</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Entry <strong>数组为扩容为原来的 2 倍</strong> ，重新计算 key 的散列值，如果遇到 key 为 null 的情况，会将其 value 也置为 null，帮助 GC</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldLen</span> <span class="operator">=</span> oldTab.length;</span><br><span class="line">    <span class="comment">// 新数组的长度是老数组的二倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newLen</span> <span class="operator">=</span> oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> <span class="title class_">Entry</span>[newLen];</span><br><span class="line">    <span class="comment">// 统计新table中的entry数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历老表，进行【数据迁移】</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        <span class="comment">// 访问老表的指定位置的 entry</span></span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> oldTab[j];</span><br><span class="line">        <span class="comment">// 条件成立说明老表中该位置有数据，可能是过期数据也可能不是</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="comment">// 过期数据</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                e.value = <span class="literal">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 非过期数据，在新表中进行哈希寻址</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 【线程探测】</span></span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                <span class="comment">// 将数据存放到新表合适的 slot 中</span></span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 设置下一次触发扩容的指标：threshold = len * 2 / 3;</span></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    <span class="comment">// 将扩容后的新表赋值给 threadLocalMap 内部散列表数组引用</span></span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>remove()：删除 Entry</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">// 哈希寻址</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="comment">// 找到了对应的 key</span></span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            <span class="comment">// 设置 key 为 null</span></span><br><span class="line">            e.clear();</span><br><span class="line">            <span class="comment">// 探测式清理</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="清理方法"><a href="#清理方法" class="headerlink" title="清理方法"></a>清理方法</h5><ul><li>探测式清理：沿着开始位置向后探测清理过期数据，沿途中碰到未过期数据则将此数据 rehash 在 table 数组中的定位，重定位后的元素理论上更接近 <code>i = entry.key &amp; (table.length - 1)</code>，让<strong>数据的排列更紧凑</strong>，会优化整个散列表查询性能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// table[staleSlot] 是一个过期数据，以这个位置开始继续向后查找过期数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取散列表和数组长度</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// help gc，先把当前过期的 entry 置空，在取消对 entry 的引用</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 数量-1</span></span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 从 staleSlot 开始向后遍历，直到碰到 slot == null 结束，【区间内清理过期数据】</span></span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 当前 entry 是过期数据</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// help gc</span></span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前 entry 不是过期数据的逻辑，【rehash】</span></span><br><span class="line">            <span class="comment">// 重新计算当前 entry 对应的 index</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 条件成立说明当前 entry 存储时发生过 hash 冲突，向后偏移过了</span></span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                <span class="comment">// 当前位置置空</span></span><br><span class="line">                tab[i] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 以正确位置 h 开始，向后查找第一个可以存放 entry 的位置</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                <span class="comment">// 将当前元素放入到【距离正确位置更近的位置，有可能就是正确位置】</span></span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 slot = null 的槽位索引，图例是 7，这个索引代表【索引前面的区间已经清理完成垃圾了】</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=MjMyZTgzODUwZWVlYjFiYjA4NDRhODY5Y2IyY2JjZTZfUUNoeXZ4SmtMOFkyNnIxM0VMaU1ONDBKb2dqUVN4NTBfVG9rZW46SkdJeWJVZ3g0b0N0V0t4c1ZiUGNlWmpJbkJiXzE3NDAzMTg1NzE6MTc0MDMyMjE3MV9WNA" alt="img"></p><ul><li></li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=MjRmZDJhMTU4NzEwMzMzOTNkZjgxMjcwNzhkZTU0N2JfU0NPS1hRNUl4TWV6SDFZYVpvaU91dmdDQTVLbVNhVmJfVG9rZW46V3U1Q2JHTlVsb0lxS2t4QTJmd2NiVmxybkxBXzE3NDAzMTg1NzE6MTc0MDMyMjE3MV9WNA" alt="img"></p><ul><li>启发式清理：向后循环扫描过期数据，发现过期数据调用探测式清理方法，如果连续几次的循环都没有发现过期数据，就停止扫描</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  i 表示启发式清理工作开始位置，一般是空 slot，n 一般传递的是 table.length </span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">cleanSomeSlots</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 表示启发式清理工作是否清除了过期数据</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 获取当前 map 的散列表引用</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 获取下一个索引，因为探测式返回的 slot 为 null</span></span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">        <span class="comment">// 条件成立说明是过期的数据，key 被 gc 了</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 【发现过期数据重置 n 为数组的长度】</span></span><br><span class="line">            n = len;</span><br><span class="line">            <span class="comment">// 表示清理过过期数据</span></span><br><span class="line">            removed = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 以当前过期的 slot 为开始节点 做一次探测式清理工作</span></span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 假设 table 长度为 16</span></span><br><span class="line">        <span class="comment">// 16 &gt;&gt;&gt; 1 ==&gt; 8，8 &gt;&gt;&gt; 1 ==&gt; 4，4 &gt;&gt;&gt; 1 ==&gt; 2，2 &gt;&gt;&gt; 1 ==&gt; 1，1 &gt;&gt;&gt; 1 ==&gt; 0</span></span><br><span class="line">        <span class="comment">// 连续经过这么多次循环【没有扫描到过期数据】，就停止循环，扫描到空 slot 不算，因为不是过期数据</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ((n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回清除标记</span></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考视频：<a href="https://space.bilibili.com/457326371/">https://space.bilibili.com/457326371/</a></p><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>Memory leak：内存泄漏是指程序中动态分配的堆内存由于某种原因未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果，内存泄漏的堆积终将导致内存溢出</p><ul><li>如果 key 使用强引用：使用完 ThreadLocal ，threadLocal Ref 被回收，但是 threadLocalMap 的 Entry 强引用了 threadLocal，造成 threadLocal 无法被回收，无法完全避免内存泄漏</li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=OGQ0YzM3MWI3YmNkNWMzMWI0NmYwM2Q0ODY3MTZkNGVfVTZTb1BOa3JtRzN3S1ZSQ1Z5M2l1ajF6a3ZGd3hxRHBfVG9rZW46QmhkZWJnTzJSb0U0ZDR4WThRbWNwUDh0bmFnXzE3NDAzMTg1NzE6MTc0MDMyMjE3MV9WNA" alt="img"></p><ul><li>如果 key 使用弱引用：使用完 ThreadLocal ，threadLocal Ref 被回收，ThreadLocalMap 只持有 ThreadLocal 的弱引用，所以threadlocal 也可以被回收，此时 Entry 中的 key &#x3D; null。但没有手动删除这个 Entry 或者 CurrentThread 依然运行，依然存在强引用链，value 不会被回收，而这块 value 永远不会被访问到，也会导致 value 内存泄漏</li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=MmFhZDEwZmZhNjM5NGQ3YjY1ZTU2Y2MyMTlmNGQzODJfZlpPdVUwS0ppN01aTGI0bGxrdFpvWHpWSzFyaUpMN3hfVG9rZW46S2ZVRGJ2d01Xb2VLTWV4Q2xKWWNnVHV2bkZmXzE3NDAzMTg1NzE6MTc0MDMyMjE3MV9WNA" alt="img"></p><ul><li>两个主要原因：<ul><li>没有手动删除这个 Entry</li><li>CurrentThread 依然运行</li></ul></li></ul><p>根本原因：ThreadLocalMap 是 Thread的一个属性，<strong>生命周期跟 Thread 一样长</strong>，如果没有手动删除对应 Entry 就会导致内存泄漏</p><p>解决方法：使用完 ThreadLocal 中存储的内容后将它 remove 掉就可以</p><p>ThreadLocal 内部解决方法：在 ThreadLocalMap 中的 set&#x2F;getEntry 方法中，通过线性探测法对 key 进行判断，如果 key 为 null（ThreadLocal 为 null）会对 Entry 进行垃圾回收。所以<strong>使用<strong><strong>弱引用</strong></strong>比强引用多一层保障</strong>，就算不调用 remove，也有机会进行 GC</p><h4 id="变量传递"><a href="#变量传递" class="headerlink" title="变量传递"></a>变量传递</h4><h5 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h5><p>父子线程：创建子线程的线程是父线程，比如实例中的 main 线程就是父线程</p><p>ThreadLocal 中存储的是线程的局部变量，如果想<strong>实现线程间局部变量传递</strong>可以使用 InheritableThreadLocal 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;&gt;();</span><br><span class="line">    threadLocal.set(<span class="string">&quot;父线程设置的值&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;子线程输出：&quot;</span> + threadLocal.get())).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子线程输出：父线程设置的值</span></span><br></pre></td></tr></table></figure><h5 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h5><p>InheritableThreadLocal 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritableThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> T <span class="title function_">childValue</span><span class="params">(T parentValue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现父子线程间的局部变量共享需要追溯到 Thread 对象的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name, <span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params">                  // 该参数默认是 <span class="literal">true</span></span></span><br><span class="line"><span class="params">                  <span class="type">boolean</span> inheritThreadLocals)</span> &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">parent</span> <span class="operator">=</span> currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断父线程（创建子线程的线程）的 inheritableThreadLocals 属性不为 null</span></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 复制父线程的 inheritableThreadLocals 属性，实现父子线程局部变量共享</span></span><br><span class="line">        <span class="built_in">this</span>.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 【本质上还是创建 ThreadLocalMap，只是把父类中的可继承数据设置进去了】</span></span><br><span class="line"><span class="keyword">static</span> ThreadLocalMap <span class="title function_">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(parentMap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取父线程的哈希表</span></span><br><span class="line">    Entry[] parentTable = parentMap.table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> parentTable.length;</span><br><span class="line">    setThreshold(len);</span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[len];</span><br><span class="line">        <span class="comment">// 【逐个复制父线程 ThreadLocalMap 中的数据】</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> parentTable[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用的是 InheritableThreadLocal#childValue(T parentValue)</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> key.childValue(e.value);</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 线性探测</span></span><br><span class="line">                <span class="keyword">while</span> (table[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                table[h] = c;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://blog.csdn.net/feichitianxia/article/details/110495764">https://blog.csdn.net/feichitianxia/article/details/110495764</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
            <tag> CAS </tag>
            
            <tag> Atomic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC_内存</title>
      <link href="/2025/02/07/JUC-%E5%86%85%E5%AD%98/"/>
      <url>/2025/02/07/JUC-%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><p>Java 内存模型是 Java Memory Model（JMM），本身是一种<strong>抽象的概念</strong>，实际上并不存在，描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p><p>JMM 作用：</p><ul><li>屏蔽各种硬件和操作系统的内存访问差异，实现让 Java 程序在各种平台下都能达到一致的内存访问效果</li><li>规定了线程和内存之间的一些关系</li></ul><p>根据 JMM 的设计，系统存在一个主内存（Main Memory），Java 中所有变量都存储在主存中，对于所有线程都是共享的；每条线程都有自己的工作内存（Working Memory），工作内存中保存的是主存中某些<strong>变量的拷贝</strong>，线程对所有变量的操作都是先对变量进行拷贝，然后在工作内存中进行，不能直接操作主内存中的变量；线程之间无法相互直接访问，线程间的通信（传递）必须通过主内存来完成</p><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjI3MGIwZmNlNzczZTllOGYzZDdlZDdhYTI2OWVlNjdfa1ZYT2RKRXVhODNLMjJXTm9sVE5rRzFiWFNWV1g3NVdfVG9rZW46WGNsRmJDWTNRb0NpenR4SUZqaWNLdWtxbkdnXzE3NDAzMTg3NzI6MTc0MDMyMjM3Ml9WNA" alt="img"></p><p>主内存和工作内存：</p><ul><li>主内存：计算机的内存，也就是经常提到的 8G 内存，16G 内存，存储所有共享变量的值</li><li>工作内存：存储该线程使用到的共享变量在主内存的的值的副本拷贝</li></ul><p><strong>JVM 和 JMM 之间的关系</strong>：JMM 中的主内存、工作内存与 JVM 中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来：</p><ul><li>主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域</li><li>从更低层次上说，主内存直接对应于物理硬件的内存，工作内存对应寄存器和高速缓存</li></ul><h4 id="内存交互"><a href="#内存交互" class="headerlink" title="内存交互"></a>内存交互</h4><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作，每个操作都是<strong>原子</strong>的</p><p>非原子协定：没有被 volatile 修饰的 long、double 外，默认按照两次 32 位的操作</p><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=YjkwMDQ1N2I2NzIwNjYxNmJjOGM3NWRjMDdiNmFkNjlfZ3Bhd3RTS2RkaE1BcDhnUFNKanJoQjJUZUtTSlllWnRfVG9rZW46Q3dOUmI4alAwb3haMlZ4bjlSN2NmUUJxbjRnXzE3NDAzMTg3NzI6MTc0MDMyMjM3Ml9WNA" alt="img"></p><ul><li>lock：作用于主内存，将一个变量标识为被一个线程独占状态（对应 monitorenter）</li><li>unclock：作用于主内存，将一个变量从独占状态释放出来，释放后的变量才可以被其他线程锁定（对应 monitorexit）</li><li>read：作用于主内存，把一个变量的值从主内存传输到工作内存中</li><li>load：作用于工作内存，在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li><li>use：作用于工作内存，把工作内存中一个变量的值传递给<strong>执行引擎</strong>，每当遇到一个使用到变量的操作时都要使用该指令</li><li>assign：作用于工作内存，把从执行引擎接收到的一个值赋给工作内存的变量</li><li>store：作用于工作内存，把工作内存的一个变量的值传送到主内存中</li><li>write：作用于主内存，在 store 之后执行，把 store 得到的值放入主内存的变量中</li></ul><p>参考文章：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md">https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md</a></p><h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</p><p>存在不可见问题的根本原因是由于缓存的存在，线程持有的是共享变量的副本，无法感知其他线程对于共享变量的更改，导致读取的值不是最新的。但是 final 修饰的变量是<strong>不可变</strong>的，就算有缓存，也不会存在不可见的问题</p><p>main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;        <span class="comment">//添加volatile</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(run)&#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    run = <span class="literal">false</span>; <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：</p><ul><li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存</li><li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率</li><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjQ4NDlmYzBmYjU1YWI4Y2Q3Y2M5NGEyNzIwMWMzOTVfUXRwdkF6OXNSbmdsTGtzbE10Zmt1MVJMMWx3djNEcXdfVG9rZW46QmE2UmJJd2JQbzlGYU54Vm5BM2N4MEt1bjdlXzE3NDAzMTg3NzI6MTc0MDMyMjM3Ml9WNA" alt="img"></p><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>原子性：不可分割，完整性，也就是说某个线程正在做某个具体业务时，中间不可以被分割，需要具体完成，要么同时成功，要么同时失败，保证指令不会受到线程上下文切换的影响</p><p>定义原子操作的使用规则：</p><ol><li>不允许 read 和 load、store 和 write 操作之一单独出现，必须顺序执行，但是不要求连续</li><li>不允许一个线程丢弃 assign 操作，必须同步回主存</li><li>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从工作内存同步会主内存中</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（assign 或者 load）的变量，即对一个变量实施 use 和 store 操作之前，必须先自行 assign 和 load 操作</li><li>一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一线程重复执行多次，多次执行 lock 后，只有<strong>执行相同次数的 unlock</strong> 操作，变量才会被解锁，<strong>lock 和 unlock 必须成对出现</strong></li><li>如果对一个变量执行 lock 操作，将会<strong>清空工作内存中此变量的值</strong>，在执行引擎使用这个变量之前需要重新从主存加载</li><li>如果一个变量事先没有被 lock 操作锁定，则不允许执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量</li><li>对一个变量执行 unlock 操作之前，必须<strong>先把此变量同步到主内存</strong>中（执行 store 和 write 操作）</li></ol><h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>有序性：在本线程内观察，所有操作都是有序的；在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序</p><p>CPU 的基本工作是执行存储的指令序列，即程序，程序的执行过程实际上是不断地取出指令、分析指令、执行指令的过程，为了提高性能，编译器和处理器会对指令重排，一般分为以下三种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</span><br></pre></td></tr></table></figure><p>现代 CPU 支持多级指令流水线，几乎所有的冯•诺伊曼型计算机的 CPU，其工作都可以分为 5 个阶段：取指令、指令译码、执行指令、访存取数和结果写回，可以称之为<strong>五级指令流水线</strong>。CPU 可以在一个时钟周期内，同时运行五条指令的<strong>不同阶段</strong>（每个线程不同的阶段），本质上流水线技术并不能缩短单条指令的执行时间，但变相地提高了指令地吞吐率</p><p>处理器在进行重排序时，必须要考虑<strong>指令之间的数据依赖性</strong></p><ul><li>单线程环境也存在指令重排，由于存在依赖性，最终执行结果和代码顺序的结果一致</li><li>多线程环境中线程交替执行，由于编译器优化重排，会获取其他线程处在不同阶段的指令同时执行</li></ul><p>补充知识：</p><ul><li>指令周期是取出一条指令并执行这条指令的时间，一般由若干个机器周期组成</li><li>机器周期也称为 CPU 周期，一条指令的执行过程划分为若干个阶段（如取指、译码、执行等），每一阶段完成一个基本操作，完成一个基本操作所需要的时间称为机器周期</li><li>振荡周期指周期性信号作周期性重复变化的时间间隔</li></ul><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><h5 id="缓存结构"><a href="#缓存结构" class="headerlink" title="缓存结构"></a>缓存结构</h5><p>在计算机系统中，CPU 高速缓存（CPU Cache，简称缓存）是用于减少处理器访问内存所需平均时间的部件；在存储体系中位于自顶向下的第二层，仅次于 CPU 寄存器；其容量远小于内存，但速度却可以接近处理器的频率</p><p>CPU 处理器速度远远大于在主内存中的，为了解决速度差异，在它们之间架设了多级缓存，如 L1、L2、L3 级别的缓存，这些缓存离 CPU 越近就越快，将频繁操作的数据缓存到这里，加快访问速度</p><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=Zjk1ZjExMjIxZGY5MDM0NjJlZWJhNzA2Mzg5NDYyMGFfUXQ2QXc1WEZMME9LdThJaGFiNnZxMFEzSFVYZ2VUQkpfVG9rZW46UUw1Z2I2OHB3b0NoazB4eUIzR2NWbmNVbkVjXzE3NDAzMTg3NzI6MTc0MDMyMjM3Ml9WNA" alt="img"></p><table><thead><tr><th>从 CPU 到</th><th>大约需要的时钟周期</th></tr></thead><tbody><tr><td>寄存器</td><td>1 cycle (4GHz 的 CPU 约为 0.25ns)</td></tr><tr><td>L1</td><td>3~4 cycle</td></tr><tr><td>L2</td><td>10~20 cycle</td></tr><tr><td>L3</td><td>40~45 cycle</td></tr><tr><td>内存</td><td>120~240 cycle</td></tr></tbody></table><h5 id="缓存使用"><a href="#缓存使用" class="headerlink" title="缓存使用"></a>缓存使用</h5><p>当处理器发出内存访问请求时，会先查看缓存内是否有请求数据，如果存在（命中），则不用访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器</p><p>缓存之所以有效，主要因为程序运行时对内存的访问呈现局部性（Locality）特征。既包括空间局部性（Spatial Locality），也包括时间局部性（Temporal Locality），有效利用这种局部性，缓存可以达到极高的命中率</p><h4 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h4><p><strong>缓存以缓存行 cache line 为单位</strong>，每个缓存行对应着一块内存，一般是 64 byte（8 个 long），在 CPU 从主存获取数据时，以 cache line 为单位加载，于是相邻的数据会一并加载到缓存中</p><p>缓存会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中，CPU 要保证数据的一致性，需要做到某个 CPU 核心更改了数据，其它 CPU 核心对应的<strong>整个缓存行必须失效</strong>，这就是伪共享</p><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=NTAwZmUzYTFiNzY1YWM3MmMxYmVjYmMxNGY1NTU5MmNfUnhHWmRuV3Q4QmY5b2FkcnZGNE1iVUdheHhkeTZRM2lfVG9rZW46RmRUQ2IzaUFRb1B5NG54R3c1U2N0bHk4blpiXzE3NDAzMTg3NzI6MTc0MDMyMjM3Ml9WNA" alt="img"></p><p>解决方法：</p><ul><li>padding：通过填充，让数据落在不同的 cache line 中</li><li>@Contended：原理参考 无锁 → Adder → 优化机制 → 伪共享</li></ul><p>Linux 查看 CPU 缓存行：</p><ul><li>命令：<code>cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size64</code></li><li>内存地址格式：[高位组标记] [低位索引] [偏移量]</li></ul><h4 id="缓存一致"><a href="#缓存一致" class="headerlink" title="缓存一致"></a>缓存一致</h4><p>缓存一致性：当多个处理器运算任务都涉及到同一块主内存区域的时候，将可能导致各自的缓存数据不一样</p><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=MjZhMzM1ZmQ5YzQ0ODM4NzEyZmE0YTcyMzc2NDU4YzdfVk5RUGM4NVBrUmlYa3dOZzFISVRZSWlnRHQzWURabVJfVG9rZW46SkFNemJRU2hIb2xVbHB4Q2dJemNzdWdTbkFkXzE3NDAzMTg3NzI6MTc0MDMyMjM3Ml9WNA" alt="img"></p><p>MESI（Modified Exclusive Shared Or Invalid）是一种广泛使用的<strong>支持写回策略的缓存一致性协议</strong>，CPU 中每个缓存行（caceh line）使用 4 种状态进行标记（使用额外的两位 bit 表示)：</p><ul><li>M：被修改（Modified）</li><li>该缓存行只被缓存在该 CPU 的缓存中，并且是被修改过的，与主存中的数据不一致 (dirty)，该缓存行中的内存需要写回 (write back) 主存。该状态的数据再次被修改不会发送广播，因为其他核心的数据已经在第一次修改时失效一次</li><li>当被写回主存之后，该缓存行的状态会变成独享 (exclusive) 状态</li><li>E：独享的（Exclusive）</li><li>该缓存行只被缓存在该 CPU 的缓存中，是未被修改过的 (clear)，与主存中数据一致，修改数据不需要通知其他 CPU 核心，该状态可以在任何时刻有其它 CPU 读取该内存时变成共享状态 (shared)</li><li>当 CPU 修改该缓存行中内容时，该状态可以变成 Modified 状态</li><li>S：共享的（Shared）</li><li>该状态意味着该缓存行可能被多个 CPU 缓存，并且各个缓存中的数据与主存数据一致，当 CPU 修改该缓存行中，会向其它 CPU 核心广播一个请求，使该缓存行变成无效状态 (Invalid)，然后再更新当前 Cache 里的数据</li><li>I：无效的（Invalid）</li><li>该缓存是无效的，可能有其它 CPU 修改了该缓存行</li></ul><p>解决方法：各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，协议主要有 MSI、MESI 等</p><h4 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h4><p>单核 CPU 处理器会自动保证基本内存操作的原子性</p><p>多核 CPU 处理器，每个 CPU 处理器内维护了一块内存，每个内核内部维护着一块缓存，当多线程并发读写时，就会出现缓存数据不一致的情况。处理器提供：</p><ul><li>总线锁定：当处理器要操作共享变量时，在 BUS 总线上发出一个 LOCK 信号，其他处理器就无法操作这个共享变量，该操作会导致大量阻塞，从而增加系统的性能开销（<strong>平台级别的加锁</strong>）</li><li>缓存锁定：当处理器对缓存中的共享变量进行了操作，其他处理器有嗅探机制，将各自缓存中的该共享变量的失效，读取时会重新从主内存中读取最新的数据，基于 MESI 缓存一致性协议来实现</li></ul><p>有如下两种情况处理器不会使用缓存锁定：</p><ul><li>当操作的数据跨多个缓存行，或没被缓存在处理器内部，则处理器会使用总线锁定</li><li>有些处理器不支持缓存锁定，比如：Intel 486 和 Pentium 处理器也会调用总线锁定</li></ul><p>总线机制：</p><ul><li>总线嗅探：每个处理器通过嗅探在总线上传播的数据来检查自己缓存值是否过期了，当处理器发现自己的缓存对应的内存地址的数据被修改，就<strong>将当前处理器的缓存行设置为无效状态</strong>，当处理器对这个数据进行操作时，会重新从内存中把数据读取到处理器缓存中</li><li>总线风暴：当某个 CPU 核心更新了 Cache 中的数据，要把该事件广播通知到其他核心（<strong>写传播</strong>），CPU 需要每时每刻监听总线上的一切活动，但是不管别的核心的 Cache 是否缓存相同的数据，都需要发出一个广播事件，不断的从主内存嗅探和 CAS 循环，无效的交互会导致总线带宽达到峰值；因此不要大量使用 volatile 关键字，使用 volatile、syschonized 都需要根据实际场景</li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h4><p>volatile 是 Java 虚拟机提供的<strong>轻量级</strong>的同步机制（三大特性）</p><ul><li>保证可见性</li><li>不保证原子性</li><li>保证有序性（<strong>禁止指令重排</strong>）</li></ul><p>性能：volatile 修饰的变量进行读操作与普通变量几乎没什么差别，但是写操作相对慢一些，因为需要在本地代码中插入很多内存屏障来保证指令不会发生乱序执行，但是开销比锁要小</p><p>synchronized 无法禁止指令重排和处理器优化，为什么可以保证有序性可见性</p><ul><li>加了锁之后，只能有一个线程获得到了锁，获得不到锁的线程就要阻塞，所以同一时间只有一个线程执行，相当于单线程，由于数据依赖性的存在，单线程的指令重排是没有问题的</li><li>线程加锁前，将<strong>清空工作内存</strong>中共享变量的值，使用共享变量时需要从主内存中重新读取最新的值；线程解锁前，必须把共享变量的最新值<strong>刷新到主内存</strong>中（JMM 内存交互章节有讲）</li></ul><h4 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h4><p>volatile 修饰的变量，可以禁用指令重排</p><p>指令重排实例：</p><ul><li>example 1：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mySort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11</span>;        <span class="comment">//语句1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">12</span>;        <span class="comment">//语句2  谁先执行效果一样</span></span><br><span class="line">        x = x + <span class="number">5</span>;        <span class="comment">//语句3</span></span><br><span class="line">        y = x * x;        <span class="comment">//语句4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行顺序是：1 2 3 4、2 1 3 4、1 3 2 4</li><li>指令重排也有限制不会出现：4321，语句 4 需要依赖于 y 以及 x 的申明，因为存在数据依赖，无法首先执行</li><li>example 2：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 线程1 执行此方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程2 执行此方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>情况一：线程 1 先执行，ready &#x3D; false，结果为 r.r1 &#x3D; 1</li><li>情况二：线程 2 先执行 num &#x3D; 2，但还没执行 ready &#x3D; true，线程 1 执行，结果为 r.r1 &#x3D; 1</li><li>情况三：线程 2 先执行 ready &#x3D; true，线程 1 执行，进入 if 分支结果为 r.r1 &#x3D; 4</li><li>情况四：线程 2 执行 ready &#x3D; true，切换到线程 1，进入 if 分支为 r.r1 &#x3D; 0，再切回线程 2 执行 num &#x3D; 2，发生指令重排</li></ul><h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><h5 id="缓存一致-1"><a href="#缓存一致-1" class="headerlink" title="缓存一致"></a>缓存一致</h5><p>使用 volatile 修饰的共享变量，底层通过汇编 lock 前缀指令进行缓存锁定，在线程修改完共享变量后写回主存，其他的 CPU 核心上运行的线程通过 CPU 总线嗅探机制会修改其共享变量为失效状态，读取时会重新从主内存中读取最新的数据</p><p>lock 前缀指令就相当于内存屏障，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后会加入写屏障</li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><p>内存屏障有三个作用：</p><ul><li>确保对内存的读-改-写操作原子执行</li><li>阻止屏障两侧的指令重排序</li><li>强制把缓存中的脏数据写回主内存，让缓存行中相应的数据失效</li></ul><h5 id="内存屏障（写屏障、读屏障）"><a href="#内存屏障（写屏障、读屏障）" class="headerlink" title="内存屏障（写屏障、读屏障）"></a>内存屏障（写屏障、读屏障）</h5><p>保证<strong>可见性</strong>：</p><ul><li>写屏障（sfence，Store Barrier）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="literal">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">    <span class="comment">// 写屏障（同步到主存中）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>读屏障（lfence，Load Barrier）保证在该屏障之后的，对共享变量的读取，从主存刷新变量值，加载的是主存中最新数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    <span class="comment">// 读屏障（保证之后的读操作都是主存中的内容）</span></span><br><span class="line">    <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=NzgwNDEyN2QxMzZhMjNkYTMyNDNkZTU3MGVlMzMyYmNfWWdGM1RrTExIWW41VWR0ejhWdnhZRHpFTld5YUFTQlVfVG9rZW46VlVWU2JIdFdzb2IyNEp4aVQxQWNGZHJxblliXzE3NDAzMTg3NzI6MTc0MDMyMjM3Ml9WNA" alt="img"></p><ul><li>全能屏障：mfence（modify&#x2F;mix Barrier），兼具 sfence 和 lfence 的功能</li></ul><p><strong>保证有序性</strong>：</p><ul><li>写屏障会确保指令重排序时，<strong>不会将写屏障之前的代码排在写屏障之后</strong></li><li>读屏障会确保指令重排序时，<strong>不会将读屏障之后的代码排在读屏障之前</strong></li></ul><p><strong>不能解决指令交错</strong>：</p><ul><li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证其他线程的读跑到写屏障之前</li><li>有序性的保证也只是保证了本线程内相关代码不被重排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">volatile</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;i++&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;i--&#125;);</span><br></pre></td></tr></table></figure><ul><li>i++ 反编译后的指令：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: iconst_1                        <span class="comment">// 当int取值 -1~5 时，JVM采用iconst指令将常量压入栈中</span></span><br><span class="line"><span class="number">1</span>: istore_1                        <span class="comment">// 将操作数栈顶数据弹出，存入局部变量表的 slot 1</span></span><br><span class="line"><span class="number">2</span>: iinc                <span class="number">1</span>, <span class="number">1</span>        </span><br></pre></td></tr></table></figure><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=NGZhYTU2YzdjOGJkZjgyMjA3MjRkNTA0NWQ0YjIzMGNfdUoyUVdZY05JNU5kb25pZTJSNlhuOGdnWGs2NjdicUJfVG9rZW46RTZydmIxUmFXb044emd4Vkx0ZGM4V21Ybk50XzE3NDAzMTg3NzI6MTc0MDMyMjM3Ml9WNA" alt="img"></p><h5 id="交互规则"><a href="#交互规则" class="headerlink" title="交互规则"></a>交互规则</h5><p>对于 volatile 修饰的变量：</p><ul><li>线程对变量的 use 与 load、read 操作是相关联的，所以变量使用前必须先从主存加载</li><li>线程对变量的 assign 与 store、write 操作是相关联的，所以变量使用后必须同步至主存</li><li>线程 1 和线程 2 谁先对变量执行 read 操作，就会先进行 write 操作，防止指令重排</li></ul><h4 id="双端检锁（dcl——double-checked-locking）"><a href="#双端检锁（dcl——double-checked-locking）" class="headerlink" title="双端检锁（dcl——double-checked locking）"></a>双端检锁（dcl——double-checked locking）</h4><p><strong>为什么要有dcl？</strong></p><p>比如说对于懒汉式的单例模式，它实际上只有第一次初始化的时候需要加上synchronized，创建之后就不用加上同步块，否则会造成性能损耗。因此有人想出了dcl。</p><h5 id="检锁机制"><a href="#检锁机制" class="headerlink" title="检锁机制"></a>检锁机制</h5><p>Double-Checked Locking：双端检锁机制</p><p>DCL（双端检锁）机制不一定是线程安全的，<strong>原因是有指令重排的存在（<strong><strong>注意，synchronized可以保证共享变量的原子、有序、可见，但是在synchronized中依旧会有重拍存在，但是synchronized能保证他是安全的</strong></strong>），加入 volatile 可以禁止指令重排</strong></p><p><strong>简单来说，就是INSTANCE这个变量没有完全被synchronized保护，导致其同时被其他线程访问。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//这里没有加volatile，会有问题</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// t2，这里的判断不是线程安全的</span></span><br><span class="line">            <span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 这里是线程安全的判断，防止其他线程在当前线程等待锁的期间完成了初始化</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; </span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不锁 INSTANCE 的原因：</p><ul><li>INSTANCE 要重新赋值</li><li>INSTANCE 是 null，线程加锁之前需要获取对象的引用，设置对象头，null 没有引用</li></ul><p>实现特点：</p><ul><li>懒惰初始化</li><li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li><li>第一个 if 使用了 INSTANCE 变量，是在同步块之外，但在多线程环境下会产生问题</li></ul><h5 id="DCL问题"><a href="#DCL问题" class="headerlink" title="DCL问题"></a>DCL问题</h5><p>getInstance 方法对应的字节码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:         getstatic                 #<span class="number">2</span>                 <span class="comment">// Field INSTANCE:Ltest/Singleton;</span></span><br><span class="line"><span class="number">3</span>:         ifnonnull                 <span class="number">37</span></span><br><span class="line"><span class="number">6</span>:         ldc                         #<span class="number">3</span>                 <span class="comment">// class test/Singleton</span></span><br><span class="line"><span class="number">8</span>:         dup</span><br><span class="line"><span class="number">9</span>:         astore_0</span><br><span class="line"><span class="number">10</span>: monitorenter</span><br><span class="line"><span class="number">11</span>: getstatic                 #<span class="number">2</span>                 <span class="comment">// Field INSTANCE:Ltest/Singleton;</span></span><br><span class="line"><span class="number">14</span>: ifnonnull <span class="number">27</span></span><br><span class="line"><span class="number">17</span>: <span class="keyword">new</span>                         #<span class="number">3</span>                 <span class="comment">// class test/Singleton</span></span><br><span class="line"><span class="number">20</span>: dup</span><br><span class="line"><span class="number">21</span>: invokespecial         #<span class="number">4</span>                 <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">24</span>: putstatic                 #<span class="number">2</span>                 <span class="comment">// Field INSTANCE:Ltest/Singleton;</span></span><br><span class="line"><span class="number">27</span>: aload_0</span><br><span class="line"><span class="number">28</span>: monitorexit</span><br><span class="line"><span class="number">29</span>: goto <span class="number">37</span></span><br><span class="line"><span class="number">32</span>: astore_1</span><br><span class="line"><span class="number">33</span>: aload_0</span><br><span class="line"><span class="number">34</span>: monitorexit</span><br><span class="line"><span class="number">35</span>: aload_1</span><br><span class="line"><span class="number">36</span>: athrow</span><br><span class="line"><span class="number">37</span>: getstatic                 #<span class="number">2</span>                 <span class="comment">// Field INSTANCE:Ltest/Singleton;</span></span><br><span class="line"><span class="number">40</span>: areturn</span><br></pre></td></tr></table></figure><ul><li>17 表示创建对象，将对象引用入栈</li><li>20 表示复制一份对象引用，引用地址</li><li>21 表示利用一个对象引用，调用构造方法初始化对象</li><li>24 表示利用一个对象引用，赋值给 static INSTANCE</li></ul><p><strong>步骤 21 和 24 之间不存在数据依赖关系</strong>，而且无论重排前后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的</p><ul><li>关键在于 0:getstatic 这行代码在 monitor 控制之外，可以越过 monitor 读取 INSTANCE 变量的值</li><li>当其他线程访问 INSTANCE 不为 null 时，由于 INSTANCE 实例未必已初始化，那么 t2 拿到的是将是一个未初始化完毕的单例返回，这就造成了线程安全的问题</li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=NTE5Y2YyMDFkNmRlYjMyM2RhYTRkMzcyY2ZiYmQzZGZfNk1OZ3ZGVEQ3eWRVZlM0TmcxNmJsWVF1ZUlGRjhnVWlfVG9rZW46SjFtbWJCaVhUb2ZSeDl4a2RybGNvMnM1blVnXzE3NDAzMTg3NzI6MTc0MDMyMjM3Ml9WNA" alt="img"></p><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性</p><p>引入 volatile，来保证出现指令重排的问题，从而保证单例模式的线程安全性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">SingletonDemo</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="happens-before（先行发生）"><a href="#happens-before（先行发生）" class="headerlink" title="happens-before（先行发生）"></a>happens-before（先行发生）</h3><p>happens-before 先行发生</p><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=MTcwNDcyNjdiOTcwOTQ2MmMyOWE5NTQ1OWE2ZDJlM2NfYUhtS2w4d1pmZUtCakpaVHRDOW5BUThsNllTUDRhRVVfVG9rZW46TEdxYmJSd1FNbzVkS3h4ZHJhbWNNSjFjblZlXzE3NDAzMTg3NzI6MTc0MDMyMjM3Ml9WNA" alt="img"></p><p>Java 内存模型具备一些<strong>先天的“有序性”</strong>，即不需要通过任何同步手段（volatile、synchronized 等）就能够得到保证的安全，这个通常也称为 <strong>happens-before 原则</strong>，它是可见性与有序性的一套规则总结</p><p>不符合 happens-before 规则，JMM 并不能保证一个线程的可见性和有序性</p><ol><li>程序次序规则 (Program Order Rule)：一个线程内，逻辑上书写在前面的操作先行发生于书写在后面的操作 ，因为多个操作之间有先后依赖关系，则不允许对这些操作进行重排序</li><li>锁定规则 (Monitor Lock Rule)：一个 unlock 操作先行发生于后面（时间的先后）对同一个锁的 lock 操作，所以线程解锁 m 之前对变量的写（解锁前会刷新到主内存中），对于接下来对 m 加锁的其它线程对该变量的读可见</li><li><strong>volatile 变量规则</strong> (Volatile Variable Rule)：对 volatile 变量的写操作先行发生于后面对这个变量的读</li><li>传递规则 (Transitivity)：具有传递性，如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C</li></ol><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=OGViNWFhNmY5NDA3NDdjODEwZjE4ZmY0Nzc0YzBiNGVfQmtHMlM1MnlTaVZRdExkOTN1YUZSYTJ2aExvUDdFT0ZfVG9rZW46U09OMWJ5TG9kb3plQ1d4QnRMNGM2bTlSbklmXzE3NDAzMTg3NzI6MTc0MDMyMjM3Ml9WNA" alt="img"></p><ol><li>线程启动规则 (Thread Start Rule)：Thread 对象的 start()方法先行发生于此线程中的每一个操作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//线程 start 前对变量的写，对该线程开始后对该变量的读可见</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;        System.out.println(x);        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br></pre></td></tr></table></figure><ol><li>线程中断规则 (Thread Interruption Rule)：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>线程终止规则 (Thread Termination Rule)：线程中所有的操作都先行发生于线程的终止检测，可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行</li><li>对象终结规则（Finaizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始</li></ol><h3 id="设计模式（两阶段终止模式-犹豫模式）"><a href="#设计模式（两阶段终止模式-犹豫模式）" class="headerlink" title="设计模式（两阶段终止模式&amp;犹豫模式）"></a>设计模式（两阶段终止模式&amp;犹豫模式）</h3><h4 id="终止模式"><a href="#终止模式" class="headerlink" title="终止模式"></a>终止模式</h4><p>终止模式之两阶段终止模式：停止标记用 volatile 是为了保证该变量在多个线程之间的可见性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TwoPhaseTermination</span> &#123;</span><br><span class="line">    <span class="comment">// 监控线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread monitor;</span><br><span class="line">    <span class="comment">// 停止标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;后置处理&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 睡眠</span></span><br><span class="line">                    System.out.println(thread.getName() + <span class="string">&quot;执行监控记录&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                           System.out.println(<span class="string">&quot;被打断，退出睡眠&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">        monitor.interrupt();<span class="comment">// 让线程尽快退出Timed Waiting</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">TwoPhaseTermination</span> <span class="variable">tpt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TwoPhaseTermination</span>();</span><br><span class="line">    tpt.start();</span><br><span class="line">    Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;停止监控&quot;</span>);</span><br><span class="line">    tpt.stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Balking"><a href="#Balking" class="headerlink" title="Balking"></a>Balking</h4><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorService</span> &#123;</span><br><span class="line">    <span class="comment">// 用来表示是否已经有线程已经在执行启动了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">starting</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;尝试启动监控线程...&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (starting) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            starting = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 真正启动监控线程...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待</p><p>例子：希望 doInit() 方法仅被调用一次，下面的实现出现的问题：</p><ul><li>当 t1 线程进入 init() 准备 doInit()，t2 线程进来，initialized 还为f alse，则 t2 就又初始化一次</li><li>volatile 适合一个线程写，其他线程读的情况，这个代码需要加锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVolatile</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">initialized</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            doInit();</span><br><span class="line">            initialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doInit</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
            <tag> JMM </tag>
            
            <tag> volatile </tag>
            
            <tag> happens-before </tag>
            
            <tag> 伪共享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC_同步</title>
      <link href="/2025/02/05/JUC-%E5%90%8C%E6%AD%A5/"/>
      <url>/2025/02/05/JUC-%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界资源：一次仅允许一个进程使用的资源成为临界资源</p><p>临界区：访问临界资源的代码块</p><p>竞态条件：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p><p>一个程序运行多个线程是没有问题，多个线程读共享资源也没有问题，在多个线程对共享资源读写操作时发生指令交错，就会出现问题</p><p>为了避免临界区的竞态条件发生（解决线程安全问题）：</p><ul><li>阻塞式的解决方案：synchronized，lock</li><li>非阻塞式的解决方案：原子变量</li></ul><p>管程（monitor）：由局部于自己的若干公共变量和所有访问这些公共变量的过程所组成的软件模块，保证同一时刻只有一个进程在管程内活动，即管程内定义的操作在同一时刻只被一个进程调用（由编译器实现）</p><p><strong>synchronized：对象锁，保证了临界区内代码的原子性</strong>，采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其它线程获取这个对象锁时会阻塞，保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><p>互斥和同步都可以采用 synchronized 关键字来完成，区别：</p><ul><li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</li><li>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</li></ul><p>性能：</p><ul><li>线程安全，性能差</li><li>线程不安全性能好，假如开发中不会存在多线程安全问题，建议使用线程不安全的设计类</li></ul><h3 id="syn-ed"><a href="#syn-ed" class="headerlink" title="syn-ed"></a>syn-ed</h3><h4 id="使用锁"><a href="#使用锁" class="headerlink" title="使用锁"></a>使用锁</h4><h5 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h5><p>锁对象：理论上可以是<strong>任意的唯一对象</strong></p><p>synchronized 是可重入、不公平的重量级锁</p><p>原则上：</p><ul><li>锁对象建议使用共享资源</li><li>在实例方法中使用 this 作为锁对象，锁住的 this 正好是共享资源</li><li>在静态方法中使用类名 .class 字节码作为锁对象，因为静态成员属于类，被所有实例对象共享，所以需要锁住类</li></ul><p>同步代码块格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line">        <span class="comment">// 访问共享资源的核心代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//static修饰，则元素是属于类本身的，不属于对象  ，与类一起加载一次，只有一个</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                    counter++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                    counter--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>把出现线程安全问题的核心方法锁起来，每次只能一个线程进入访问</p><p>synchronized 修饰的方法的不具备继承性，所以子类是线程不安全的，如果子类的方法也被 synchronized 修饰，两个锁对象其实是一把锁，而且是<strong>子类对象作为锁</strong></p><p>用法：直接给方法加上一个修饰符 synchronized</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步方法</span></span><br><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123; </span><br><span class="line">        方法体；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同步静态方法</span></span><br><span class="line">修饰符 <span class="keyword">static</span> <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123; </span><br><span class="line">        方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步方法底层也是有锁对象的：</p><ul><li>如果方法是实例方法：同步方法默认用 this 作为的锁对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;&#125; <span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果方法是静态方法：同步方法默认用类名 .class 作为的锁对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Test.class) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h5><p>线程八锁就是考察 synchronized 锁住的是哪个对象，直接百度搜索相关的实例</p><p>说明：主要关注锁住的对象是不是同一个</p><ul><li>锁住类对象，所有类的实例的方法都是安全的，类的所有实例都相当于同一把锁</li><li>锁住 this 对象，只有在当前实例对象的线程内是安全的，如果有多个实例就不安全</li></ul><p>线程不安全：因为锁住的不是同一个对象，线程 1 调用 a 方法锁住的类对象，线程 2 调用 b 方法锁住的 n2 对象，不是同一个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程安全：因为 n1 调用 a() 方法，锁住的是类对象，n2 调用 b() 方法，锁住的也是类对象，所以线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程安全类"><a href="#线程安全类" class="headerlink" title="线程安全类"></a>线程安全类</h4><p>由于你不能保证之后的子类中是不是会新建线程导致和父线程冲突，所以最后加上final，protect不可被重写。</p><p>有一些类已经被封装成线程安全的了。</p><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=NjEwY2FjOGY0ZGNjY2QxOThjN2RjMzRhYzI2YTk2OGZfS2RzdWJpV0dtMWtJRTBJTGplWUVWTlF4VTJjRGVYY1dfVG9rZW46R3l6MGJZa0ZCb0J1SlR4bkNjc2NJNXpBbkpiXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><p>因为他们的方法加了synchronized</p><p>但是要注意这只能保证他们单个的原子性，不能保证组合的原子性。</p><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=ODBkNjlhNDkyNzI3NDliYzVjMzcwMzNmN2FjMTJmMGRfaHppOWJjaTYxdmtVc3hiUHRmeFd5aHo1WFd5ZjNTT0RfVG9rZW46Sml5UWJ0d1lxb2gwREF4VHRXVGN1c245bldJXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><h5 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h5><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=YmZmMTY0N2ViNTkxNDhmOTcxYTliMjA5YjI3OTVlMDhfU0lGQnRCTW1wRDlxQkFrWG43UXlySkdseTZKUlNWUXlfVG9rZW46Rmg0R2JGVTBFbzZkb2x4TGFpZWNjUEltbldmXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><p>可以看到他们用了final，不能被改变自然不会有线程安全的问题。</p><p>向String的subString，replace等看似改变的方法实际上都是new 一个新的String类。</p><h5 id="判断以下是否线程安全"><a href="#判断以下是否线程安全" class="headerlink" title="判断以下是否线程安全"></a>判断以下是否线程安全</h5><p>Final new data &#x3D; new Data();</p><p>注意data不是线程安全的，data引用的地址不可以改，但是data对象中的内容可以改。</p><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2FhZGQ0MWIwYzRiZDhhZTg2NjM0MGNkZWQ4YTY0YzRfdElDQ1Z0b0s1WHo2alRmWU95SkdCeDFXc2g5UThIazdfVG9rZW46RzZFTWJoZGhvbzhadlR4bWhvMmN0eWJjblJlXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><p>这个是spring中的aop。我们知道spring中的bean一般来说是单例，而这个start作为成员变量而不是局部变量也是单例的，所以会被多个线程共享，这种写法可能会导致线程冲突。可以使用@Around注解，由于使用方法时才会创建局部变量，以此来避免冲突。</p><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=MjY3MjVlZGZlZTc1ZTcwNDI3ZjI0MjYyZjU3NzMwZmRfdldudlE4SVgycHFVcmJkbXZzY1cxZjQ1REJ0YzJiSnZfVG9rZW46QUxTN2JMQ0ZNb1ZtNE94UkMxRmNRTUVIbjBnXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><p>局部变量也不一定是安全的，他有可能被子类继承后创建新的线程然后访问，和主线程共享这个局部变量。</p><p>这也是为什么String类源代码之前有final，他是为了防止子类重写String中高端方法导致线程安全问题。</p><h4 id="锁原理"><a href="#锁原理" class="headerlink" title="锁原理"></a>锁原理</h4><h5 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h5><p>Monitor 被翻译为监视器或管程</p><p>每个 Java 对象都可以关联一个 Monitor 对象，Monitor 也是 class，其<strong>实例存储在堆中</strong>，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针，这就是重量级锁</p><ul><li>Mark Word 结构：最后两位是<strong>锁标志位</strong></li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=OGQ0NDk0ZDIyYjIyMDJkYzU5NzZiYmZkMzMyYzhiYzFfeEx1OG5jWWc0YnZQSnljaHl4UGdkeXJvTHh6dDBucVhfVG9rZW46Uk9FNWJibk9Xb2lCeVh4Q1lFc2NDSlRZbktlXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><ul><li>64 位虚拟机 Mark Word：</li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTExOGU1NGY5ZDE3ODdjM2M0ZTBlZTIyZWJiZTMxNzlfUFhCNGFlVk5NNzBIYlpwcG1nQVFTV0RqbjFBUU83aVNfVG9rZW46T1FIQWJNSXJqbzhxNmd4ZE5IQWN6SEpXbjlnXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><p>工作流程：</p><ul><li>开始时 Monitor 中 Owner 为 null</li><li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor 中只能有一个 Owner，<strong>obj 对象的 Mark Word 指向 Monitor</strong>，把<strong>对象****原有的 MarkWord 存入线程栈中的锁记录</strong>中（轻量级锁部分详解）</li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=MGFlYWJjY2QyNjg3ODhiMTk2ZmUyNDFlZTk1MTAxOWJfMEliVDUydjhuYUxUdFVZMnFzUzJVMGxVa083Z0Z5d2lfVG9rZW46V012aGJ5M1hFb2RONnR4MVprbWNvWGFZblhkXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><ul><li>在 Thread-2 上锁的过程，Thread-3、Thread-4、Thread-5 也执行 synchronized(obj)，就会进入 <strong>EntryList BLOCKED（<strong><strong>双向链表</strong></strong>）</strong></li><li>Thread-2 执行完同步代码块的内容，根据 obj 对象头中 Monitor 地址寻找，设置 Owner 为空，把线程栈的锁记录中的对象头的值设置回 MarkWord</li><li>唤醒 EntryList 中等待的线程来竞争锁，竞争是<strong>非公平的</strong>，如果这时有新的线程想要获取锁，可能直接就抢占到了，阻塞队列的线程就会继续阻塞</li><li>WaitSet 中的 Thread-0，是以前获得过锁，但条件不满足进入 WAITING 状态的线程（wait-notify 机制）</li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=ODllMTIxMzIxN2IyNDA4YWE0MGQwZmFlOGExYmM5ZTlfeUQwNVpRUEl1WDhkYmZVeVdzV3FPWVZNdmQ1VUpscVRfVG9rZW46VHNpVGJPNG1nb2lTUDl4NkFwb2NrMUhEbjNiXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><p>注意：</p><ul><li>synchronized 必须是进入同一个对象的 Monitor 才有上述的效果</li><li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li></ul><h5 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h5><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span>:         <span class="keyword">new</span>                                #<span class="number">2</span>                <span class="comment">// new Object</span></span><br><span class="line"><span class="number">3</span>:         dup</span><br><span class="line"><span class="number">4</span>:         invokespecial         #<span class="number">1</span>                 <span class="comment">// invokespecial &lt;init&gt;:()V，非虚方法</span></span><br><span class="line"><span class="number">7</span>:         astore_1                                 <span class="comment">// lock引用 -&gt; lock</span></span><br><span class="line"><span class="number">8</span>:         aload_1                                        <span class="comment">// lock （synchronized开始）</span></span><br><span class="line"><span class="number">9</span>:         dup                                                <span class="comment">// 一份用来初始化，一份用来引用</span></span><br><span class="line"><span class="number">10</span>: astore_2                                 <span class="comment">// lock引用 -&gt; slot 2</span></span><br><span class="line"><span class="number">11</span>: monitorenter                         <span class="comment">// 【将 lock对象 MarkWord 置为 Monitor 指针】</span></span><br><span class="line"><span class="number">12</span>: getstatic                 #<span class="number">3</span>                <span class="comment">// System.out</span></span><br><span class="line"><span class="number">15</span>: ldc                         #<span class="number">4</span>                <span class="comment">// &quot;ok&quot;</span></span><br><span class="line"><span class="number">17</span>: invokevirtual         #<span class="number">5</span>                 <span class="comment">// invokevirtual println:(Ljava/lang/String;)V</span></span><br><span class="line"><span class="number">20</span>: aload_2                                 <span class="comment">// slot 2(lock引用)</span></span><br><span class="line"><span class="number">21</span>: monitorexit                         <span class="comment">// 【将 lock对象 MarkWord 重置, 唤醒 EntryList】</span></span><br><span class="line"><span class="number">22</span>: goto <span class="number">30</span></span><br><span class="line"><span class="number">25</span>: astore_3                                 <span class="comment">// any -&gt; slot 3</span></span><br><span class="line"><span class="number">26</span>: aload_2                                 <span class="comment">// slot 2(lock引用)</span></span><br><span class="line"><span class="number">27</span>: monitorexit                         <span class="comment">// 【将 lock对象 MarkWord 重置, 唤醒 EntryList】</span></span><br><span class="line"><span class="number">28</span>: aload_3</span><br><span class="line"><span class="number">29</span>: athrow</span><br><span class="line"><span class="number">30</span>: <span class="keyword">return</span></span><br><span class="line">Exception table:</span><br><span class="line">    from to target type</span><br><span class="line">      <span class="number">12</span> <span class="number">22</span> <span class="number">25</span>                 any</span><br><span class="line">      <span class="number">25</span> <span class="number">28</span> <span class="number">25</span>                 any</span><br><span class="line">LineNumberTable: ...</span><br><span class="line">LocalVariableTable:</span><br><span class="line">    Start Length Slot Name Signature</span><br><span class="line">            <span class="number">0</span>         <span class="number">31</span>                 <span class="number">0</span> args [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>         <span class="number">23</span>                 <span class="number">1</span> lock Ljava/lang/Object;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>通过异常 <strong>try-catch 机制</strong>，确保一定会被解锁</li><li>方法级别的 synchronized 不会在字节码指令中有所体现</li></ul><h4 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h4><h5 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程</h5><p><strong>synchronized 是可重入、不公平的重量级锁</strong>，所以可以对其进行优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁        <span class="comment">// 随着竞争的增加，只能锁升级，不能降级</span></span><br></pre></td></tr></table></figure><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程之后重新获取该锁不再需要同步操作：</p><ul><li>当锁对象第一次被线程获得的时候进入偏向状态，标记为 101，同时<strong>使用 CAS 操作将线程 ID 记录到 Mark Word</strong>。如果 CAS 操作成功，这个线程以后进入这个锁相关的同步块，查看这个线程 ID 是自己的就表示没有竞争，就不需要再进行任何同步操作</li><li>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定或轻量级锁状态</li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=MzRkMThiNTRiMDE2MjNjOWJiMTI0OGQzZjJhM2Q0OTBfWmZWdW51VXV3bXdiQkVGazZCajV2Z2FqcmpJa09Va25fVG9rZW46RlhjTmJrSVJob2liNnF4dDY1cGNSYzFIbnFiXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><p>一个对象创建时：</p><ul><li>如果开启了偏向锁（默认开启），那么对象创建后，MarkWord 值为 0x05 即最后 3 位为 101，thread、epoch、age 都为 0</li><li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 <code>-XX:BiasedLockingStartupDelay=0</code> 来禁用延迟。JDK 8 延迟 4s 开启偏向锁原因：在刚开始执行代码时，会有好多线程来抢锁，如果开偏向锁效率反而降低</li><li>当一个对象已经计算过 hashCode，就再也无法进入偏向状态了</li><li>添加 VM 参数 <code>-XX:-UseBiasedLocking</code> 禁用偏向锁</li></ul><p>撤销偏向锁的状态：</p><ul><li>调用对象的 hashCode：偏向锁的对象 MarkWord 中存储的是线程 id，调用 hashCode 导致偏向锁被撤销</li><li>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</li><li>调用 wait&#x2F;notify，需要申请 Monitor，进入 WaitSet</li></ul><p><strong>批量撤销</strong>：如果对象被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</p><ul><li>批量重偏向：当撤销偏向锁阈值超过 20 次后，JVM 会觉得是不是偏向错了，于是在给这些对象加锁时重新偏向至加锁线程</li><li>批量撤销：当撤销偏向锁阈值超过 40 次后，JVM 会觉得自己确实偏向错了，根本就不该偏向，于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</li></ul><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>一个对象有多个线程要加锁，但加锁的时间是错开的（没有竞争），可以使用轻量级锁来优化，<strong>轻量级锁对使用者是透明的（不可见）</strong></p><p>可重入锁：线程可以进入任何一个它已经拥有的锁所同步着的代码块，可重入锁最大的作用是<strong>避免死锁</strong></p><p>轻量级锁在没有竞争时（锁重入时），<strong>每次重入仍然需要执行 CAS 操作，Java 6 才引入的偏向锁来优化</strong></p><p>锁重入实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">            <span class="comment">// 同步块 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建锁记录（Lock Record）对象，每个线程的<strong>栈帧</strong>都会包含一个锁记录的结构，存储锁定对象的 Mark Word</li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=MDU3YjdkYmJlMjVjNTUyZjkwNWRiOWMxMzAzMDFlYWFfUWR4VlNjR3NyMmhoY2I0Y0xGdlBFV3hEcWRJNDVFWkZfVG9rZW46QThwWWJTTmR0b2J6R2t4dE92Z2NNbG9ObnVnXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><ul><li>让锁记录中 Object reference 指向锁住的对象，并尝试用 CAS 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</li><li>如果 CAS 替换成功，对象头中存储了锁记录地址和状态 00（轻量级锁） ，表示由该线程给对象加锁</li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=NmFjYTQ0MmQyNjg2ZThkYjZlZTM4YWQ2Yzc2NzA2Y2ZfWFQ2UUQwSjgzcmo0TlBXWTVqc2Y5b1JDQ3RVVkNTQzJfVG9rZW46RGltRGJFU2ZBbzVab2R4ZXQ4OGNoT3d6bmNkXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><ul><li>如果 CAS 失败，有两种情况：<ul><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入<strong>锁膨胀</strong>过程</li><li>如果是<strong>同一个线程自己执行了 synchronized 锁重入</strong>，就添加一条 Lock Record 作为重入的计数</li></ul></li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=MWJkMzY0YzM0MzIyNDNiMWY0OTM1ZDJiNmJlZTE3ZDBfeDBtYUNhaDRCREQ5QzFSSUtTVVZLUGhNV2pscWM0WDFfVG9rZW46TnpFamJPUE1Fb25yU2R4ZnNGR2NRNnlxbndoXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><ul><li>当退出 synchronized 代码块（解锁时）<ul><li>如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减 1</li><li>如果lock record记录的值不为 null，这时使用 CAS <strong>将</strong> <strong>Mark Word 的值恢复给对象头</strong><ul><li>成功，则解锁成功</li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul></li></ul></li></ul><h5 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h5><p>在尝试加轻量级锁的过程中，CAS 操作无法成功，可能是其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为<strong>重量级锁</strong></p><ul><li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=M2RiMDg1MGE0NWY5YzAxNzQ0MGU5Y2UwY2ZlZmJkZTJfQlJJYllrVkk2RHZldTJoMERseXJkZk1ReTBJclp0VEtfVG9rZW46U3BlMmJGZTdTb3BUd2h4MHBwamMzZmoxbjliXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><ul><li>Thread-1 加轻量级锁失败，进入锁膨胀流程：为 Object 对象申请 Monitor 锁，<strong>通过 Object 对象头获取到持锁线程</strong>，将 Monitor 的 Owner 置为 Thread-0，将 Object 的对象头指向重量级锁地址，然后自己进入 Monitor 的 EntryList BLOCKED</li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=M2M3NTliNDUwZDcyMDhjMGM3OGM1MTI3NDFkZDFmYTJfVWYyM2VXSm1BSXRQNEdBTjllUWRsV2UzaHZJT2hpMldfVG9rZW46SHFBQ2I3S1V3b0Y5cHl4WWJuUmN1dkJiblRoXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><ul><li>当 Thread-0 退出同步块解锁时，使用 CAS 将 Mark Word 的值恢复给对象头失败，这时进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li></ul><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>重量级锁竞争时，尝试获取锁的线程（在entry list中的线程）不会立即阻塞，可以使用<strong>自旋</strong>（默认 10 次）来进行优化，采用循环的方式去尝试获取锁。</p><p><strong>自旋锁的好处在哪里？</strong></p><ul><li>在传统的锁机制（如互斥锁）中，当一个线程请求锁而锁被占用时，线程会被挂起，然后操作系统会将 CPU 的控制权交给其他线程。这就涉及到<strong>上下文切换</strong>，包括保存当前线程的状态，加载另一个线程的状态等，操作系统调度可能会带来较大的性能开销。</li><li><strong>自旋锁避免了线程的挂起与唤醒，因此可以显著减少上下文切换的次数。</strong>特别是在锁持有时间较短时，频繁的上下文切换反而会造成更大的性能损失。</li></ul><p>注意：</p><ul><li>自旋占用 CPU 时间，单核 CPU 自旋就是浪费时间，因为同一时刻只能运行一个线程，多核 CPU 自旋才能发挥优势</li><li>自旋失败的线程会进入阻塞状态</li></ul><p>优点：不会进入阻塞状态，<strong>减少线程上下文切换的消耗</strong></p><p>缺点：当自旋的线程越来越多时，会不断的消耗 CPU 资源</p><p>自旋锁情况：</p><ul><li>自旋成功的情况：</li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=MGM4MDcyODJmNWM0ZDQyN2MwOGNjMGZhOTNhOGU4MjlfZmJPMkdLZWJlNmx4bW93ekVoRW9hUlJqQ2NqZ0R0Z0VfVG9rZW46VkJySmJZNHhybzFqWXl4NUhGT2NnTlNqbjdiXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><ul><li>自旋失败的情况：</li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=YWYxMzVmZTEyOGY1N2QyZTc2YjgzZGYzM2Y2YTAzZGFfQlpiMGNUNUJnZk5rd1hVcWswcnpNeUltbHZoUVBoTU5fVG9rZW46RG5kaGJ4VkxxbzlXeW54V1pRZ2NNOUVlbnhkXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><p>自旋锁说明：</p><ul><li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，比较智能</li><li>Java 7 之后不能控制是否开启自旋功能，由 JVM 控制</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手写自旋锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line">    <span class="comment">// 泛型装的是Thread，原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始自旋，期望值为null，更新值是当前线程</span></span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>, thread)) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(thread.getName() + <span class="string">&quot; 正在自旋&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot; 自旋成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程使用完锁把引用变为null</span></span><br><span class="line">                atomicReference.compareAndSet(thread, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot; invoke unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SpinLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpinLock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//占有锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>); </span><br><span class="line"></span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让main线程暂停1秒，使得t1线程，先执行</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除，这是 JVM <strong>即时编译器的优化</strong></p><p>锁消除主要是通过<strong>逃逸分析</strong>来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除（同步消除：JVM 逃逸分析）</p><h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>对相同对象多次加锁，导致线程发生多次重入，频繁的加锁操作就会导致性能损耗，可以使用锁粗化方式优化</p><p>如果虚拟机探测到一串的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部</p><ul><li>一些看起来没有加锁的代码，其实隐式的加了很多锁：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，转化为 StringBuffer 对象的连续 append() 操作，每个 append() 方法中都有一个同步块</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，只需要加锁一次就可以</p><h4 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h4><p>多把不相干的锁：一间大屋子有两个功能睡觉、学习，互不相干。现在一人要学习，一人要睡觉，如果只用一间屋子（一个对象锁）的话，那么并发度很低</p><p>将锁的粒度细分：</p><ul><li>好处，是可以增强并发度</li><li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li></ul><p>解决方法：准备多个对象锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BigRoom</span> <span class="variable">bigRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigRoom</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; bigRoom.study(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; bigRoom.sleep(); &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigRoom</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">studyRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">sleepRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sleepRoom) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;sleeping 2 小时&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (studyRoom) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;study 1 小时&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h4><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><h6 id="形成"><a href="#形成" class="headerlink" title="形成"></a>形成</h6><p>死锁：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放，由于线程被无限期地阻塞，因此程序不可能正常终止</p><p>Java 死锁产生的四个必要条件：</p><ol><li>互斥条件，即当资源被一个线程使用（占有）时，别的线程不能使用</li><li>不可剥夺条件，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放</li><li>请求和保持条件，即当资源请求者在请求其他的资源的同时保持对原有资源的占有</li><li>循环等待条件，即存在一个等待循环队列：p1 要 p2 的资源，p2 要 p1 的资源，形成了一个等待环路</li></ol><p>四个条件都成立的时候，便形成死锁。死锁情况下打破上述任何一个条件，便可让死锁消失</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resources1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resources2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 线程1：占用资源1 ，请求资源2</span></span><br><span class="line">            <span class="keyword">synchronized</span>(resources1)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1已经占用了资源1，开始请求资源2&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);<span class="comment">//休息两秒，防止线程1直接运行完成。</span></span><br><span class="line">                <span class="comment">//2秒内线程2肯定可以锁住资源2</span></span><br><span class="line">                <span class="keyword">synchronized</span> (resources2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1已经占用了资源2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 线程2：占用资源2 ，请求资源1</span></span><br><span class="line">            <span class="keyword">synchronized</span>(resources2)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2已经占用了资源2，开始请求资源1&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resources1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2已经占用了资源1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;&#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h6><p>定位死锁的方法：</p><ul><li>使用 jps 定位进程 id，再用 <code>jstack id</code> 定位死锁，找到死锁的线程去查看源码，解决优化</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Thread-1&quot;</span> <span class="comment">#12 prio=5 os_prio=0 tid=0x000000001eb69000 nid=0xd40 waiting formonitor entry [0x000000001f54f000]</span></span><br><span class="line">        java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line"><span class="comment">#省略    </span></span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span> <span class="comment">#12 prio=5 os_prio=0 tid=0x000000001eb69000 nid=0xd40 waiting for monitor entry [0x000000001f54f000]</span></span><br><span class="line">        java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line"><span class="comment">#省略</span></span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line">    waiting to lock monitor 0x000000000361d378 (object 0x000000076b5bf1c0, a java.lang.Object),</span><br><span class="line">    <span class="built_in">which</span> is held by <span class="string">&quot;Thread-0&quot;</span></span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line">    waiting to lock monitor 0x000000000361e768 (object 0x000000076b5bf1d0, a java.lang.Object),</span><br><span class="line">    <span class="built_in">which</span> is held by <span class="string">&quot;Thread-1&quot;</span></span><br><span class="line"></span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line">    at thread.TestDeadLock.lambda$main<span class="variable">$1</span>(TestDeadLock.java:28)</span><br><span class="line">    - waiting to lock &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)</span><br><span class="line">    - locked &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)</span><br><span class="line">    at thread.TestDeadLock$$Lambda<span class="variable">$2</span>/883049899.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line">    at thread.TestDeadLock.lambda$main<span class="variable">$0</span>(TestDeadLock.java:15)</span><br><span class="line">    - waiting to lock &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)</span><br><span class="line">    - locked &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)</span><br><span class="line">    at thread.TestDeadLock$$Lambda<span class="variable">$1</span>/495053715</span><br></pre></td></tr></table></figure><ul><li>Linux 下可以通过 top 先定位到 CPU 占用高的 Java 进程，再利用 <code>top -Hp 进程id</code> 来定位是哪个线程，最后再用 jstack 的输出来看各个线程栈</li><li>避免死锁：避免死锁要注意加锁顺序</li><li>可以使用 jconsole 工具，在 <code>jdk\bin</code> 目录下</li></ul><h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><p>活锁：指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试—失败—尝试—失败的过程</p><p>两个线程互相改变对方的结束条件，最后谁也无法结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestLiveLock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                count--;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程一count:&quot;</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程二count:&quot;</span>+ count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h5><p>饥饿：一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束</p><p>如何解决死锁？</p><p>可以让其顺序加锁</p><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=OTlhYjI4ZmQ3NTE3ODVkMmU2NzQ4NDYyZGY1NWFmYzNfbGZObHQwQ21nMTF4ck9FY2xEQXFCeTVBc1UxNWZ0dGlfVG9rZW46WmhhUWJveEgyb2ZYY2Z4ckNXNGNqUXVWbmtkXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=N2FkMGI3NjE2ZTg1YzFmMWM5OWY0ZmFkODJhNzY3ZGRfNGdsQmlZVGRGZGZwTzZjRjR4b0d0N3dzOWY1YkQ0ejNfVG9rZW46VWh3MGJ2RlR2b3BDWDJ4bnUxRGN2b0xRbm1nXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=YTFjYjFiNjU2ZTZiNTlkNmQwNGY4NzMwZjNjNThmNWJfaEtvTDE1VTdPSkFsOTYzWEpBRUpSdXpTTml3Sk54RmZfVG9rZW46RXZqSWJPdzV4b0tGNGl4dUI5WWN4eVdDbkNlXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><p>此时第五个哲学家顺序是1,5而不是5,1。此时不会发生死锁，但是会发生饥饿。</p><h3 id="wait-ify"><a href="#wait-ify" class="headerlink" title="wait-ify"></a>wait-ify</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>需要获取对象锁后才可以调用 <code>锁对象.wait()</code>，notify 随机唤醒一个线程，notifyAll 唤醒所有线程去竞争 CPU</p><p>Object 类 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>:唤醒正在等待对象监视器的单个线程。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>:唤醒正在等待对象监视器的所有线程。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span>:导致当前线程等待，直到另一个线程调用该对象的 notify() 方法或 notifyAll()方法。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span>:有时限的等待, 到n毫秒后结束等待，或是被唤醒</span><br></pre></td></tr></table></figure><p>说明：<strong>wait 是挂起线程，需要唤醒的都是挂起操作</strong>，阻塞线程可以自己去争抢锁，挂起的线程需要唤醒后去争抢锁</p><p>对比 sleep()：</p><ul><li>原理不同：sleep() 方法是属于 Thread 类，是线程用来控制自身流程的，使此线程暂停执行一段时间而把执行机会让给其他线程；wait() 方法属于 Object 类，用于线程间通信</li><li>对<strong>锁的处理机制</strong>不同：调用 sleep() 方法的过程中，线程不会释放对象锁，当调用 wait() 方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池（不释放锁其他线程怎么抢占到锁执行唤醒操作），但是都会释放 CPU</li><li>使用区域不同：wait() 方法必须放在<strong>同步控制方法和同步代码块（先获取锁）</strong>中使用，sleep() 方法则可以放在任何地方使用</li></ul><p>底层原理：</p><ul><li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li><li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li><li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li><li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，唤醒后并不意味者立刻获得锁，<strong>需要进入 EntryList 重新竞争</strong></li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDc4ZDYyMWRhOTM1YzQzNTdiMGIzNDdiMDUzMmI5MmNfSWp4MlEzR0VUMnF3TmdwUnBHRmxBdE1RbFF3UktEQUxfVG9rZW46THczZ2JORHBnbzM2dTd4ZDVBN2NzMjdkbm1mXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>虚假唤醒：notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程</p><p>解决方法：采用 notifyAll</p><p>notifyAll 仅解决某个线程的唤醒问题，使用 if + wait 判断仅有一次机会，一旦条件不成立，无法重新判断</p><p>解决方法：用 while + wait，当条件不成立，再次 wait</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;    <span class="comment">//有没有烟</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">while</span> (!hasCigarette) &#123;<span class="comment">//while防止虚假唤醒</span></span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">if</span> (!hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">if</span> (hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 这里能不能加 synchronized (room)？</span></span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                hasTakeout = <span class="literal">true</span>;</span><br><span class="line">                                <span class="comment">//log.debug(&quot;烟到了噢！&quot;);</span></span><br><span class="line">                log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">                room.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="park-un"><a href="#park-un" class="headerlink" title="park-un"></a>park-un</h3><p>LockSupport 是用来创建锁和其他同步类的<strong>线程原语</strong></p><p>LockSupport 类方法：</p><ul><li><code>LockSupport.park()</code>：暂停当前线程，挂起原语</li><li><code>LockSupport.unpark(暂停的线程对象)</code>：恢复某个线程的运行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);        <span class="comment">//1</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">// Thread.sleep(3000)</span></span><br><span class="line">        <span class="comment">// 先 park 再 unpark 和先 unpark 再 park 效果一样，都会直接恢复线程的运行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;park...&quot;</span>);        <span class="comment">//2</span></span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">&quot;resume...&quot;</span>);<span class="comment">//4</span></span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">           Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;unpark...&quot;</span>);        <span class="comment">//3</span></span><br><span class="line">    LockSupport.unpark(t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LockSupport 出现就是为了增强 wait &amp; notify 的功能：</p><ul><li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park、unpark 不需要</li><li>park &amp; unpark <strong>以线程为单位</strong>来阻塞和唤醒线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程</li><li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify。类比生产消费，先消费发现有产品就消费，没有就等待；先生产就直接产生商品，然后线程直接消费</li><li>wait 会释放锁资源进入等待队列，<strong>park 不会释放锁资源</strong>，只负责阻塞当前线程，会释放 CPU</li></ul><p>原理：类似生产者消费者</p><ul><li>先 park：<ul><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 0，这时获得 _mutex 互斥锁</li><li>线程进入 _cond 条件变量挂起</li><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>唤醒 _cond 条件变量中的 Thread_0，Thread_0 恢复运行，设置 _counter 为 0</li></ul></li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=YWZlM2M5NTZmNjdlNmJlNGE1M2U1YzIyNTc2NzI5Y2NfaTdzZmRVb1BQcXJLTlRkWUt6d1g0d1cxa01ERzlkYW5fVG9rZW46UkFUN2JzemtSb3ZwcHZ4RUhLQWNHc3pJblJnXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><ul><li>先 unpark：<ul><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 1，这时线程无需挂起，继续运行，设置 _counter 为 0</li></ul></li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=YWFkMTExNDk3MGUxZjUwMjkyNWVhMzgwZmFiZWUzZWZfN1FpblhQYmlyVGhhMFNWY211a3RvUGVXU0IwZ1NLV1hfVG9rZW46SnR6MmIwcW1ob3hzMFl4dEMyZGNTNVFJbm5iXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><h3 id="安全分析"><a href="#安全分析" class="headerlink" title="安全分析"></a>安全分析</h3><p>成员变量和静态变量：</p><ul><li>如果它们没有共享，则线程安全</li><li>如果它们被共享了，根据它们的状态是否能够改变，分两种情况：<ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全问题</li></ul></li></ul><p>局部变量：</p><ul><li>局部变量是线程安全的</li><li>局部变量引用的对象不一定线程安全（逃逸分析）：<ul><li>如果该对象没有逃离方法的作用访问，它是线程安全的（每一个方法有一个栈帧）</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全问题（暴露引用）</li></ul></li></ul><p>常见线程安全类：String、Integer、StringBuffer、Random、Vector、Hashtable、java.util.concurrent 包</p><ul><li>线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的</li><li><strong>每个方法是原子的，但多个方法的组合不是原子的</strong>，只能保证调用的方法内部安全：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Hashtable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line"><span class="comment">// 线程1，线程2</span></span><br><span class="line"><span class="keyword">if</span>(table.get(<span class="string">&quot;key&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        table.put(<span class="string">&quot;key&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无状态类线程安全，就是没有成员变量的类</p><p>不可变类线程安全：String、Integer 等都是不可变类，<strong>内部的状态不可以改变</strong>，所以方法是线程安全</p><ul><li>replace 等方法底层是新建一个对象，复制过去</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();        <span class="comment">// 线程不安全</span></span><br><span class="line"><span class="type">String</span> <span class="variable">S1</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;                                                        <span class="comment">// 线程安全</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">S2</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;                                        <span class="comment">// 线程安全</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">D1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();                                                <span class="comment">// 线程不安全</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Date</span> <span class="variable">D2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();                                        <span class="comment">// 线程不安全，final让D2引用的对象不能变，但对象的内容可以变</span></span><br></pre></td></tr></table></figure><p>抽象方法如果有参数，被重写后行为不确定可能造成线程不安全，被称之为外星方法：<code>public abstract foo(Student s);</code></p><h3 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h3><h4 id="保护性暂停"><a href="#保护性暂停" class="headerlink" title="保护性暂停"></a>保护性暂停</h4><h5 id="单任务版"><a href="#单任务版" class="headerlink" title="单任务版"></a>单任务版</h5><p>Guarded Suspension，用在一个线程等待另一个线程的执行结果（<strong>一个线程对应一个线程</strong>）</p><ul><li>有一个结果需要从一个线程传递到另一个线程，让它们关联同一个 GuardedObject</li><li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者&#x2F;消费者）</li><li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDU4YWQxZjRhODQwMDY1YmNlZmRiZDkwODcwMzI5YjhfRVpybXRVNFdOWGt6NTJnU3ljVnBzZDVKVWcwYkhEbFhfVG9rZW46WDdVYmJZbXplb1B0NE54NTF0bmNyM2JZbm5iXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GuardedObject</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObjectV2</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        object.complete(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>));</span><br><span class="line">    &#125;).start();</span><br><span class="line">    </span><br><span class="line">    <span class="type">Object</span> <span class="variable">response</span> <span class="operator">=</span> object.get(<span class="number">2500</span>);</span><br><span class="line">    <span class="keyword">if</span> (response != <span class="literal">null</span>) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;get response: [&#123;&#125;] lines&quot;</span>, ((List&lt;String&gt;) response).size());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;can&#x27;t get response&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取结果</span></span><br><span class="line">    <span class="comment">//timeout :最大等待时间</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> millis)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 1) 记录最初时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 2) 已经经历的时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">timePassed</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 4) 假设 millis 是 1000，结果在 400 时唤醒了，那么还有 600 要等</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> millis - timePassed;</span><br><span class="line">                log.debug(<span class="string">&quot;waitTime: &#123;&#125;&quot;</span>, waitTime);</span><br><span class="line">                <span class="comment">//经历时间超过最大等待时间退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;break...&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait(waitTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 3) 如果提前被唤醒，这时已经经历的时间假设为 400</span></span><br><span class="line">                timePassed = System.currentTimeMillis() - begin;</span><br><span class="line">                log.debug(<span class="string">&quot;timePassed: &#123;&#125;, object is null &#123;&#125;&quot;</span>,</span><br><span class="line">                        timePassed, response == <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 条件满足，通知等待线程</span></span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            log.debug(<span class="string">&quot;notify...&quot;</span>);</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多任务版"><a href="#多任务版" class="headerlink" title="多任务版"></a>多任务版</h5><p>多任务版保护性暂停：</p><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=YjgwM2VjYmE4NjkxNmEwOGJkMzg4ZmI3ZTk3Y2FiNTZfZm1KaU9adWZobkFJWTBsdm9VV040Q0l2U0R1cllNWDdfVG9rZW46UUJMa2JKUEwwbzNlanh4eUNHcmNsVnZFbkFoXzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">People</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (Integer id : Mailboxes.getIds()) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Postman</span>(id, id + <span class="string">&quot;号快递到了&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.People&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 收信</span></span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> Mailboxes.createGuardedObject();</span><br><span class="line">        log.debug(<span class="string">&quot;开始收信i d:&#123;&#125;&quot;</span>, guardedObject.getId());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">mail</span> <span class="operator">=</span> guardedObject.get(<span class="number">5000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;收到信id:&#123;&#125;，内容:&#123;&#125;&quot;</span>, guardedObject.getId(),mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Postman</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String mail;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> Mailboxes.getGuardedObject(id);</span><br><span class="line">        log.debug(<span class="string">&quot;开始送信i d:&#123;&#125;，内容:&#123;&#125;&quot;</span>, guardedObject.getId(),mail);</span><br><span class="line">        guardedObject.complete(mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Mailboxes</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生唯一的id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">generateId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title function_">getGuardedObject</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> boxes.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title function_">createGuardedObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">go</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>(generateId());</span><br><span class="line">        boxes.put(go.getId(), go);</span><br><span class="line">        <span class="keyword">return</span> go;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title function_">getIds</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> boxes.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line">    <span class="comment">//标识，Guarded Object</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;<span class="comment">//添加get set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="顺序输出"><a href="#顺序输出" class="headerlink" title="顺序输出"></a>顺序输出</h4><p>顺序输出 2 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125;</span></span><br><span class="line">            <span class="comment">// 当没有许可时，当前线程暂停运行；有许可时，用掉这个许可，当前线程恢复运行</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            <span class="comment">// 给线程 t1 发放『许可』（多次连续调用 unpark 只会发放一个『许可』）</span></span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">500</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h4><p>连续输出 5 次 abc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">day2_14</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AwaitSignal</span> <span class="variable">awaitSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwaitSignal</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">a</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">b</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">c</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;a&quot;</span>, a, b);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;b&quot;</span>, b, c);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;c&quot;</span>, c, a);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        awaitSignal.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            awaitSignal.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AwaitSignal</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AwaitSignal</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//参数1：打印内容  参数二：条件变量  参数二：唤醒下一个</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, Condition condition, Condition next)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                next.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步模式（生产者-消费者）"><a href="#异步模式（生产者-消费者）" class="headerlink" title="异步模式（生产者&#x2F;消费者）"></a>异步模式（生产者&#x2F;消费者）</h3><h4 id="传统版"><a href="#传统版" class="headerlink" title="传统版"></a>传统版</h4><p>异步模式之生产者&#x2F;消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShareData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 同步代码块，加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断  防止虚假唤醒</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 等待不能生产</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number);</span><br><span class="line">            <span class="comment">// 通知 唤醒</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 同步代码块，加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断 防止虚假唤醒</span></span><br><span class="line">            <span class="keyword">while</span>(number == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 等待不能消费</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number);</span><br><span class="line">            <span class="comment">// 通知 唤醒</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TraditionalProducerConsumer</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ShareData</span> <span class="variable">shareData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareData</span>();</span><br><span class="line">        <span class="comment">// t1线程，生产</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    shareData.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// t2线程，消费</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                                shareData.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h4><p>异步模式之生产者&#x2F;消费者：</p><ul><li>消费队列可以用来平衡生产和消费的线程资源，不需要产生结果和消费结果的线程一一对应</li><li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li><li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li><li>JDK 中各种阻塞队列，采用的就是这种模式</li></ul><p><img src="https://wvmc78hl9ey.feishu.cn/space/api/box/stream/download/asynccode/?code=YjhmYTg0NDFiMmE2MGNmNTg2NjgyNjYwMDBhOWJkZmNfQ2tUQ0VsZUtKaWhNU29MYjVDMXlZWXlvcXBuUHZRU0NfVG9rZW46Q1lEYmJiVHhyb0JvdjN4aFZBdWMwM0NEbnV4XzE3NDAzMjE4MzI6MTc0MDMyNTQzMl9WNA" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                queue.put(<span class="keyword">new</span> <span class="title class_">Message</span>(id,<span class="string">&quot;值&quot;</span>+id));</span><br><span class="line">            &#125;, <span class="string">&quot;生产者&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> queue.take();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;消费者&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息队列类，Java间线程之间通信</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Message&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//消息的队列集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;<span class="comment">//队列容量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取消息</span></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//检查队列是否为空</span></span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sout(Thread.currentThread().getName() + <span class="string">&quot;:队列为空，消费者线程等待&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从队列的头部获取消息返回</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> list.removeFirst();</span><br><span class="line">            sout(Thread.currentThread().getName() + <span class="string">&quot;：已消费消息--&quot;</span> + message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存入消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="comment">//检查队列是否满</span></span><br><span class="line">            <span class="keyword">while</span> (list.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sout(Thread.currentThread().getName()+<span class="string">&quot;:队列为已满，生产者线程等待&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将消息加入队列尾部</span></span><br><span class="line">            list.addLast(message);</span><br><span class="line">            sout(Thread.currentThread().getName() + <span class="string">&quot;:已生产消息--&quot;</span> + message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line">        <span class="comment">//get set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">consumer</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">producer</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();</span><br><span class="line">    producer.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            queue.put(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    consumer.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;等待消费...&quot;</span>);</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> queue.take();</span><br><span class="line">            System.out.println(<span class="string">&quot;结果为:&quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
            <tag> synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程期末复习</title>
      <link href="/2025/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
      <url>/2025/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一共6个题</p><p>&#x20;</p><p>十个选择 每个3分</p><p>单选+多选，错一个扣0.5</p><p>第二题 和敏捷开发有关，分析题 10</p><p>第三题，看图分析题，和需求分析建模有关 12</p><p>第四题，应用分析题 15</p><p>第五题，图形题，和分析设计（需求分析+概要设计）有关</p><p>第六题，概要设计</p><p>&#x20;</p><p>第一章</p><p>1.1 中的 1.1.1，1.1.2，1.1.3</p><p>1.2 中 1.2.2，1.2.3</p><p>&#x20;</p><p>第二章</p><p>2.1，2.2（2.2.1,2.2.2,2.2.3）</p><p>2.3(2.3.1,2.3.2)</p><p>2.4</p><p>&#x20;</p><p>第三章</p><p>3.1,3.2,3.3,3.4</p><p>&#x20;</p><p>第四章</p><p>4.1（4.1.1，4.1.2，4.1.3（prototype model，spiral model））</p><p>&#x20;</p><p>第五章</p><p>5.1,5.2,5.4(重中之重，5.4.1)，5.5.1</p><p>&#x20;</p><p>第六章</p><p>无</p><p>&#x20;</p><p>第七章</p><p>先看描述，7.1,7.2（7.2.1,7.2.2）,7.3（7.3.1~5），7.4（很重要）</p><p>&#x20;</p><p>第八章</p><p>8.1，8.2.1~8.2.5(标题含义弄懂)，8.5（8.5.1），8.6，8.8</p><p>&#x20;</p><p>第九章</p><p>9.1(9.1.1~9.1.4),9.3(9.3.1~9.3.2很重要)</p><p>&#x20;</p><p>第十章</p><p>10.1,10.2,10.3,10.4,10.5,10.6</p><p>&#x20;</p><p>第十一章</p><p>11.1,11.2,11.3,11.4,11.5(11.5.3~11.5.8)</p><p>&#x20;</p><p>第十二章</p><p>12.1,12.2(尤其是12.2.1),12.3(12.3.1~12.3.8,12.3.10,12.3.12(重点))</p><p>&#x20;</p><p>第十三章</p><p>13.1.1,13.1.2,13.2,13.3.1,13.6(13.6.1重点)</p><p>&#x20;</p><p>第十四章</p><p>14.1.1,14.1.2,14.3（重中之重）</p></blockquote><p><img src="/2025/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/a559444415f487ca99181662b39ed23.jpg"></p><h1 id="第1章"><a href="#第1章" class="headerlink" title="第1章"></a>第1章</h1><blockquote><p>1.1中的1.1.1，1.1.2，1.1.3</p></blockquote><p><img src="/2025/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-10.png"></p><h2 id="1-1-软件的本质-the-nature-of-software"><a href="#1-1-软件的本质-the-nature-of-software" class="headerlink" title="1.1 (软件的本质)the nature of software"></a>1.1 (软件的本质)the nature of software</h2><h3 id="1-1-1-Defining-Software"><a href="#1-1-1-Defining-Software" class="headerlink" title="1.1.1 Defining Software"></a>1.1.1 Defining Software</h3><p>软件是指：</p><p>（1）当执行时能提供所需功能、性能和特性的指令（计算机程序）。</p><p>（2）使程序能够有效处理信息的数据结构。</p><p>（3）以纸质和虚拟形式存在的描述程序操作和使用的说明信息。</p><p>软件是logical rather than physical system element。</p><p>每一次软件故障都表明在分析或设计中存在错误将误差转化为机器的其他阶段可执行代码。</p><h3 id="1-1-2-Software-Application-Domains"><a href="#1-1-2-Software-Application-Domains" class="headerlink" title="1.1.2 Software Application Domains"></a>1.1.2 <strong>Software Application Domains</strong></h3><p>今天，计算机软件有七大类别软件工程师面临的持续挑战：</p><ul><li><p><strong>System software</strong></p></li><li><p><strong>Engineering&#x2F;scientific software</strong></p></li><li><p><strong>Embedded software</strong></p></li><li><p><strong>Product-line software（产品线软件）</strong></p></li><li><p><strong>Web&#x2F;Mobile applications</strong></p></li><li><p><strong>Artificial intelligence software</strong></p></li></ul><h3 id="1-1-3-Legacy-Software（年代遗留软件）"><a href="#1-1-3-Legacy-Software（年代遗留软件）" class="headerlink" title="1.1.3 Legacy Software（年代遗留软件）"></a>1.1.3 Legacy Software（年代遗留软件）</h3><p>传统软件的特点是寿命（<strong>longevity</strong>）和业务关键性（<strong>business criticality</strong>）。不幸的是，有时还有一个额外的特征这存在于遗留软件中——质量差（<strong>poor quality</strong>）。</p><p><strong>As time passes, legacy systems often evolve for one or more of the following reasons:</strong></p><ul><li><p>该软件必须经过调整才能满足新用户的需要计算环境或技术。</p></li><li><p>软件必须增强以实现新的业务要求。</p></li><li><p>软件必须经过扩展才能与其它软件互操作其他更现代的系统或数据库。</p></li><li><p>软件必须重新架构，使其在一个可行的不断发展的计算环境。</p></li></ul><h2 id="1-2-（软件的变化）THE-CHANGING-NATURE-OF-SOFTWARE"><a href="#1-2-（软件的变化）THE-CHANGING-NATURE-OF-SOFTWARE" class="headerlink" title="1.2 （软件的变化）THE CHANGING NATURE OF SOFTWARE"></a>1.2 <strong>（软件的变化）THE CHANGING NATURE OF SOFTWARE</strong></h2><h3 id="1-2-2-Mobile-Applications"><a href="#1-2-2-Mobile-Applications" class="headerlink" title="1.2.2 Mobile Applications"></a>1.2.2 <strong>Mobile Applications</strong></h3><p>在大多数情况下，移动应用程序包含用户界面、互操作性（<strong>interoperability</strong>）具有基于web的资源和本地处理能力。</p><h3 id="1-2-3-Cloud-Computing"><a href="#1-2-3-Cloud-Computing" class="headerlink" title="1.2.3 Cloud Computing"></a>1.2.3 <strong>Cloud Computing</strong></h3><p><strong>computing devices reside outside the cloud and have access to a variety of resources within the cloud. （计算设备驻留在云之外，可以访问云中的各种资源。）</strong></p><p>*<em>These resources encompass <em>applications(Saas,software as service), platforms(Paas),&#x20;</em>&#x61;nd <em>infrastructure(Iaas)</em></em>*</p><p>2.1，2.2（2.2.1,2.2.2,2.2.3）</p><p>2.3(2.3.1,2.3.2)</p><p>2.4</p><h1 id="第2章-software-engineering-x20"><a href="#第2章-software-engineering-x20" class="headerlink" title="第2章 software engineering &#x20;"></a>第2章 software engineering &#x20;</h1><h2 id="2-1-软件工程定义-definition-for-software-engineering"><a href="#2-1-软件工程定义-definition-for-software-engineering" class="headerlink" title="2.1 软件工程定义(definition for software  engineering)"></a>2.1 软件工程定义(<strong>definition for software  engineering</strong>)</h2><p>电气和电子工程师协会（IEEE）对软件工程的定义如下：</p><p>软件工程：</p><p>（1）将系统化、有纪律、可量化（<em><strong>systematic, disciplined, quantifiable</strong></em>）的方法应用于软件的开发、运行和维护(<em><strong>development,  operation, and maintenance of software</strong></em>)；也就是说，将工程应用于软件。</p><p>（2）研究如上所述的方法。</p><h2 id="2-2-软件工程过程-software-process"><a href="#2-2-软件工程过程-software-process" class="headerlink" title="2.2 软件工程过程(software process)"></a>2.2 软件工程过程(software process)</h2><p>*<em>A process is a collection of <em>activities, actions</em>, and <em>tasks&#x20;</em>&#x74;hat are  performed when some work product is to be created.</em>*</p><ul><li><p>An activity strives to achieve a broad objective (e.g., architectural design).  &#x20;</p></li><li><p>An action (e.g., interface design in architectural design) encompasses a set of tasks that produce a major work product (e.g., interface specification).&#x20;</p></li><li><p>A task focuses on a small, but well-defined objective (e.g., conducting interface design) that produces a  tangible outcome.</p></li></ul><h3 id="2-2-1-the-process-framework"><a href="#2-2-1-the-process-framework" class="headerlink" title="2.2.1 the process framework"></a>2.2.1 the process framework</h3><p><strong>A process framework establishes the foundation for a complete software engineering process&#x20;</strong>&#x62;y identifying a small number of framework activities that are applicable to all software projects regardless of their size or complexity.&#x20;</p><p><strong>A generic (通用的) process  framework for software engineering encompasses five activities</strong></p><ul><li><p>Communication.&#x20;</p></li><li><p>Planning（umbrella activities）.&#x20;</p></li><li><p>Modeling.&#x20;</p></li><li><p>Construction.&#x20;</p></li><li><p>Deployment.</p></li></ul><p>The details of the software process will be quit&#x65;<strong>&#x20;different</strong> in each case, but the framework activities remain th&#x65;<strong>&#x20;same.</strong></p><h3 id="2-2-2-umbrella-activities"><a href="#2-2-2-umbrella-activities" class="headerlink" title="2.2.2 umbrella activities"></a>2.2.2 umbrella activities</h3><p>In genera&#x6C;<strong>, &#x20;</strong>&#x75;mbrella activities are applie&#x64;<strong>&#x20;throughout</strong> a software project and <strong>help a software team manage and control progress, quality, change, and risk.&#x20;</strong></p><ul><li><p>Software project planning,tracking and control.</p></li><li><p>Risk management.</p></li><li><p>Software quality assurance</p></li><li><p>Technical reviews</p></li><li><p>Measurement</p></li><li><p>Software configuration management.</p></li><li><p>Reusability management</p></li><li><p>Work product preparation and production</p></li></ul><h3 id="2-2-3-process-adaptation"><a href="#2-2-3-process-adaptation" class="headerlink" title="2.2.3 process adaptation"></a>2.2.3 process adaptation</h3><p>在本节的前面，我们注意到软件工程过程不是必须遵循的严格规定由软件团队独断专行。相反，它应该是敏捷的</p><p>适应性强（对问题、对项目、对团队、对环境、组织文化)。</p><p><strong>Therefore, a process adopted for one project might be significantly different than a process adopted for another project.</strong> 不同之处在于：</p><ul><li><p>Overall flow of activities, actions, and tasks and the interdependencies among them.</p></li><li><p>Degree to which actions and tasks are defined within each framework activity.</p></li><li><p>Degree to which work products are identified and required.</p></li><li><p>Manner in which quality assurance activities are applied.</p></li><li><p>Manner in which project tracking and control activities are applied.</p></li><li><p>Overall degree of detail and rigor with which the process is described.</p></li><li><p>Degree to which the customer and other stakeholders are involved with the project.</p></li><li><p>Level of autonomy given to the software team.</p></li><li><p>Degree to which team organization and roles are prescribed.</p></li></ul><h2 id="2-3-software-engineering-practice"><a href="#2-3-software-engineering-practice" class="headerlink" title="2.3 software engineering practice"></a>2.3 software engineering practice</h2><p>在2.2节中，我们介绍了一个通用的软件过程模型由一组为其建立框架的活动组成软件工程实践。一般框架活动-沟通，规划，建模，施工，以及部署和伞形活动建立了一个框架软件工程工作的体系结构。</p><p>But how does the <strong>practice of software engineering fit in</strong>？在接下来的章节中，您&#x5C06;<strong>&#x20;</strong>&#x67;ain a basic understanding of th&#x65;<strong>&#x20;generic concepts and principles&#x20;</strong>&#x74;hat apply t&#x6F;<strong>&#x20;framework activities.</strong></p><h3 id="2-3-1-The-Essence-of-Practice"><a href="#2-3-1-The-Essence-of-Practice" class="headerlink" title="2.3.1 The Essence of Practice"></a>2.3.1 <strong>The Essence of Practice</strong></h3><ol><li><p><strong>Understand the problem (communication,analysis modeling).&#x20;</strong></p></li><li><p><strong>Plan a solution ( design modeling).&#x20;</strong></p></li><li><p><strong>Carry out the plan (code generation).&#x20;</strong></p></li><li><p><strong>Examine the result for accuracy (testing and quality assurance)</strong></p></li></ol><h3 id="2-3-2-General-Principles-x20"><a href="#2-3-2-General-Principles-x20" class="headerlink" title="2.3.2 General Principles&#x20;"></a><strong>2.3.2 General Principles&#x20;</strong></h3><p>David Hooker has proposed seven principles that focus on  software engineering practice as a whole:&#x20;</p><ul><li><p><strong>The Reason It All Exists&#x20;</strong></p></li><li><p><strong>KISS (Keep It Simple, Stupid!)&#x20;</strong></p></li><li><p><strong>Maintain the Vision&#x20;</strong></p></li><li><p><strong>What You Produce, Others Will Consume&#x20;</strong></p></li><li><p><strong>Be Open to the Future&#x20;</strong></p></li><li><p><strong>Plan Ahead for Reuse&#x20;</strong></p></li><li><p><strong>Think!</strong></p></li></ul><h2 id="2-4-SOFTWARE-DEVELOPMENT-MYTHS"><a href="#2-4-SOFTWARE-DEVELOPMENT-MYTHS" class="headerlink" title="2.4 SOFTWARE DEVELOPMENT MYTHS"></a>2.4 <strong>SOFTWARE DEVELOPMENT MYTHS</strong></h2><ul><li><p><strong>Management myths</strong></p></li><li><p><strong>Customer myths.</strong></p></li><li><p><strong>Practitioner’s myths.</strong></p></li></ul><h1 id="第3章-the-software-process"><a href="#第3章-the-software-process" class="headerlink" title="第3章 the software process"></a>第3章 the software process</h1><p>3.1,3.2,3.3,3.4</p><h2 id="3-1-a-generic-process-model"><a href="#3-1-a-generic-process-model" class="headerlink" title="3.1 a generic process model"></a>3.1 a generic process model</h2><p>A generic process framework for software engineering defines five framework activities</p><ul><li><p>communication</p></li><li><p>Planning</p></li><li><p>Modeling</p></li><li><p>Construction</p></li><li><p>Deployment</p></li></ul><h2 id="3-2-define-a-framework-activity"><a href="#3-2-define-a-framework-activity" class="headerlink" title="3.2 define a framework activity"></a>3.2 define a framework activity</h2><p>the <strong>communication activity</strong> might have six distinct actions (described in Chapter 8):&#x20;</p><ul><li><p>Inception</p></li><li><p>Elicitation</p></li><li><p>Elaboration</p></li><li><p>negotiation</p></li><li><p>Specification</p></li><li><p>validation</p></li></ul><h2 id="3-3-identifying-a-task-set"><a href="#3-3-identifying-a-task-set" class="headerlink" title="3.3 identifying a task set"></a>3.3 identifying a task set</h2><h2 id="3-4-process-patterns"><a href="#3-4-process-patterns" class="headerlink" title="3.4 process patterns"></a>3.4 process patterns</h2><p>流程模式描述了在软件工程工作中遇到的与流程相关的问题，识别了遇到问题的环境，并为该问题提出一个或多个已经过验证的解决方案。</p><p>4.1（4.1.1，4.1.2，4.1.3（prototype model，spiral model））</p><h1 id="第4章-process-models"><a href="#第4章-process-models" class="headerlink" title="第4章 process models"></a>第4章 process models</h1><h2 id="4-1-PRESCRIPTIVE-PROCESS-MODELS"><a href="#4-1-PRESCRIPTIVE-PROCESS-MODELS" class="headerlink" title="4.1 PRESCRIPTIVE PROCESS MODELS"></a>4.1 <strong>PRESCRIPTIVE PROCESS MODELS</strong></h2><p>It defines the flow of all activities , actions and tasks.</p><p><strong>Each process model also prescribes a process flow (also called a work flow )</strong></p><h3 id="4-1-1-The-Waterfall-Model"><a href="#4-1-1-The-Waterfall-Model" class="headerlink" title="4.1.1 The Waterfall Model"></a>4.1.1 <strong>The Waterfall Model</strong></h3><p><img src="/2025/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-9.png"></p><p>瀑布模型，有时称为经典生命周期，提出了一种系统化、顺序化的软件开发方法，从客户需求规格开始，经过计划、建模、构建和部署，最终完成软件的支持。</p><p>实际项目很少遵循模型提出的顺序流程。尽管线性模型可以间接地适应迭代，但变更可能导致项目团队在推进过程中产生混乱。</p><p>客户通常难以明确陈述所有需求。瀑布模型要求这一点，并且难以应对许多项目初期的自然不确定性。</p><p><img src="/2025/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-8.png"></p><p>V模型是瀑布模型的一种变体，描述了质量保证动作与沟通、建模和早期构建活动之间的关系。</p><h3 id="4-1-2-Incremental-Process-Models"><a href="#4-1-2-Incremental-Process-Models" class="headerlink" title="4.1.2 Incremental Process Models"></a>4.1.2 <strong>Incremental Process Models</strong></h3><p>增量模型结合了线性和并行过程流 <strong>linear and parallel</strong>，适用于初始需求明确但整体开发范围较大的情况。它通过分阶段交付软件功能，逐步完善和扩展功能。</p><p><strong>优点</strong>：</p><ul><li><p>快速交付核心功能，用户可以在早期使用和评估。</p></li><li><p>逐步完善功能，降低风险。</p></li></ul><p><strong>缺点</strong>：</p><ul><li>需要良好的计划和协调，确保各增量的集成和一致性。</li></ul><p><img src="/2025/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-7.png"></p><h3 id="4-1-3-Evolutionary-Process-Models"><a href="#4-1-3-Evolutionary-Process-Models" class="headerlink" title="4.1.3 Evolutionary Process Models"></a>4.1.3 <strong>Evolutionary Process Models</strong></h3><p>Evolutionary models are iterative. They are characterized in a manner that enables you to develop increasingly more complete versions of the software.</p><p><strong>包含prototyping和sprial model</strong></p><p><strong>原型模型Prototyping</strong>：<br>原型模型适用于需求不明确或开发者不确定算法效率、操作系统适应性等情况。通过快速构建原型，帮助利益相关者更好地理解需求，并在迭代中逐步完善。</p><p>The prototyping paradigm assists you and other stakeholders to better understand what is to be built when requirements are fuzzy.</p><p><strong>优点</strong>：</p><ul><li><p>快速验证需求，减少不确定性。</p></li><li><p>用户和开发者都能早期看到系统雏形。</p></li></ul><p><strong>缺点</strong>：</p><ul><li><p>原型可能被误认为是最终产品，忽略整体软件质量和长期可维护性。</p></li><li><p>开发者可能为了快速实现原型而做出不合适的实现选择。</p></li></ul><p><img src="/2025/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-5.png"></p><p><img src="/2025/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-6.png"></p><p><strong>螺旋模型The Spiral Model</strong>：<br>螺旋模型结合了原型模型的迭代特性和瀑布模型的系统化控制。它通过一系列演化发布逐步开发软件，每个迭代都包括风险分析和计划调整。</p><p>The spiral model is an evolutionary software process model that couples the iterative nature of prototyping with the controlled and systematic aspects of the waterfall model.</p><p>The spiral model demands a direct consideration of technical risks at all stages of the project.</p><p><strong>优点</strong>：</p><ul><li><p>适用于大型系统开发，能够更好地理解和应对风险。</p></li><li><p>强调技术风险的直接考虑。</p></li></ul><p><strong>缺点</strong>：</p><ul><li><p>需要较高的风险评估和管理能力。</p></li><li><p>客户可能难以接受这种演化方法的可控性。</p></li></ul><p>总结</p><ul><li><p><strong>瀑布模型</strong>适用于需求明确且稳定的项目，但难以应对变更和不确定性。</p></li><li><p><strong>增量模型</strong>通过分阶段交付功能，逐步完善软件，适用于需求明确但范围较大的项目。</p></li><li><p><strong>原型模型</strong>通过快速构建原型验证需求，适用于需求不明确或不确定的情况。</p></li><li><p><strong>螺旋模型</strong>结合了迭代和系统化控制，适用于大型系统开发，强调风险管理和演化发布。</p></li></ul><h1 id="第5章-AGILE-DEVELOPMENT"><a href="#第5章-AGILE-DEVELOPMENT" class="headerlink" title="第5章 AGILE DEVELOPMENT"></a>第5章 <strong>AGILE DEVELOPMENT</strong></h1><p>5.1,5.2,5.4(重中之重，5.4.1)，5.5.1</p><p>现代商业环境催生了基于计算机的系统和软件产品，这种环境节奏快且不断变化。对于某些类别的软件和某些类型的软件项目，敏捷软件工程代表了传统软件工程的合理替代方案。它已被证明能够快速交付成功的系统。</p><p>敏捷软件工程的理念鼓励客户满意度、软件的早期增量交付、小型高度激励的项目团队、非正式方法、最少的软件工程工作产品以及整体开发的简洁性。</p><p>软件工程师和其他项目利益相关者（如经理、客户、最终用户）在敏捷团队中一起工作——这是一个自我组织并掌控自己命运的团队。敏捷团队促进所有成员之间的沟通与协作。</p><h2 id="5-1-WHAT-IS-AGILITY"><a href="#5-1-WHAT-IS-AGILITY" class="headerlink" title="5.1 WHAT IS AGILITY"></a>5.1 <strong>WHAT IS AGILITY</strong></h2><p>敏捷性已成为描述现代软件流程的流行词。每个人都在谈论敏捷。敏捷团队是一个灵活的团队，能够恰当地应对变化。变化是软件开发的核心。无论是正在构建的软件的变化、团队成员的变化、新技术的引入带来的变化，还是任何可能对他们构建的产品或创建产品的项目产生影响的变化，敏捷团队都能应对。</p><h2 id="5-2-AGILITY-AND-THE-COST-OF-CHANGE"><a href="#5-2-AGILITY-AND-THE-COST-OF-CHANGE" class="headerlink" title="5.2 AGILITY AND THE COST OF CHANGE"></a>5.2 <strong>AGILITY AND THE COST OF CHANGE</strong></h2><p>传统的软件开发经验表明，随着项目的进展，变更的成本会非线性地增加（如图5.1中的黑色实线所示）。在项目早期（如需求收集阶段），变更相对容易处理，成本较低。然而，如果项目进行到后期（如验证测试阶段），一个重要的利益相关者提出重大功能变更，变更的成本将迅速上升，因为需要修改架构设计、构建新组件、修改现有组件、设计新测试等。</p><p><img src="/2025/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-3.png"></p><p>敏捷方法的支持者认为，一个设计良好的敏捷过程可以“扁平化”变更成本曲线（如图5.1中的灰色实线所示），使软件团队能够在项目后期容纳变更，而不会显著增加成本和时间。敏捷过程通过增量交付、持续单元测试和成对编程等实践，减少了变更的成本。尽管关于变更成本曲线扁平化程度的争论仍在继续，但有证据表明，敏捷方法可以显著降低变更成本。</p><h2 id="5-4-EXTREME-PROGRAMMING-极限编程"><a href="#5-4-EXTREME-PROGRAMMING-极限编程" class="headerlink" title="5.4 EXTREME PROGRAMMING(极限编程)"></a>5.4 <strong>EXTREME PROGRAMMING(极限编程)</strong></h2><p>In order to illustrate an agile process in a bit more detail, we’ll  provide you with an overview of Extreme Programming (XP)</p><p>极限编程（XP）过程是一种敏捷软件开发方法，强调通过迭代和增量开发快速交付高质量的软件。XP 过程包括四个主要框架活动：规划、设计、编码和测试。每个活动都有一系列特定的实践和规则，旨在提高团队的效率和软件的质量。</p><h3 id="5-4-1-The-XP-Process"><a href="#5-4-1-The-XP-Process" class="headerlink" title="5.4.1 The XP Process"></a>5.4.1 <strong>The XP Process</strong></h3><p><img src="/2025/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-1.png"></p><p><strong>XP 过程的四个框架活动</strong>：</p><ol><li><p><strong>规划（Planning）</strong>：<br>XP 的规划活动从“倾听”开始，这是一个需求收集活动，帮 助技术团队成员理解软件的业务背景，并了解所需的输出和主要功能。客户编写“用户故事”（类似于用例user-case），描述软件的功能和特性，并为每个故事分配优先级。开发团队评估每个故事的成本，并与客户一起决定如何将故事分组到下一个发布（软件增量）中。</p></li><li><p><strong>设计（Design）</strong>：<br>XP 设计遵循“保持简单”（KIS）原则，使用 CRC 卡片（类-责任-协作者卡片）来组织和识别与当前软件增量相关的面向对象类。如果遇到复杂的设计问题，XP 建议立即创建该部分设计的操作原型（称为“尖峰spike解决方案”），以降低风险并验证原始估算。</p></li><li><p><strong>编码（Coding）</strong>：<br>在完成初步设计后，团队不会直接进入编码，而是为当前发布中的每个故事创建一系列单元测试unit tests。XP 强调“成对编程”，即两个开发人员在一台计算机上共同编写代码，以实时解决问题并确保代码质量。代码完成后，立即进行单元测试，并通过“持续集成”continous integration策略将代码与团队其他成员的工作集成，以避免兼容性和接口问题。</p></li><li><p><strong>测试（Testing）</strong>：<br>单元测试应使用自动化框架实现，以便轻松重复执行。XP 的验收测试由客户指定，关注系统的整体功能和特性，确保软件满足客户需求。</p></li></ol><h2 id="5-5-OTHER-AGILE-PROCESS-MODELS"><a href="#5-5-OTHER-AGILE-PROCESS-MODELS" class="headerlink" title="5.5 OTHER AGILE PROCESS MODELS"></a>5.5 <strong>OTHER AGILE PROCESS MODELS</strong></h2><h3 id="5-5-1-scrum"><a href="#5-5-1-scrum" class="headerlink" title="5.5.1 scrum"></a>5.5.1 scrum</h3><p>在这个框架中，整个开发周期包括若干个小的迭代周期，每个小的迭代周期称为一个 Sprint，每个 Sprint的建议长度 2 到 4 周。它强调跨职能团队之间的协作、迭代开发以及快速适应变化的能力。Scrum 的关键组件包括：</p><p>Sprint 中<strong>挑选的需求</strong>经过 Sprint 计划会议上的分析、讨论和估算得到一个 Sprint 的任务列表，称它为 Sprint backlog 。 在每个迭代结束时，Scrum 团队将交付潜在可交付的产品增量。</p><p><strong>scrum的角色：</strong></p><ol><li>产品负责人（Product Owner）&#x20;</li></ol><ul><li><p>确定产品的功能。&#x20;</p></li><li><p>决定发布的日期和发布内容。&#x20;</p></li><li><p>为产品的 ROI(Return On Investment)负责。&#x20;</p></li><li><p>根据市场价值确定功能优先级。&#x20;</p></li><li><p>每个 Sprint，根据需要调整功能和优先级（每个 Sprint 开始前调整）。&#x20;</p></li><li><p>接受或拒绝接受开发团队的工作成果。&#x20;</p></li><li><p>Product Owner 参与 Scrum planning。&#x20;</p></li></ul><ul><li>Scrum Master&#x20;</li></ul><p>将 Team Leader 和 Product owner 紧密地工作在一起，他可以及时地为团队成员提供帮助。&#x20;</p><ul><li><p>保证团队资源完全可被利用并且全部是高产出的。&#x20;</p></li><li><p>保证各个角色及职责的良好协作。&#x20;</p></li><li><p>解决团队开发中的障碍。&#x20;</p></li><li><p>作为团队和外部的接口，屏蔽外界对团队成员的干扰。&#x20;</p></li><li><p>保证开发过程按计划进行，组织 Daily Scrum, Sprint Review and Sprint Planning meetings。&#x20;</p></li></ul><ul><li>团队（team）&#x20;</li></ul><p>负责产品的开发，一般情况人数在 5-9 个左右&#x20;</p><ul><li><p>团队要<strong>跨职能</strong>（包括开发人员、测试人员、用户界面设计师等）&#x20;</p></li><li><p>&#x20;团队成员需要全职。（有些情况例外，比如数据库管理员）&#x20;</p></li><li><p>在项目向导范围内，尽一切努力做任何事情已确保达到 Sprint 的目标。&#x20;</p></li><li><p>高度的<strong>自组织</strong>能力。&#x20;</p></li><li><p>向 Product Owner 演示产品功能。&#x20;</p></li><li><p>团队成员构成在 sprint 内不允许变化。</p></li><li><p><strong>产品待办事项（Product Backlog）</strong>：所有需要完成的任务和功能的列表。</p></li><li><p><strong>Sprint 规划（Sprint Planning）</strong>：在每个 Sprint 开始时，团队从产品待办事项中选择任务，并制定 Sprint 目标。</p></li><li><p><strong>每日站会（Daily Stand-ups）</strong>：团队成员每天短暂会议，汇报进展、计划和遇到的问题。</p></li><li><p><strong>Sprint 审查（Sprint Reviews）</strong>：在 Sprint 结束时，团队展示完成的工作，并接受反馈。</p></li><li><p><strong>Sprint 回顾（Sprint Retrospectives）</strong>：团队反思 Sprint 中的工作流程，寻找改进机会。</p></li></ul><p>Scrum 通过短周期的迭代和持续的反馈，帮助团队快速交付高质量的软件，并能够灵活应对变化。</p><p><strong>DevOps</strong>：</p><p>DevOps 是由 Patrick DeBois 提出的，旨在将开发（Development）和运维（Operations）结合起来。DevOps 尝试将敏捷和精益开发原则应用于整个软件供应链。DevOps 的工作流程包括以下几个阶段，这些阶段循环进行，直到产品达到预期：</p><ul><li><p><strong>持续开发（Continuous Development）</strong>：软件交付物被分解并在多个 Sprint 中开发，增量交付给质量保证团队进行测试。</p></li><li><p><strong>持续测试（Continuous Testing）</strong>：使用自动化测试工具帮助团队成员同时测试多个代码增量，确保在集成之前没有缺陷。</p></li><li><p><strong>持续集成（Continuous Integration）</strong>：将具有新功能的代码添加到现有代码和运行时环境中，并检查部署后是否有错误。</p></li><li><p><strong>持续部署（Continuous Deployment）</strong>：将集成的代码部署到生产环境中，可能包括全球多个站点。</p></li><li><p><strong>持续监控（Continuous Monitoring）</strong>：运维团队成员监控生产环境中的软件性能，主动寻找潜在问题，确保软件质量。</p></li></ul><p>DevOps 通过快速响应客户需求的变化，增强了客户的体验，提高了品牌忠诚度和市场份额。它通过减少返工和转向更高价值的业务活动，为组织提供了更大的创新能力。</p><h1 id="第7章-PRINCIPLES-THAT-GUIDE-PRACTICE"><a href="#第7章-PRINCIPLES-THAT-GUIDE-PRACTICE" class="headerlink" title="第7章 PRINCIPLES THAT GUIDE PRACTICE"></a>第7章 <strong>PRINCIPLES THAT GUIDE PRACTICE</strong></h1><p>先看描述，7.1,7.2（7.2.1,7.2.2）,7.3（7.3.1~5），7.4（很重要）</p><h2 id="7-1-SOFTWARE-ENGINEERING-KNOWLEDGE"><a href="#7-1-SOFTWARE-ENGINEERING-KNOWLEDGE" class="headerlink" title="7.1 SOFTWARE ENGINEERING KNOWLEDGE"></a>7.1 <strong>SOFTWARE ENGINEERING KNOWLEDGE</strong></h2><p>你经常听到人们说，软件开发知识的半衰期为3年：今天你需要知道的知识，有一半将在3年内过时。在技术相关的知识领域，这可能是正确的。但还有另一种软件开发知识——我称之为“软件工程原则”——它的半衰期并不是3年。这些软件工程原则很可能在程序员的整个职业生涯中都适用。</p><h2 id="7-2-CORE-PRINCIPLES"><a href="#7-2-CORE-PRINCIPLES" class="headerlink" title="7.2 CORE PRINCIPLES"></a>7.2 <strong>CORE PRINCIPLES</strong></h2><p>在过程层面，核心原则为软件团队在执行框架活动framework和伞活动umbrella activities、导航过程流以及生成一系列软件工程工作产品时，奠定了哲学基础。</p><p>在实践层面，核心原则建立了一系列价值观和规则，指导你分析问题、设计解决方案、实施和测试解决方案，并最终部署软件。</p><h3 id="7-2-1-Principles-That-Guide-Process"><a href="#7-2-1-Principles-That-Guide-Process" class="headerlink" title="7.2.1 Principles That Guide Process"></a>7.2.1 <strong>Principles That Guide Process</strong></h3><p>The following set o&#x66;<strong>&#x20;core principles</strong> can be applied to the framework, and by extension, to every software process:</p><ol><li><p><strong>Principle 1: Be agile</strong>.</p></li><li><p><strong>Principle 2: Focus on quality at every step</strong>.</p></li><li><p><strong>Principle 3: Be ready to adapt</strong>.</p></li><li><p><strong>Principle 4: Build an effective team</strong>.</p></li><li><p><strong>Principle 5: Establish mechanisms for communication and coordination</strong>.</p></li><li><p><strong>Principle 6: Manage change</strong>.</p></li><li><p><strong>Principle 7: Assess risk</strong>.</p></li><li><p><strong>Principle 8: Create work products that provide value for others</strong>.</p></li></ol><h3 id="7-2-2-Principles-That-Guide-Practice"><a href="#7-2-2-Principles-That-Guide-Practice" class="headerlink" title="7.2.2 Principles That Guide Practice"></a>7.2.2 <strong>Principles That Guide Practice</strong></h3><p>软件工程实践有一个首要目标——按时交付高质量的、可操作的软件，该软件包含满足所有利益相关者需求的功能和特性。以下是软件工程实践中的核心原则：</p><ol><li><p><strong>Principle 1: Divide and conquer</strong>.</p></li><li><p><strong>Principle 2: Understand the use of abstraction</strong>.</p></li><li><p><strong>Principle 3: Strive for consistency</strong>.</p></li><li><p><strong>Principle 4: Focus on the transfer of information</strong>.</p></li><li><p><strong>Principle 5: Build software that exhibits effective modularity</strong>.</p></li><li><p><strong>Principle 6: Look for patterns</strong>.</p></li><li><p><strong>Principle 7: When possible, represent the problem and its solution from a number of different perspectives</strong>.</p></li><li><p><strong>Principle 8: Remember that someone will maintain the software</strong>.</p></li></ol><h2 id="7-3-PRINCIPLES-THAT-GUIDE-EACH-FRAMEWORK-ACTIVITY"><a href="#7-3-PRINCIPLES-THAT-GUIDE-EACH-FRAMEWORK-ACTIVITY" class="headerlink" title="7.3 PRINCIPLES THAT GUIDE EACH FRAMEWORK ACTIVITY"></a>7.3 <strong>PRINCIPLES THAT GUIDE EACH FRAMEWORK ACTIVITY</strong></h2><h3 id="7-3-1-Communication-Principles"><a href="#7-3-1-Communication-Principles" class="headerlink" title="7.3.1 Communication Principles"></a>7.3.1 <strong>Communication Principles</strong></h3><p>在客户需求被分析、建模或指定之前，必须通过沟通活动来收集这些需求。然而，从沟通到理解的道路往往充满障碍。</p><p>有效的沟通（在技术同行之间、与客户和其他利益相关者之间，以及与项目经理之间）是你在软件项目中面临的最具挑战性的活动之一。我们讨论的沟通原则主要适用于与客户的沟通，但其中许多原则同样适用于软件项目中的所有沟通形式：</p><ol><li><p><strong>Principle 1: Listen</strong>.</p></li><li><p><strong>Principle 2: Prepare before you communicate</strong>.</p></li><li><p><strong>Principle 3: Someone should facilitate the activity</strong>.</p></li><li><p><strong>Principle 4: Face-to-face communication is best</strong>.</p></li><li><p><strong>Principle 5: Take notes and document decisions</strong>.</p></li><li><p><strong>Principle 6: Strive for collaboration</strong>.</p></li><li><p><strong>Principle 7: Stay focused; modularize your discussion</strong>.</p></li><li><p><strong>Principle 8: If something is unclear, draw a picture</strong>.</p></li><li><p><strong>Principle 9</strong>:</p><ul><li><p><strong>a) Once you agree to something, move on</strong>.</p></li><li><p><strong>b) If you can’t agree to something, move on</strong>.</p></li><li><p><strong>c) If a feature or function is unclear and cannot be clarified at the moment, move on</strong>.</p></li></ul></li><li><p><strong>Principle 10: Negotiation is not a contest or a game. It works best when both parties win</strong>.</p></li></ol><h3 id="7-3-2-Planning-Principles"><a href="#7-3-2-Planning-Principles" class="headerlink" title="7.3.2 Planning Principles"></a>7.3.2 <strong>Planning Principles</strong></h3><p>计划活动包括一系列管理和技术实践，使软件团队能够定义一条通往战略目标和战术目标的路线图。在许多项目中，过度计划既耗时又无果（因为太多事情会变化），但计划不足则会导致混乱。像生活中的大多数事情一样，计划应该适度进行，为团队提供有用的指导——既不多，也不少。无论计划的严谨性如何，以下原则始终适用：</p><ol><li><p><strong>Principle 1: Understand the scope of the project</strong>.</p></li><li><p><strong>Principle 2: Involve stakeholders in the planning activity</strong>.</p></li><li><p><strong>Principle 3: Recognize that planning is iterative</strong>.</p></li><li><p><strong>Principle 4: Estimate based on what you know</strong>.</p></li><li><p><strong>Principle 5: Consider risk as you define the plan</strong>.</p></li><li><p><strong>Principle 6: Be realistic</strong>.</p></li><li><p><strong>Principle 7: Adjust granularity as you define the plan</strong>.</p></li><li><p><strong>Principle 8: Define how you intend to ensure quality</strong>.</p></li><li><p><strong>Principle 9: Describe how you intend to accommodate change</strong>.</p></li><li><p><strong>Principle 10: Track the plan frequently and make adjustments as required</strong>.</p></li></ol><p>To be most effective, everyone on the software team should participate in the planning activity. Only then will team members “sign up” to the plan.</p><h3 id="7-3-3-modeling-principle"><a href="#7-3-3-modeling-principle" class="headerlink" title="7.3.3 modeling principle"></a>7.3.3 modeling principle</h3><p>在软件工程工作中，可以创建两类模型：<strong>需求模型requirements model</strong>和<strong>设计模型design model</strong>。需求模型（除了场景模型，如用例图）通过在三个不同领域（信息域、功能域和行为域）中描述软件来表示客户需求。设计模型则代表软件的特性，帮助从业者有效地构建软件，包括架构、用户界面、组件级细节等。</p><p>在敏捷建模中，Scott Ambler 和 Ron Jeffries 定义了一组建模原则，这些原则适用于使用敏捷过程模型的人，但也适用于所有执行建模任务和活动的软件工程师：</p><ol><li><p><strong>Principle 1</strong>: The primary goal of the software team is to build software, not create models.</p></li><li><p><strong>Principle 2</strong>: Travel light—don’t create more models than you need.</p></li><li><p><strong>Principle 3</strong>: Strive to produce the simplest model that will describe the problem or the software.</p></li><li><p><strong>Principle 4</strong>: Build models in a way that makes them amenable to change.</p></li><li><p><strong>Principle 5</strong>: Be able to state an explicit purpose for each model that is created.</p></li><li><p><strong>Principle 6</strong>: Adapt the models you develop to the system at hand.</p></li><li><p><strong>Principle 7</strong>: Try to build useful models, but forget about building perfect models.</p></li><li><p><strong>Principle 8</strong>: Don’t become dogmatic about the syntax of the model. If it communicates content successfully, representation is secondary.</p></li><li><p><strong>Principle 9</strong>: If your instincts tell you a model isn’t right even though it seems okay on paper, you probably have reason to be concerned.</p></li><li><p><strong>Principle 10</strong>: Get feedback as soon as you can.</p></li></ol><h4 id="Requirements-Modeling-Principles"><a href="#Requirements-Modeling-Principles" class="headerlink" title="Requirements Modeling Principles:"></a><strong>Requirements Modeling Principles</strong>:</h4><ol><li><p><strong>Principle 1</strong>: The information domain of a problem must be represented and understood.</p></li><li><p><strong>Principle 2</strong>: The functions that the software performs must be defined.</p></li><li><p><strong>Principle 3</strong>: The behavior of the software (as a consequence of external events) must be represented.</p></li><li><p><strong>Principle 4</strong>: The models that depict information, function, and behavior must be partitioned in a manner that uncovers detail in a layered (or hierarchical) fashion.</p></li><li><p><strong>Principle 5</strong>: The analysis task should move from essential information toward implementation detail.</p></li></ol><blockquote><ol><li><p><strong>原则1</strong>：必须表示并理解问题的信息域。</p></li><li><p><strong>原则2</strong>：必须定义软件执行的功能。</p></li><li><p><strong>原则3</strong>：必须表示软件的行为（作为外部事件的结果）。</p></li><li><p><strong>原则4</strong>：描述信息、功能和行为的模型必须以分层（或层次化）的方式划分，以揭示细节。</p></li><li><p><strong>原则5</strong>：分析任务应从基本信息向实现细节推进。</p></li></ol></blockquote><h4 id="Design-Modeling-Principles"><a href="#Design-Modeling-Principles" class="headerlink" title="Design Modeling Principles:"></a><strong>Design Modeling Principles</strong>:</h4><ol><li><p><strong>Principle 1</strong>: Design should be traceable to the requirements model.</p></li><li><p><strong>Principle 2</strong>: Always consider the architecture of the system to be built.</p></li><li><p><strong>Principle 3</strong>: Design of data is as important as design of processing functions.</p></li><li><p><strong>Principle 4</strong>: Interfaces (both internal and external) must be designed with care.</p></li><li><p><strong>Principle 5</strong>: User interface design should be tuned to the needs of the end user. However, in every case, it should stress ease of use.</p></li><li><p><strong>Principle 6</strong>: Component-level design should be functionally independent.</p></li><li><p><strong>Principle 7</strong>: Components should be loosely coupled to one another and to the external environment.</p></li><li><p><strong>Principle 8</strong>: Design representations (models) should be easily understandable.</p></li><li><p><strong>Principle 9</strong>: The design should be developed iteratively.</p></li><li><p><strong>Principle 10</strong>: Creation of a design model does not preclude an agile approach.</p></li></ol><blockquote><ol><li><p><strong>原则1</strong>：设计应可追溯到需求模型。</p></li><li><p><strong>原则2</strong>：始终考虑要构建的系统架构。</p></li><li><p><strong>原则3</strong>：数据设计与处理功能的设计同样重要。</p></li><li><p><strong>原则4</strong>：接口（包括内部和外部）必须精心设计。</p></li><li><p><strong>原则5</strong>：用户界面设计应根据最终用户的需求进行调整，但在任何情况下都应强调易用性。</p></li><li><p><strong>原则6</strong>：组件级设计应具有功能独立性。</p></li><li><p><strong>原则7</strong>：组件之间以及与外部环境之间应松散耦合。</p></li><li><p><strong>原则8</strong>：设计表示（模型）应易于理解。</p></li><li><p><strong>原则9</strong>：设计应迭代开发。</p></li><li><p><strong>原则10</strong>：创建设计模型并不排除敏捷方法。</p></li></ol></blockquote><h3 id="7-3-4-Construction-principle"><a href="#7-3-4-Construction-principle" class="headerlink" title="7.3.4 Construction principle"></a>7.3.4 Construction principle</h3><h3 id="7-3-5-Deployment-principle"><a href="#7-3-5-Deployment-principle" class="headerlink" title="7.3.5 Deployment principle"></a>7.3.5 Deployment principle</h3><h2 id="7-4-WORK-PRACTICES"><a href="#7-4-WORK-PRACTICES" class="headerlink" title="7.4 WORK PRACTICES"></a>7.4 <strong>WORK PRACTICES</strong></h2><p>软件工程中的人为因素与技术领域同样重要。因此，研究成功软件工程师的共同特质和工作习惯是很有意义的。除了基本的特质basic traits 和工作习惯外，Isklod 提出了10个超越编程语言和特定技术的概念（transcend programming languages and specific technologies）。其中一些概念是理解软件工程在软件过程中作用的前提 （prerequisite） 知识</p><ol><li><p><strong>Interfaces</strong>.</p></li><li><p><strong>Conventions and templates</strong>.</p></li><li><p><strong>Layering</strong>.</p></li><li><p><strong>Algorithmic complexity</strong>.</p></li><li><p><strong>Hashing</strong>.</p></li><li><p><strong>Caching</strong>.</p></li><li><p><strong>Concurrency</strong>.</p></li><li><p><strong>Cloud computing</strong>.</p></li><li><p><strong>Relational databases</strong>.</p></li></ol><h1 id="第8章-UNDERSTANDING-REQUIREMENTS"><a href="#第8章-UNDERSTANDING-REQUIREMENTS" class="headerlink" title="第8章 UNDERSTANDING REQUIREMENTS"></a>第8章 <strong>UNDERSTANDING REQUIREMENTS</strong></h1><p>8.1，8.2.1~8.2.5(标题含义弄懂)，8.5（8.5.1），8.6，8.8</p><h2 id="8-1-REQUIREMENTS-ENGINEERING"><a href="#8-1-REQUIREMENTS-ENGINEERING" class="headerlink" title="8.1 REQUIREMENTS ENGINEERING"></a>8.1 <strong>REQUIREMENTS ENGINEERING</strong></h2><p>导致对需求理解的一系列广泛任务和技术被称为<strong>需求工程</strong>。从软件过程的角度来看，需求工程是一个主要的软件工程活动，始于沟通活动communication activity，并延续到需求分析建模活动requirement analysis modeling。它必须根据过程、项目、产品和工作人员的需求进行调整。</p><p>需求工程包括沟通活动和需求分析建模活动，可以理解为七个独立的任务：<strong>初始（Inception）</strong>、<strong>获取（Elicitation）</strong>、<strong>细化（Elaboration）</strong>、<strong>协商（Negotiation）</strong>、<strong>规格说明（Specification）</strong>、<strong>验证（Validation）和管理（Management）</strong>。需要注意的是，这些任务中的一些是并行进行的，并且所有任务都根据项目的需求进行调整。</p><p><strong>1. 初始（Inception）</strong></p><p>在项目初始阶段，团队建立对问题、利益相关者和解决方案的基本理解。这个阶段的主要目标是确定项目的范围、目标和可行性，并确保所有利益相关者对项目的初步方向达成一致。</p><p><strong>关键活动</strong>：</p><ul><li><p>识别问题。</p></li><li><p>确定利益相关者。</p></li><li><p>初步沟通和协作。</p></li></ul><p><strong>2. 启发（Elicitation）</strong></p><p>需求启发是通过与利益相关者的互动，收集他们的需求和期望。这个阶段的目标是明确业务目标，并确保所有利益相关者的需求被充分理解和记录。</p><p><strong>关键活动</strong>：<strong>establish business goals</strong></p><ul><li><p>与利益相关者沟通，获取业务目标。</p></li><li><p>建立需求优先级机制。</p></li><li><p>创建初步的系统架构设计。</p></li></ul><p><strong>常见问题</strong>：</p><ul><li><p><strong>范围问题</strong>：需求范围不明确。</p></li><li><p><strong>理解问题</strong>：利益相关者和开发团队之间的理解不一致。</p></li><li><p><strong>易变性问题</strong>：需求在项目过程中频繁变化。</p></li></ul><p><strong>3. 细化（Elaboration）</strong></p><p>在细化阶段，团队通过创建和细化用户场景，开发详细的需求模型。这个阶段的目标是明确系统的功能、行为和信息结构。</p><p><strong>关键活动</strong>：<strong>developing a refined requirements model</strong></p><ul><li><p>创建用户场景，描述用户与系统的交互。</p></li><li><p>提取分析类（Analysis Classes），定义类的属性和服务。</p></li><li><p>识别类之间的关系和协作，生成补充图表。</p></li></ul><p><strong>4. 协商（Negotiation）</strong></p><p>需求协商是解决利益相关者之间需求冲突的过程。通过协商，团队确保所有利益相关者的需求得到平衡，并达成一致。</p><p><strong>关键活动</strong>：<strong>rank requirements and then discuss conflicts in priority</strong></p><ul><li><p>让利益相关者对需求进行优先级排序。</p></li><li><p>评估每个需求的成本和风险。</p></li><li><p>通过迭代方法消除、合并或修改需求，确保各方满意。</p></li></ul><p><strong>5. 规格说明（Specification）</strong></p><p>规格说明是将需求以明确的形式表达出来，可以是文档、图形模型、数学模型、使用场景或原型的组合。这个阶段的目标是确保所有需求被清晰地记录和传达。</p><p><strong>关键活动</strong>：</p><ul><li><p>编写需求文档。</p></li><li><p>创建图形模型或原型。</p></li><li><p>确保规格说明的完整性和一致性。</p></li></ul><p><strong>6. 验证（Validation）</strong></p><p>需求验证是评估需求工程的工作产品，确保其质量和一致性。通过验证，团队确保所有需求被正确理解、记录，并且符合项目的标准和目标。</p><p><strong>关键活动</strong>：</p><ul><li><p>进行技术评审<strong>technical review</strong>，检查需求规格说明中的错误、遗漏和不一致性。</p></li><li><p>确保所有需求明确、无歧义且可测试。</p></li><li><p>确保需求模型符合系统的信息、功能和行为。</p></li></ul><p><strong>7. 需求管理（Requirement Management）</strong></p><p>需求管理是在整个项目生命周期中识别、控制和跟踪需求及其变更的过程。由于需求在项目过程中可能会发生变化，需求管理确保这些变化被有效处理。</p><p><strong>关键活动</strong>：</p><ul><li><p>识别和跟踪需求及其变更。</p></li><li><p>控制需求变更的影响。</p></li><li><p>使用软件配置管理（SCM）技术管理需求。</p></li></ul><h2 id="8-2-ESTABLISHING-THE-GROUNDWORK-Inception"><a href="#8-2-ESTABLISHING-THE-GROUNDWORK-Inception" class="headerlink" title="8.2 ESTABLISHING THE GROUNDWORK(Inception)"></a>8.2 <strong>ESTABLISHING THE GROUNDWORK(Inception)</strong></h2><h3 id="8-2-1-Identifying-Stakeholders"><a href="#8-2-1-Identifying-Stakeholders" class="headerlink" title="8.2.1 Identifying Stakeholders"></a>8.2.1 <strong>Identifying Stakeholders</strong></h3><h3 id="8-2-2-Recognizing-Multiple-Viewpoints-x20"><a href="#8-2-2-Recognizing-Multiple-Viewpoints-x20" class="headerlink" title="8.2.2 Recognizing Multiple Viewpoints&#x20;"></a><strong>8.2.2 Recognizing Multiple Viewpoints&#x20;</strong></h3><h3 id="8-2-3-Working-toward-Collaboration-x20"><a href="#8-2-3-Working-toward-Collaboration-x20" class="headerlink" title="8.2.3 Working toward Collaboration&#x20;"></a><strong>8.2.3 Working toward Collaboration&#x20;</strong></h3><h3 id="8-2-4-Asking-the-First-Questions-x20"><a href="#8-2-4-Asking-the-First-Questions-x20" class="headerlink" title="8.2.4 Asking the First Questions&#x20;"></a><strong>8.2.4 Asking the First Questions&#x20;</strong></h3><h3 id="8-2-5-Nonfunctional-Requirements"><a href="#8-2-5-Nonfunctional-Requirements" class="headerlink" title="8.2.5 Nonfunctional Requirements"></a><strong>8.2.5 Nonfunctional Requirements</strong></h3><p>解释如下:</p><p><strong>奠定基础（Inception）</strong></p><p>在项目初始阶段，团队需要奠定基础，确保对问题、利益相关者和解决方案有清晰的理解。这个阶段的目标是为后续的需求工程活动提供坚实的基础。</p><ol><li><strong>识别利益相关者（Identifying Stakeholders）</strong></li></ol><p>利益相关者是指与系统相关的所有个人或组织，包括客户、用户、开发团队、管理层等。识别利益相关者是需求工程的第一步，确保所有相关方的需求和期望被考虑。</p><p><strong>关键活动</strong>：</p><ul><li><p>列出所有可能的利益相关者。</p></li><li><p>确定每个利益相关者的角色和职责。</p></li><li><p>确保利益相关者参与需求定义和确认。</p></li></ul><ul><li><strong>识别多重视角（Recognizing Multiple Viewpoints）</strong></li></ul><p>不同的利益相关者可能对系统有不同的需求和期望。需求工程师需要识别并协调这些不同的视角，确保所有需求被充分考虑。</p><p><strong>关键活动</strong>：</p><ul><li><p>识别每个利益相关者的需求和期望。</p></li><li><p>分析不同需求之间的冲突和一致性。</p></li><li><p>通过沟通和协商，协调多重视角。</p></li></ul><ul><li><strong>促进协作（Working toward Collaboration）</strong></li></ul><p>有效的沟通和协作是需求工程成功的关键。通过促进利益相关者之间的协作，团队可以确保需求被正确理解并达成一致。</p><p><strong>关键活动</strong>：</p><ul><li><p>建立沟通渠道，确保利益相关者能够有效交流。</p></li><li><p>组织会议或工作坊，促进利益相关者之间的协作。</p></li><li><p>使用协作工具（如共享文档、原型等）帮助利益相关者表达需求。</p></li></ul><ul><li><strong>提出初步问题（Asking the First Questions）</strong></li></ul><p>在项目初期，提出一些关键问题，帮助团队理解项目的范围、目标和约束。这些问题为后续的需求获取和分析提供方向。</p><p><strong>关键问题</strong>：</p><ul><li><p>项目的业务目标是什么？</p></li><li><p>系统的主要功能是什么？</p></li><li><p>项目的技术约束和限制有哪些？</p></li><li><p>项目的预算和时间表如何？</p></li></ul><ul><li><strong>非功能性需求（Nonfunctional Requirements）</strong></li></ul><p>非功能性需求描述了系统的质量属性，如性能、安全性、可用性等。这些需求通常与功能性需求分开列出，但对系统的成功同样重要。</p><p><strong>常见的非功能性需求</strong>：</p><ul><li><p><strong>性能</strong>：系统的响应时间、吞吐量等。</p></li><li><p><strong>安全性</strong>：系统的数据保护、访问控制等。</p></li><li><p><strong>可用性</strong>：系统的易用性、用户界面设计等。</p></li><li><p><strong>可维护性</strong>：系统的可扩展性、可修改性等。</p></li><li><p><strong>可靠性</strong>：系统的容错能力、恢复能力等。</p></li></ul><p><strong>关键活动</strong>：</p><ul><li><p>与利益相关者讨论并记录非功能性需求。</p></li><li><p>确保非功能性需求在需求规格说明中明确列出。</p></li><li><p>在系统设计和实现中考虑非功能性需求。</p></li></ul><h2 id="8-5-BUILDING-THE-ANALYSIS-MODEL-elaboration"><a href="#8-5-BUILDING-THE-ANALYSIS-MODEL-elaboration" class="headerlink" title="8.5 BUILDING THE ANALYSIS MODEL(elaboration)"></a>8.5 <strong>BUILDING THE ANALYSIS MODEL(elaboration)</strong></h2><h3 id="8-5-1-Elements-of-the-Analysis-Model"><a href="#8-5-1-Elements-of-the-Analysis-Model" class="headerlink" title="8.5.1 Elements of the Analysis Model"></a>8.5.1 <strong>Elements of the Analysis Model</strong></h3><p>分析模型的目的是描述基于计算机系统的信息域、功能域和行为域。为了全面理解系统的需求，分析模型通常包括以下三类元素：</p><ol><li><strong>功能元素（Function Elements）</strong></li></ol><p>功能元素描述系统的功能，即系统需要执行的任务或操作。功能元素通常通过活动图（Activity Diagram）来表示，活动图展示了系统功能的流程和逻辑。</p><p><strong>关键点</strong>：</p><ul><li><p>活动图描述了系统功能的业务流程。</p></li><li><p>每个活动代表系统中的一个功能或任务。</p></li><li><p>活动图帮助团队理解系统的功能需求，并识别潜在的遗漏或不一致性。</p></li></ul><p><strong>示例</strong>：<br>在家庭安全系统中，活动图可以描述用户如何通过系统设置警报、监控传感器和接收通知。</p><ul><li><strong>基于类的元素（Class-based Elements）</strong></li></ul><p>基于类的元素描述系统的信息或数据结构，通常通过类图（Class Diagram）来表示。类图展示了系统中的类、类的属性、方法以及类之间的关系。</p><p><strong>关键点</strong>：</p><ul><li><p>类图描述了系统的信息域，即系统中的数据结构和关系。</p></li><li><p>每个类代表系统中的一个实体或概念。</p></li><li><p>类的属性描述了实体的特征，类的方法描述了实体的行为。</p></li><li><p>类之间的关系（如继承、关联、聚合等）描述了实体之间的交互。</p></li></ul><p><strong>示例</strong>：<br>在家庭安全系统中，类图可以包括“传感器”、“用户”、“警报”等类，描述这些类之间的关系和交互。</p><ul><li><strong>行为元素（Behavioral Elements）</strong></li></ul><p>行为元素描述系统的行为，即系统如何响应外部事件或用户操作。行为元素通常通过状态图（State Diagram）和时序图（Sequence Diagram）来表示。</p><p><strong>状态图（State Diagram）</strong>：</p><ul><li><p>状态图描述了系统或系统组件的状态变化。</p></li><li><p>每个状态代表系统的一个行为模式，状态之间的转换由事件触发。</p></li><li><p>状态图帮助团队理解系统的动态行为，并识别潜在的状态冲突或不一致性。</p></li></ul><p><strong>时序图（Sequence Diagram）</strong>：</p><ul><li><p>顺序图描述了系统中对象之间的交互顺序。</p></li><li><p>顺序图展示了对象如何通过消息传递来执行特定的功能。</p></li><li><p>顺序图帮助团队理解系统的交互逻辑，并识别潜在的交互问题。</p></li></ul><p><strong>示例</strong>：<br>在家庭安全系统中，状态图可以描述系统的“待机”、“警报”、“关闭”等状态及其转换；顺序图可以描述用户如何通过系统设置警报、系统如何响应传感器事件等。</p><h2 id="8-6-Negotiating-Requirements"><a href="#8-6-Negotiating-Requirements" class="headerlink" title="8.6 Negotiating Requirements"></a>8.6 <strong>Negotiating Requirements</strong></h2><p><strong>Negotiating Requirements</strong>是解决利益相关者之间需求冲突的过程。由于不同的利益相关者可能对系统有不同的需求和期望，需求协商的目标是通过协商达成一致，确保所有利益相关者的需求得到平衡。Boehm 提出了一组需求协商活动，帮助团队有效地处理需求冲突。</p><ol><li><strong>识别关键利益相关者（Identification of the System or Subsystem’s Key Stakeholders）</strong></li></ol><p>在需求协商过程中，首先需要识别系统的关键利益相关者。这些利益相关者包括客户、用户、开发团队、管理层等，他们对系统的需求和期望可能不同。</p><p><strong>关键活动</strong>：</p><ul><li><p>列出所有与系统相关的利益相关者。</p></li><li><p>确定每个利益相关者的角色和职责。</p></li><li><p>确保关键利益相关者参与需求协商过程。</p></li></ul><ul><li><strong>确定利益相关者的“赢条件”（Determination of the Stakeholders’ “Win Conditions”）</strong></li></ul><p>每个利益相关者都有其“赢条件”，即他们对系统的期望和目标。需求工程师需要与利益相关者沟通，明确他们的“赢条件”。</p><p><strong>关键活动</strong>：</p><ul><li><p>与每个利益相关者讨论他们的需求和期望。</p></li><li><p>记录每个利益相关者的“赢条件”。</p></li><li><p>确保所有“赢条件”被明确表达和理解。</p></li></ul><ul><li><strong>协商利益相关者的“赢条件”（Negotiation of the Stakeholders’ Win Conditions to Reconcile Them into a Set of Win-Win Conditions）</strong></li></ul><p>在明确所有利益相关者的“赢条件”后，需求工程师需要通过协商，将这些“赢条件”协调为对所有相关方（包括软件团队）都有利的“双赢条件”。协商的目标是确保每个利益相关者的核心需求得到满足，同时避免需求冲突。</p><p><strong>关键活动</strong>：</p><ul><li><p>让利益相关者对需求进行优先级排序。</p></li><li><p>评估每个需求的成本、风险和技术可行性。</p></li><li><p>通过迭代方法消除、合并或修改需求，确保各方达成一致。</p></li><li><p>确保最终的需求集对所有利益相关者都是可接受的。</p></li></ul><h2 id="8-8-VALIDATING-REQUIREMENTS-validation"><a href="#8-8-VALIDATING-REQUIREMENTS-validation" class="headerlink" title="8.8 VALIDATING REQUIREMENTS(validation)"></a>8.8 <strong>VALIDATING REQUIREMENTS(validation)</strong></h2><p>validation是评估需求工程的工作产品，确保其质量和一致性的过程。通过需求验证，团队确保所有需求被正确理解、记录，并且符合项目的标准和目标。需求验证通常在需求规格说明完成后进行，以确保需求模型的完整性和准确性。</p><p><strong>需求验证的关键问题</strong></p><p>在验证需求时，团队需要回答以下关键问题，以确保需求模型的质量：</p><ol><li><p><strong>一致性（Consistency）</strong>：</p><ul><li><p>每个需求是否与系统的总体目标一致？</p></li><li><p>是否存在需求之间的冲突或不一致？</p></li></ul></li><li><p><strong>抽象层次（Level of Abstraction）</strong>：</p><ul><li><p>所有需求是否在适当的抽象层次上指定？</p></li><li><p>是否存在过于技术化或过于抽象的需求？</p></li></ul></li><li><p><strong>必要性（Necessity）</strong>：</p><ul><li><p>每个需求是否真正必要，还是只是一个附加功能？</p></li><li><p>是否存在可以省略的非核心需求？</p></li></ul></li><li><p><strong>明确性（Clarity）</strong>：</p><ul><li><p>每个需求是否明确且无歧义？</p></li><li><p>是否存在模糊或难以理解的需求？</p></li></ul></li><li><p><strong>可追溯性（Attribution）</strong>：</p><ul><li><p>每个需求是否有来源（即由谁提出）？</p></li><li><p>是否记录了每个需求的提出者和背景？</p></li></ul></li><li><p><strong>可实现性（Achievability）</strong>：</p><ul><li><p>每个需求在技术环境中是否可实现？</p></li><li><p>是否存在技术上不可行或不切实际的需求？</p></li></ul></li><li><p><strong>可测试性（Testability）</strong>：</p><ul><li><p>每个需求在实现后是否可测试？</p></li><li><p>是否存在难以验证或测试的需求？</p></li></ul></li><li><p><strong>完整性（Completeness）</strong>：</p><ul><li><p>需求模型是否正确反映了系统的信息、功能和行为？</p></li><li><p>是否存在遗漏的需求或功能？</p></li></ul></li><li><p><strong>分区性（Partitioning）</strong>：</p><ul><li><p>需求模型是否以逐步揭示更多细节的方式划分？</p></li><li><p>是否存在过于复杂或难以理解的需求分区？</p></li></ul></li><li><p><strong>模式使用（Pattern Usage）</strong>：</p><ul><li><p>是否使用了需求模式来简化需求模型？</p></li><li><p>所有模式是否经过验证并与客户需求一致？</p></li></ul></li></ol><h1 id="第9章-REQUIREMENTS-MODELING-SCENARIO-BASED-METHODS"><a href="#第9章-REQUIREMENTS-MODELING-SCENARIO-BASED-METHODS" class="headerlink" title="第9章 REQUIREMENTS MODELING:SCENARIO BASED METHODS"></a>第9章 <strong>REQUIREMENTS MODELING:SCENARIO BASED METHODS</strong></h1><p>9.1(9.1.1~9.1.4),9.3(9.3.1~9.3.2很重要)</p><h2 id="9-1-REQUIREMENTS-ANALYSIS"><a href="#9-1-REQUIREMENTS-ANALYSIS" class="headerlink" title="9.1 REQUIREMENTS ANALYSIS"></a>9.1 <strong>REQUIREMENTS ANALYSIS</strong></h2><p>需求分析的目标是通过建模技术，帮助团队理解系统的需求，并为后续的设计和实现提供基础。需求分析的结果通常包括以下几种模型：</p><ol><li><p><strong>基于场景的模型（Scenario-based Models）</strong>：从系统“参与者”的角度描述需求。</p></li><li><p><strong>类模型或数据模型（Class-oriented Models or Data Models）</strong>：描述问题的信息域，表示面向对象的类及其属性和操作。</p></li><li><p><strong>行为模型（Behavioral Models）</strong>：描述软件如何响应外部事件。</p></li><li><p><strong>功能模型或流模型（Function Models or Flow-oriented Models）</strong>：表示系统的功能元素及其如何转换数据。</p></li></ol><h3 id="9-1-1-Overall-Objectives-and-Philosophy（总体目标和理念）"><a href="#9-1-1-Overall-Objectives-and-Philosophy（总体目标和理念）" class="headerlink" title="9.1.1 Overall Objectives and Philosophy（总体目标和理念）"></a>9.1.1 <strong>Overall Objectives and Philosophy（总体目标和理念）</strong></h3><p>需求模型必须实现三个主要目标：</p><ol><li><p><strong>描述客户的需求</strong>。</p></li><li><p><strong>为软件设计奠定基础</strong>。</p></li><li><p><strong>定义一组可以在软件构建后验证的需求</strong>。</p></li></ol><p>需求模型是系统描述和设计模型之间的桥梁，分析和设计任务之间的界限并不总是清晰的，<strong>分析过程中可能会涉及一些设计，设计过程中也可能会进行一些分析。</strong></p><h3 id="9-1-2-Analysis-Rules-of-Thumb-分析经验法则"><a href="#9-1-2-Analysis-Rules-of-Thumb-分析经验法则" class="headerlink" title="9.1.2 Analysis Rules of Thumb(分析经验法则)"></a>9.1.2 <strong>Analysis Rules of Thumb(分析经验法则)</strong></h3><p>Arlow 和 Neustadt 提出了一些在创建分析模型时应遵循的经验法则：</p><ol><li><p><strong>模型应关注问题或业务域中可见的需求</strong>，抽象层次应相对较高。</p></li><li><p><strong>需求模型的每个元素都应增加对软件需求的整体理解</strong>，并提供对信息域、功能和行为的洞察。</p></li><li><p><strong>延迟考虑基础设施和其他非功能性模型，直到设计阶段</strong>。</p></li><li><p><strong>尽量减少系统中的耦合</strong>。</p></li><li><p><strong>确保需求模型为所有利益相关者提供价值</strong>。</p></li><li><p><strong>保持模型尽可能简单</strong>。</p></li></ol><h3 id="9-1-3-Domain-Analysis"><a href="#9-1-3-Domain-Analysis" class="headerlink" title="9.1.3 Domain Analysis"></a>9.1.3 <strong>Domain Analysis</strong></h3><p><strong>Domain Analysis&#x20;</strong>&#x7684;目标是找到或创建广泛适用的<strong>分析类</strong>和&#x2F;或<strong>分析模式</strong>，以便它们可以被重用。领域分析是软件过程中的一项持续性活动，不局限于某一个软件项目。</p><p><strong>领域分析师的角色是发现和定义分析模式、分析类以及相关信息，供许多从事类似应用的人使用。</strong></p><p><img src="/2025/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image.png"></p><h3 id="9-1-4-Requirements-Modeling-Approaches"><a href="#9-1-4-Requirements-Modeling-Approaches" class="headerlink" title="9.1.4 Requirements Modeling Approaches"></a>9.1.4 <strong>Requirements Modeling Approaches</strong></h3><ol><li><strong>结构化分析（Structured Analysis）</strong></li></ol><p>结构化分析是一种传统的需求建模方法，它将数据和转换数据的过程视为独立的实体。结构化分析的核心思想是通过数据流图（Data Flow Diagrams, DFD）和实体关系图（Entity-Relationship Diagrams, ERD）等工具，描述系统中的数据流动和处理过程。</p><p><strong>特点</strong>：</p><ul><li><p><strong>数据与过程分离</strong>：数据流图描述数据在系统中的流动，而实体关系图描述数据的结构。</p></li><li><p><strong>层次化分解</strong>：通过层次化的数据流图，逐步分解系统的功能。</p></li><li><p><strong>较少使用</strong>：随着面向对象方法的普及，结构化分析的使用逐渐减少。</p></li></ul><p><strong>适用场景</strong>：</p><ul><li><p>适用于数据密集型系统，如数据库管理系统。</p></li><li><p>适合需要明确数据流动和处理逻辑的项目。</p></li></ul><ul><li><strong>&#x20;面向对象分析（Object-Oriented Analysis）</strong></li></ul><p>面向对象分析是一种现代的需求建模方法，它关注类的定义以及它们如何协作以实现客户需求。面向对象分析的核心思想是通过类图（Class Diagrams）、用例图（Use Case Diagrams）等工具，描述系统中的对象及其交互。</p><p><strong>特点</strong>：</p><ul><li><p><strong>类与对象</strong>：类图描述系统中的类及其属性、方法和关系。</p></li><li><p><strong>用例驱动</strong>：用例图描述系统与外部参与者之间的交互。</p></li><li><p><strong>行为建模</strong>：通过状态图（State Diagrams）和顺序图（Sequence Diagrams）描述系统的行为。</p></li><li><p><strong>广泛使用</strong>：UML（统一建模语言）和统一过程（Unified Process）主要采用面向对象分析。</p></li></ul><p><strong>适用场景</strong>：</p><ul><li><p>适用于复杂的、交互密集的系统，如现代软件应用。</p></li><li><p>适合需要高复用性和扩展性的项目。</p></li></ul><p><img src="/2025/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-2.png"></p><p>需求模型的每个元素（如上图所示）从不同的角度呈现问题。<strong>基于场景的元素</strong>描述了用户如何与系统交互，以及在使用软件时发生的具体活动序列。<strong>基于类的元素</strong>建模了系统将操作的对象、应用于这些对象的操作以实现操作、对象之间的关系（有些是层次化的），以及定义的类之间的协作。<strong>行为元素</strong>描述了外部事件如何改变系统或类内部的状态。最后，<strong>功能建模</strong>将系统表示为信息转换，描述了数据对象在流经各种系统功能时如何被转换。</p><h2 id="9-3-UML-MODELS-THAT-SUPPLEMENT-THE-USE-CASE"><a href="#9-3-UML-MODELS-THAT-SUPPLEMENT-THE-USE-CASE" class="headerlink" title="9.3 UML MODELS THAT SUPPLEMENT THE USE CASE"></a>9.3 <strong>UML MODELS THAT SUPPLEMENT THE USE CASE</strong></h2><h3 id="9-3-1-Developing-an-Activity-Diagram"><a href="#9-3-1-Developing-an-Activity-Diagram" class="headerlink" title="9.3.1 Developing an Activity Diagram"></a>9.3.1 <strong>Developing an Activity Diagram</strong></h3><h3 id="9-3-2-Swimlane-Diagrams"><a href="#9-3-2-Swimlane-Diagrams" class="headerlink" title="9.3.2 Swimlane Diagrams"></a>9.3.2 <strong>Swimlane Diagrams</strong></h3><h1 id="第10章-REQUIREMENTS-MODELING-CLASS-BASED-METHODS"><a href="#第10章-REQUIREMENTS-MODELING-CLASS-BASED-METHODS" class="headerlink" title="第10章 REQUIREMENTS MODELING: CLASS-BASED METHODS"></a>第10章 <strong>REQUIREMENTS MODELING: CLASS-BASED METHODS</strong></h1><p>10.1,10.2,10.3,10.4,10.5,10.6</p><h3 id="10-1-识别分析类（Identifying-Analysis-Classes）"><a href="#10-1-识别分析类（Identifying-Analysis-Classes）" class="headerlink" title="10.1 识别分析类（Identifying Analysis Classes）"></a><strong>10.1 识别分析类（Identifying Analysis Classes）</strong></h3><p>分析类是需求建模的基础，通常通过以下步骤识别：</p><ol><li><p><strong>从用例中提取名词</strong>：通过分析用例场景，提取名词或名词短语作为潜在的类。</p></li><li><p><strong>分类潜在类</strong>：将潜在类分为以下几类：</p><ul><li><p><strong>外部实体</strong>（如其他系统、设备、人）。</p></li><li><p><strong>事物</strong>（如报告、显示、信号）。</p></li><li><p><strong>事件或发生</strong>（如属性转移、机器人动作完成）。</p></li><li><p><strong>角色</strong>（如经理、工程师、销售人员）。</p></li><li><p><strong>组织单位</strong>（如部门、团队）。</p></li><li><p><strong>地点</strong>（如制造车间、装货码头）。</p></li><li><p><strong>结构</strong>（如传感器、车辆、计算机）。</p></li></ul></li><li><p><strong>筛选类</strong>：使用Coad和Yourdon提出的六个特征来筛选潜在类：</p><ul><li><p><strong>保留信息</strong>：类是否需要存储信息以支持系统功能。</p></li><li><p><strong>所需服务</strong>：类是否有可识别的操作来改变其属性。</p></li><li><p><strong>多个属性</strong>：类是否具有多个属性。</p></li><li><p><strong>共同属性</strong>：类是否有一组适用于所有实例的属性。</p></li><li><p><strong>共同操作</strong>：类是否有一组适用于所有实例的操作。</p></li><li><p><strong>基本需求</strong>：类是否是问题空间中的外部实体，对系统操作至关重要。</p></li></ul></li></ol><h3 id="10-2-指定属性（Specifying-Attributes）"><a href="#10-2-指定属性（Specifying-Attributes）" class="headerlink" title="10.2 指定属性（Specifying Attributes）"></a><strong>10.2 指定属性（Specifying Attributes）</strong></h3><p>属性是类的特征，用于描述类的状态。指定属性的步骤如下：</p><ol><li><p><strong>从用例中提取属性</strong>：分析用例，选择属于类的“事物”。</p></li><li><p><strong>定义复合数据项</strong>：将相关的数据项组合成复合属性。例如，系统的“识别信息”可以包括系统ID、验证电话号码和系统状态。</p></li></ol><h3 id="10-3-定义操作（Defining-Operations）"><a href="#10-3-定义操作（Defining-Operations）" class="headerlink" title="10.3 定义操作（Defining Operations）"></a><strong>10.3 定义操作（Defining Operations）</strong></h3><p>操作定义了类的行为，通常分为四类：</p><ol><li><p><strong>数据操作</strong>：如添加、删除、格式化数据。</p></li><li><p><strong>计算操作</strong>：执行某种计算。</p></li><li><p><strong>查询操作</strong>：查询对象的状态。</p></li><li><p><strong>监控操作</strong>：监控对象以检测控制事件的发生。<br>通过分析用例中的动词，可以识别类的操作。例如，“传感器被分配编号和类型”表明<code>Sensor</code>类需要<code>assign()</code>操作。</p></li></ol><h3 id="10-4-类-责任-协作者模型（CRC-Modeling）"><a href="#10-4-类-责任-协作者模型（CRC-Modeling）" class="headerlink" title="10.4 类-责任-协作者模型（CRC Modeling）"></a><strong>10.4 类-责任-协作者模型（CRC Modeling）</strong></h3><p>CRC模型通过索引卡的形式表示类及其责任和协作者：</p><ol><li><p><strong>责任（Responsibilities）</strong>：类的属性和操作。</p></li><li><p><strong>协作者（Collaborators）</strong>：类完成责任所需的其他类。<br>CRC模型帮助团队理解类之间的关系，并确保系统智能均匀分布。</p></li></ol><p><strong>类的分类</strong>：</p><ol><li><p><strong>实体类（Entity Classes）</strong>：直接从问题陈述中提取，通常表示需要存储在数据库中的事物。</p></li><li><p><strong>边界类（Boundary Classes）</strong>：用于创建用户界面，管理实体对象的表示。</p></li><li><p><strong>控制类（Controller Classes）</strong>：管理“工作单元”，负责创建或更新实体对象、实例化边界对象、处理复杂通信和数据验证。</p></li></ol><p><strong>分配责任的指南</strong>：</p><ol><li><p><strong>系统智能应均匀分布</strong>：避免某个类承担过多责任。</p></li><li><p><strong>责任应尽可能通用</strong>：通用责任应位于类层次结构的高层。</p></li><li><p><strong>信息与行为应封装在一起</strong>：数据及其操作应封装在同一个类中。</p></li><li><p><strong>信息应局部化</strong>：特定类型的信息应由单个类管理，避免分散。</p></li><li><p><strong>责任应在相关类之间共享</strong>：当多个相关类需要相同行为时，责任应共享。</p></li></ol><p><strong>识别协作者</strong>：</p><ol><li><p><strong>部分关系（is-part-of）</strong>：类是否是另一个类的组成部分。</p></li><li><p><strong>知识关系（has-knowledge-of）</strong>：类是否需要从另一个类获取信息。</p></li><li><p><strong>依赖关系（depends-upon）</strong>：类是否依赖于另一个类。</p></li></ol><h3 id="10-5-关联与依赖（Associations-and-Dependencies）"><a href="#10-5-关联与依赖（Associations-and-Dependencies）" class="headerlink" title="10.5 关联与依赖（Associations and Dependencies）"></a><strong>10.5 关联与依赖（Associations and Dependencies）</strong></h3><p>类之间的关系可以通过关联和依赖来表示：</p><ol><li><p><strong>关联（Associations）</strong>：表示类之间的静态关系，可以通过多重性（如1..*表示“一个或多个”）进一步定义。</p></li><li><p><strong>依赖（Dependencies）</strong>：表示类之间的动态关系，通常用于客户端-服务器关系。</p></li></ol><h3 id="10-6-分析包（Analysis-Packages）"><a href="#10-6-分析包（Analysis-Packages）" class="headerlink" title="10.6 分析包（Analysis Packages）"></a><strong>10.6 分析包（Analysis Packages）</strong></h3><p>分析包用于对需求模型中的元素（如用例、分析类）进行分类和分组，以便在大型系统中更易于管理。例如，视频游戏的分析包可以包括“环境”、“角色”和“规则”等类别。</p><h1 id="第11章"><a href="#第11章" class="headerlink" title="第11章"></a>第11章</h1><p>11.1,11.2,11.3,11.4,11.5(11.5.3~11.5.8)</p><p>&#x20;</p><h1 id="第12章"><a href="#第12章" class="headerlink" title="第12章"></a>第12章</h1><p>12.1,12.2(尤其是12.2.1，12.2.3),12.3(12.3.1~12.3.8,12.3.10,12.3.12(重点))</p><p>&#x20;</p><p><img src="/2025/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-4.png"></p><p><img src="/2025/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/5d7236dcf138099c23d43183cd9ab91.jpg"></p><ul><li><p>最后一层应当是Design Class Diagram Design（得到分析类图，作为数据库设计基础）</p></li><li><p>倒数第二层是Software Architectural Design（属于architectural design，即概要设计）</p></li><li><p>完成体系结构设计后可以涉及到技术栈了（例如controller类设计）</p></li><li><p>接口设计时参考时序图（涉及到类之间接口）和状态图（涉及类内接口）</p></li><li><p>组件设计参考状态图（定义了内部方法）、时序图（如何跟其他类协作）、类图</p></li></ul><p><strong>衡量设计质量的属性(FURPS)</strong></p><ol><li><p>Functionality：系统功能是否满足了需求</p></li><li><p>Usability：是否有设计感、导航一致性、使用说明或提示</p></li><li><p>Reliability：是否能平稳运行（MTTF）</p></li><li><p>Performance：性能是否达标（运行速度、响应时间、资源消耗、效率）</p><ul><li>影响因素：类方法数据结构不合适、数据库设计索引太多、类接口参数太复杂、体系结构设计不好、硬件确实不行</li></ul></li><li><p>Supportability：包括可扩展性、可移植性、可服务性</p></li></ol><p>对不同的系统，侧重的属性不同。</p><h3 id="12-3-12-设计类（Design-Classes）-x20"><a href="#12-3-12-设计类（Design-Classes）-x20" class="headerlink" title="12.3.12 设计类（Design Classes）&#x20;"></a><strong>12.3.12 设计类（Design Classes）</strong>&#x20;</h3><p>是面向对象设计中的一个重要概念，用于将分析类（Analysis Classes）细化为可实现的类，为编码提供详细的指导。以下是这一部分的详细介绍：</p><ol><li><strong>设计类的定义</strong></li></ol><p>设计类是从分析类细化而来的，包含了更多的实现细节，用于指导编码。设计类不仅描述了类的属性和操作，还定义了类的接口、数据结构、算法等。</p><ul><li><strong>设计类的类型</strong></li></ul><p>在面向对象设计中，设计类通常分为以下五种类型，每种类型代表设计架构中的不同层次：</p><ol><li><strong>业务域类（Business Domain Classes）</strong></li></ol><ul><li><p><strong>定义</strong>：也称为实体类（Entity Classes），用于实现业务逻辑。</p></li><li><p><strong>职责</strong>：封装业务数据和行为，通常与数据库交互。</p></li><li><p><strong>示例</strong>：在图书馆管理系统中，<code>Book</code> 类和 <code>Reader</code> 类是业务域类。</p></li></ul><ul><li><strong>用户界面类（User Interface Classes）</strong></li></ul><ul><li><p><strong>定义</strong>：也称为边界类（Boundary Classes），用于实现用户与系统的交互。</p></li><li><p><strong>职责</strong>：处理用户输入和输出，通常与用户界面相关。</p></li><li><p><strong>示例</strong>：在图书馆管理系统中，<code>LoginScreen</code> 类和 <code>SearchForm</code> 类是用户界面类。</p></li></ul><ul><li><strong>过程类（Process Classes）</strong></li></ul><ul><li><p><strong>定义</strong>：也称为控制类（Control Classes），用于实现业务逻辑的控制流程。</p></li><li><p><strong>职责</strong>：协调业务域类之间的交互，处理复杂的业务逻辑。</p></li><li><p><strong>示例</strong>：在图书馆管理系统中，<code>BorrowProcess</code> 类和 <code>ReturnProcess</code> 类是过程类。</p></li></ul><ul><li><strong>持久化类（Persistent Classes）</strong></li></ul><ul><li><p><strong>定义</strong>：用于实现数据的持久化存储，通常与数据库交互。</p></li><li><p><strong>职责</strong>：封装数据的存储和检索逻辑。</p></li><li><p><strong>示例</strong>：在图书馆管理系统中，<code>BookDAO</code> 类和 <code>ReaderDAO</code> 类是持久化类。</p></li></ul><ul><li><strong>系统类（System Classes）</strong></li></ul><ul><li><p><strong>定义</strong>：用于实现系统管理和控制功能。</p></li><li><p><strong>职责</strong>：处理系统级别的任务，如日志记录、异常处理、通信等。</p></li><li><p><strong>示例</strong>：在图书馆管理系统中，<code>Logger</code> 类和 <code>ExceptionHandler</code> 类是系统类。</p></li></ul><p><strong>设计类的特征</strong></p><p>为了确保设计类的质量，Arlow 和 Neustadt 提出了设计类的四个特征：</p><ol><li><strong>完整性和充分性（Complete and Sufficient）</strong></li></ol><ul><li><p><strong>定义</strong>：设计类应完整封装所有相关的属性和方法，确保类的功能完备。</p></li><li><p><strong>示例</strong>：<code>Book</code> 类应包含所有与图书相关的属性和方法，如 <code>title</code>、<code>author</code>、<code>borrow()</code> 等。</p></li></ul><ul><li><strong>原始性（Primitiveness）</strong></li></ul><ul><li><p><strong>定义</strong>：类的方法应专注于完成单一服务，避免提供多种方式实现相同功能。</p></li><li><p><strong>示例</strong>：<code>Book</code> 类的 <code>borrow()</code> 方法应只负责借书操作，不应包含还书逻辑。</p></li></ul><ul><li><strong>高内聚（High Cohesion）</strong></li></ul><ul><li><p><strong>定义</strong>：类应具有明确的责任，所有属性和方法应紧密相关。</p></li><li><p><strong>示例</strong>：<code>Book</code> 类的所有方法都应围绕图书的管理操作，如借书、还书、查询等。</p></li></ul><ul><li><strong>低耦合（Low Coupling）</strong></li></ul><ul><li><p><strong>定义</strong>：类之间的依赖应尽量减少，确保类的独立性。</p></li><li><p><strong>示例</strong>：<code>Book</code> 类与 <code>Reader</code> 类之间的交互应通过定义良好的接口进行，避免直接依赖。</p></li></ul><p><strong>设计类的设计步骤</strong></p><ul><li><p><strong>从分析类到设计类</strong>：将分析类细化为设计类，添加实现细节。</p></li><li><p><strong>定义接口</strong>：明确类的接口，确保接口是高内聚的。</p></li><li><p><strong>设计数据结构</strong>：定义类的属性及其数据类型。</p></li><li><p><strong>实现算法</strong>：描述类的方法的处理逻辑，使用伪代码或活动图。</p></li><li><p><strong>优化设计</strong>：通过重构和迭代优化设计类，确保其满足质量特征。</p></li></ul><p><strong>设计类的示例</strong></p><p>以图书馆管理系统为例：</p><ul><li><p><strong>业务域类</strong>：<code>Book</code> 类（图书）、<code>Reader</code> 类（读者）。</p></li><li><p><strong>用户界面类</strong>：<code>LoginScreen</code> 类（登录界面）、<code>SearchForm</code> 类（搜索表单）。</p></li><li><p><strong>过程类</strong>：<code>BorrowProcess</code> 类（借书流程）、<code>ReturnProcess</code> 类（还书流程）。</p></li><li><p><strong>持久化类</strong>：<code>BookDAO</code> 类（图书数据访问）、<code>ReaderDAO</code> 类（读者数据访问）。</p></li><li><p><strong>系统类</strong>：<code>Logger</code> 类（日志记录）、<code>ExceptionHandler</code> 类（异常处理）。</p></li></ul><h1 id="第13章"><a href="#第13章" class="headerlink" title="第13章"></a>第13章</h1><p>13.1.1,13.1.2,13.2,13.3.1,13.6(13.6.1重点)</p><p>&#x20;</p><h1 id="第14章"><a href="#第14章" class="headerlink" title="第14章"></a>第14章</h1><p>14.1.1,14.1.2,14.3（重中之重）</p><h2 id="14-3-组件级设计的定义"><a href="#14-3-组件级设计的定义" class="headerlink" title="14.3 组件级设计的定义"></a>14.3 <strong>组件级设计的定义</strong></h2><ol><li><strong>组件级设计的定义</strong></li></ol><p>组件级设计是对软件架构中的每个组件进行详细设计的过程，包括：</p><ul><li><p><strong>Data Structures（数据结构）</strong>：定义组件内部的数据结构。</p></li><li><p><strong>Algorithms（算法）</strong>：描述组件内部的处理逻辑。</p></li><li><p><strong>Interfaces（接口）</strong>：定义组件与其他组件或外部系统的交互方式。</p></li><li><p><strong>Communication Mechanisms（通信机制）</strong>：描述组件之间的通信方式。</p></li></ul><ul><li><strong>组件级设计的输入</strong></li></ul><ul><li><p><strong>Requirements Model（需求模型）</strong>：包括用例、类图、状态图等，描述系统的功能和行为。</p></li><li><p><strong>Architectural Model（架构模型）</strong>：包括系统架构图、模块划分等，描述系统的整体结构。</p></li></ul><ul><li><strong>组件级设计的输出</strong></li></ul><ul><li><p><strong>Component Design Document（组件设计文档）</strong>：包括组件的接口、属性、操作、数据结构、算法等详细描述。</p></li><li><p><strong>Design Diagrams（设计图）</strong>：如类图、序列图、活动图等，用于表示组件的内部结构和行为。</p></li></ul><ul><li><strong>组件级设计的步骤</strong></li></ul><h4 id="Step-1-Identify-Design-Classes-Related-to-the-Problem-Domain（识别与问题域相关的设计类）"><a href="#Step-1-Identify-Design-Classes-Related-to-the-Problem-Domain（识别与问题域相关的设计类）" class="headerlink" title="Step 1: Identify Design Classes Related to the Problem Domain（识别与问题域相关的设计类）"></a><strong>Step 1: Identify Design Classes Related to the Problem Domain（识别与问题域相关的设计类）</strong></h4><ul><li><p><strong>任务</strong>：从需求模型和架构模型中识别出与问题域相关的设计类。</p></li><li><p><strong>方法</strong>：通过分析用例、类图和协作图，确定需要设计的类。</p></li><li><p><strong>输出</strong>：问题域设计类列表。</p></li></ul><h4 id="Step-2-Identify-Design-Classes-Related-to-the-Infrastructure-Domain（识别与基础设施域相关的设计类）"><a href="#Step-2-Identify-Design-Classes-Related-to-the-Infrastructure-Domain（识别与基础设施域相关的设计类）" class="headerlink" title="Step 2: Identify Design Classes Related to the Infrastructure Domain（识别与基础设施域相关的设计类）"></a><strong>Step 2: Identify Design Classes Related to the Infrastructure Domain（识别与基础设施域相关的设计类）</strong></h4><ul><li><p><strong>任务</strong>：识别与基础设施相关的设计类，如用户界面类、数据库管理类等。</p></li><li><p><strong>方法</strong>：分析系统的非功能性需求，确定需要的基础设施类。</p></li><li><p><strong>输出</strong>：基础设施域设计类列表。</p></li></ul><h4 id="Step-3-Elaborate-Non-Reusable-Design-Classes（细化非可重用组件的设计类）"><a href="#Step-3-Elaborate-Non-Reusable-Design-Classes（细化非可重用组件的设计类）" class="headerlink" title="Step 3: Elaborate Non-Reusable Design Classes（细化非可重用组件的设计类）"></a><strong>Step 3: Elaborate Non-Reusable Design Classes（细化非可重用组件的设计类）</strong></h4><ul><li><p><strong>任务</strong>：详细描述每个设计类的接口、属性和操作。</p></li><li><p><strong>方法</strong>：使用 UML 类图、序列图等工具，细化类的设计。</p></li><li><p><strong>子步骤</strong>：</p><ul><li><p><strong>Step 3a: Specify Message Details（指定消息细节）</strong>：使用协作图或序列图描述对象之间的消息传递。</p></li><li><p><strong>Step 3b: Identify Component Interfaces（识别组件的接口）</strong>：定义组件的接口，确保接口是高内聚的。</p></li><li><p><strong>Step 3c: Elaborate Attributes and Data Structures（细化属性和数据结构）</strong>：详细描述每个属性的数据类型和数据结构。</p></li><li><p><strong>Step 3d: Describe Operation Processing Flow（描述操作的处理流程）</strong>：使用伪代码或 UML 活动图描述操作的算法。</p></li></ul></li><li><p><strong>输出</strong>：详细的设计类文档。</p></li></ul><h4 id="Step-4-Describe-Persistent-Data-Sources（描述持久化数据源）"><a href="#Step-4-Describe-Persistent-Data-Sources（描述持久化数据源）" class="headerlink" title="Step 4: Describe Persistent Data Sources（描述持久化数据源）"></a><strong>Step 4: Describe Persistent Data Sources（描述持久化数据源）</strong></h4><ul><li><p><strong>任务</strong>：详细描述数据库和文件的结构，并识别管理它们的类。</p></li><li><p><strong>方法</strong>：分析系统的数据需求，设计数据库表和文件结构。</p></li><li><p><strong>输出</strong>：持久化数据源设计文档。</p></li></ul><h4 id="Step-5-Develop-Behavioral-Representations（开发行为表示）"><a href="#Step-5-Develop-Behavioral-Representations（开发行为表示）" class="headerlink" title="Step 5: Develop Behavioral Representations（开发行为表示）"></a><strong>Step 5: Develop Behavioral Representations（开发行为表示）</strong></h4><ul><li><p><strong>任务</strong>：使用 UML 状态图描述类的行为。</p></li><li><p><strong>方法</strong>：分析类的生命周期和状态转换，绘制状态图。</p></li><li><p><strong>输出</strong>：类的状态图。</p></li></ul><h4 id="Step-6-Refine-Deployment-Diagrams（细化部署图）"><a href="#Step-6-Refine-Deployment-Diagrams（细化部署图）" class="headerlink" title="Step 6: Refine Deployment Diagrams（细化部署图）"></a><strong>Step 6: Refine Deployment Diagrams（细化部署图）</strong></h4><ul><li><p><strong>任务</strong>：描述组件在计算环境中的位置。</p></li><li><p><strong>方法</strong>：使用 UML 部署图表示组件的部署位置。</p></li><li><p><strong>输出</strong>：部署图。</p></li></ul><h4 id="Step-7-Refactor-Design-Representations（重构设计表示）"><a href="#Step-7-Refactor-Design-Representations（重构设计表示）" class="headerlink" title="Step 7: Refactor Design Representations（重构设计表示）"></a><strong>Step 7: Refactor Design Representations（重构设计表示）</strong></h4><ul><li><p><strong>任务</strong>：通过迭代和重构优化设计模型。</p></li><li><p><strong>方法</strong>：检查设计的完整性、一致性和准确性，进行必要的调整。</p></li><li><p><strong>输出</strong>：优化后的设计模型。</p></li></ul><ul><li><strong>组件级设计的关键原则</strong></li></ul><ul><li><p><strong>High Cohesion（高内聚）</strong>：组件内部的元素应紧密相关，完成单一功能。</p></li><li><p><strong>Low Coupling（低耦合）</strong>：组件之间的依赖应尽量减少，确保组件的独立性。</p></li><li><p><strong>Information Hiding（信息隐藏）</strong>：组件的内部实现细节应对其他组件隐藏，只暴露必要的接口。</p></li><li><p><strong>Functional Independence（功能独立性）</strong>：组件应具有独立的功能，便于复用和维护。</p></li></ul><ul><li><strong>组件级设计的工具</strong></li></ul><ul><li><p><strong>UML Class Diagrams（UML 类图）</strong>：用于表示类的属性和操作。</p></li><li><p><strong>UML Sequence Diagrams（UML 序列图）</strong>：用于表示对象之间的消息传递。</p></li><li><p><strong>UML Activity Diagrams（UML 活动图）</strong>：用于描述操作的流程。</p></li><li><p><strong>UML State Diagrams（UML 状态图）</strong>：用于表示类的状态转换。</p></li><li><p><strong>Pseudocode（伪代码）</strong>：用于描述算法的逻辑。</p></li></ul><ul><li><strong>组件级设计的输出示例</strong></li></ul><ul><li><p><strong>Class Diagrams（类图）</strong>：表示类的属性和操作。</p></li><li><p><strong>Sequence Diagrams（序列图）</strong>：表示对象之间的交互。</p></li><li><p><strong>Activity Diagrams（活动图）</strong>：表示操作的流程。</p></li><li><p><strong>State Diagrams（状态图）</strong>：表示类的状态转换。</p></li><li><p><strong>Design Documents（设计文档）</strong>：详细描述组件的接口、属性、操作、数据结构和算法。</p></li></ul><p><strong>总结</strong></p><p><strong>14.3 进行组件级设计</strong> 是软件设计过程中的关键阶段，通过详细设计每个组件的内部结构、行为和接口，为编码和测试提供指导。其核心步骤包括：</p><ul><li><p><strong>Identifying Design Classes（识别设计类）</strong>：从需求模型和架构模型中识别问题域和基础设施域的设计类。</p></li><li><p><strong>Elaborating Design Classes（细化设计类）</strong>：详细描述每个设计类的接口、属性、操作、数据结构和算法。</p></li><li><p><strong>Describing Persistent Data Sources（描述持久化数据源）</strong>：设计数据库和文件结构。</p></li><li><p><strong>Developing Behavioral Representations（开发行为表示）</strong>：使用状态图描述类的行为。</p></li><li><p><strong>Refining Deployment Diagrams（细化部署图）</strong>：描述组件在计算环境中的位置。</p></li><li><p><strong>Refactoring Design Representations（重构设计表示）</strong>：通过迭代和重构优化设计模型。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 大学课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 敏捷开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式期末复习</title>
      <link href="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
      <url>/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-软件工程设计原则"><a href="#1-软件工程设计原则" class="headerlink" title="1 软件工程设计原则"></a>1 软件工程设计原则</h1><h2 id="1-1-对象间关系"><a href="#1-1-对象间关系" class="headerlink" title="1.1 对象间关系"></a>1.1 对象间关系</h2><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-14.png"></p><ol><li><p><strong>Dependency（依赖）</strong>：表示⼀个对象在某种程度上依赖于另⼀个对象。在⽂件中，它被⽤来描述“Professor（教授）” 和“Course（课程）”之间的关系，意味着教授依赖于课程来完成教学任务。&#x20;</p></li><li><p><strong>Association（关联）</strong>：表示两个对象之间有某种联系，但这种<strong>联系不像依赖那样强烈</strong>。在这⾥，它被⽤来描述 “Professor（教授）”和“Student（学⽣）”之间的关系，表示教授和学⽣之间存在教学或指导的联系。&#x20;</p></li><li><p><strong>Aggregation（聚合）</strong>：表示⼀种整体与部分的关系，但部分可以独⽴于整体存在。⽂件中⽤“Professor（教授）”和 “Department（系）”来说明这种关系，意味着教授是系的⼀部分，但教授不依赖于系⽽存在。&#x20;</p></li><li><p><strong>Composition（组合）</strong>：也是⼀种整体与部分的关系，但与聚合不同的是，部分不能独⽴于整体存在。⽂件中⽤ “University（⼤学）”和“Department（系）”来说明这种关系，表示系是⼤学的⼀部分，并且系的存在依赖于⼤学。&#x20;</p></li><li><p><strong>Inheritance（继承）</strong>：这是⼀种类与类之间的关系，⼦类继承⽗类的属性和⽅法。⽂件中⽤“A→B”来表示这种关系， 意味着B类继承了A类的某些特性。</p></li></ol><h2 id="1-2-设计原则"><a href="#1-2-设计原则" class="headerlink" title="1.2 设计原则"></a>1.2 设计原则</h2><ol><li><p><strong>封装变化（Encapsulate what varies）</strong>:</p><ul><li><p>识别应用程序中变化的部分，并将它们与不变的部分分离。</p></li><li><p>目标是最小化变化带来的影响，通过将变化的部分隔离在独立的模块中，保护其他部分不受变化影响。</p></li><li><p>可以在方法级别和类级别上进行封装。</p></li></ul></li><li><p><strong>面向接口编程（Program to an interface, not an implementation）</strong>:</p><ul><li><p>依赖于抽象而不是具体类。</p></li><li><p>设计应足够灵活，能够轻松扩展而不影响现有代码。</p></li><li><p>通过定义接口或抽象类来描述一个对象需要从另一个对象中获取的内容，然后让依赖类实现这个接口，而不是依赖于具体类。</p></li></ul></li><li><p><strong>组合优于继承（Favor composition over inheritance）</strong>:</p><ul><li><p>继承带来的挑战包括子类不能减少父类的接口，重写方法时需要确保新行为与基类兼容，继承破坏了父类的封装，子类与父类紧密耦合。</p></li><li><p>通过组合（”has-a”关系）而不是继承（”is-a”关系）来重用代码。</p></li></ul></li><li><p><strong>SOLID原则</strong>:</p><ul><li><p><strong>单一职责原则（Single Responsibility Principle）</strong>: 一个类应该只有一个引起它变化的原因，即每个类应该只负责一个功能部分，并且该功能完全封装。</p></li><li><p><strong>开闭原则（Open&#x2F;Closed Principle）</strong>: 类应该对扩展开放，对修改封闭。这意味着可以在不修改现有代码的情况下扩展类的行为。</p></li><li><p><strong>里氏替换原则（Liskov Substitution Principle）</strong>: 子类对象应该能够替换其父类对象被使用，而不影响程序的正确性。子类应该保持与父类相同的行为。</p></li><li><p><strong>接口隔离原则（Interface Segregation Principle）</strong>: 客户端不应该依赖于它们不使用的方法。应该将“胖”接口拆分成更小、更具体的接口。</p></li><li><p><strong>依赖倒置原则（Dependency Inversion Principle）</strong>: 高层模块不应该依赖于低层模块，两者都应该依赖于抽象。改变依赖的方向，让高层模块和低层模块都依赖于抽象。</p></li></ul></li></ol><h1 id="2-创建型模式"><a href="#2-创建型模式" class="headerlink" title="2 创建型模式"></a>2 创建型模式</h1><h2 id="2-1-工厂方法模式"><a href="#2-1-工厂方法模式" class="headerlink" title="2.1 工厂方法模式"></a>2.1 工厂方法模式</h2><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-11.png"></p><p>调用工厂方法的代码 （通常被称为<em>客户端</em>代码） 无需了解不同子类返回实际对象之间的差别。 客户端将所有产品视为抽象的<code>运输</code> 。 客户端知道所有运输对象都提供<code>交付</code>方法，但是并不关心其具体实现方式。</p><p><strong>工厂方法模式结构</strong></p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-13.png"></p><ol><li><p><strong>产品</strong> （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。</p></li><li><p><strong>具体产品</strong> （Concrete Products） 是产品接口的不同实现。</p></li><li><p><strong>创建者</strong> （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与<strong>产品接口相匹配</strong>。</p></li><li><p><strong>具体创建者</strong> （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。</p></li></ol><p><strong>使用场景</strong></p><ul><li><p>当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。</p></li><li><p>如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。</p></li></ul><p><strong>实现方式</strong></p><ol><li><p>让所有产品都遵循同一接口。 该接口必须声明对所有产品都有意义的方法。</p></li><li><p>在创建类中添加一个空的工厂方法。 该方法的返回类型必须遵循通用的产品接口。</p></li><li><p>在创建者代码中找到对于产品构造函数的所有引用。 将它们依次替换为对于工厂方法的调用， 同时将创建产品的代码移入工厂方法。</p></li></ol><p><strong>优点</strong></p><ul><li><p>&#x20;你可以避免创建者和具体产品之间的紧密耦合。</p></li><li><p>&#x20;<em>单一职责原则</em>。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。</p></li><li><p>&#x20;<em>开闭原则</em>。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。</p></li></ul><p><strong>缺点</strong></p><ul><li>应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。</li></ul><h2 id="2-2-抽象工厂模式"><a href="#2-2-抽象工厂模式" class="headerlink" title="2.2 抽象工厂模式"></a>2.2 抽象工厂模式</h2><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-9.png"></p><p><strong>抽象工厂模式</strong>是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-8.png"></p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-7.png"></p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-4.png"></p><ol><li><p><strong>抽象产品</strong> （Abstract Product） 为构成系列产品的一组不同但相关的产品声明接口。</p></li><li><p><strong>具体产品</strong> （Concrete Product） 是抽象产品的多种不同类型实现。 所有变体 （维多利亚&#x2F;现代） 都必须实现相应的抽象产品 （椅子&#x2F;沙发）。</p></li><li><p><strong>抽象工厂</strong> （Abstract Factory） 接口声明了一组创建各种抽象产品的方法。</p></li><li><p><strong>具体工厂</strong> （Concrete Factory） 实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体。</p></li><li><p>尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的<em>抽象</em>产品。如下，返回的Button是抽象产品(接口)。</p></li></ol><p>&#x20;     这样， 使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。 <strong>客户端</strong> （Client） 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂&#x2F;产品变体交互。</p><p><strong>适用场景</strong></p><ul><li><p>如果代码需要与多个不同系列的相关产品交互， 但是由于<strong>无法提前获取相关信息</strong>， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。</p></li><li><p>如果你有一个基于一组<a href="https://refactoringguru.cn/design-patterns/factory-method">抽象方法</a>的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。</p></li></ul><p><strong>实现方式</strong></p><ol><li><p>以不同的产品类型与产品变体为维度绘制矩阵。</p></li><li><p>为所有产品声明抽象产品接口。 然后让所有具体产品类实现这些接口。</p></li><li><p>声明抽象工厂接口， 并且在接口中为所有抽象产品提供一组构建方法。</p></li><li><p>为每种产品变体实现一个具体工厂类。</p></li><li><p>在应用程序中开发初始化代码。 该代码根据应用程序配置或当前环境， 对特定具体工厂类进行初始化。 然后将该工厂对象传递给所有需要创建产品的类。</p></li><li><p>找出代码中所有对产品构造函数的直接调用， 将其替换为对工厂对象中相应构建方法的调用。</p></li></ol><p><strong>优点</strong></p><ul><li><p>你可以确保同一工厂生成的产品相互匹配。</p></li><li><p>你可以避免客户端和具体产品代码的耦合。</p></li><li><p><em>单一职责原则</em>。 你可以将产品生成代码抽取到同一位置，使得代码易于维护。</p></li><li><p>&#x20;<em>开闭原则</em>。 向应用程序中引入新产品变体时， 你无需修改客户端代码。</p></li></ul><p><strong>缺点</strong></p><ul><li>由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。</li></ul><h2 id="2-3-生成器模式"><a href="#2-3-生成器模式" class="headerlink" title="2.3 生成器模式"></a>2.3 生成器模式</h2><p><strong>生成器模式</strong>是一种创建型设计模式， 使你能够分<strong>步骤创建</strong>复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。</p><p>生成器模式建议将对象构造代码从产品类中抽取出来， 并将其放在一个名为<em>生成器</em>的独立对象中。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-6.png"></p><p>生成器模式让你能够分步骤创建复杂对象。 生成器不允许其他对象访问正在创建中的产品。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-12.png"></p><ol><li><p><strong>生成器</strong> （Builder） 接口声明在所有类型生成器中通用的产品构造步骤。</p></li><li><p><strong>具体生成器</strong> （Concrete Builders） 提供构造过程的<strong>不同实现</strong>。 具体生成器也可以构造不遵循通用接口的产品。</p></li><li><p><strong>产品</strong> （Products） 是最终生成的对象。 由不同生成器构造的产品无需属于同一类层次结构或接口。</p></li><li><p><strong>主管</strong> （Director） 类定义调用构造步骤的顺序， 这样你就可以创建和复用特定的产品配置。</p></li><li><p><strong>客户端</strong> （Client） 必须将某个<strong>生成器对象</strong>与<strong>主管类</strong>关联。 一般情况下， 你只需通过<strong>主管类构造函数</strong>的参数进行一次性关联即可。 此后主管类就能使用生成器对象完成后续所有的构造任务。 但在客户端将生成器对象<strong>传递</strong>给主管类制造方法时还有另一种方式。 在这种情况下， 你在使用主管类生产产品时每次都可以使用不同的生成器。</p></li></ol><p><strong>使用场景</strong></p><ol><li><p>使用生成器模式可避免 “重叠构造函（telescoping constructor）” 的出现。例如</p></li><li><p>&#x20;当你希望使用代码创建不同形式的产品 （例如石头或木头房屋） 时， 可使用生成器模式。</p></li><li><p>使用生成器构造<a href="https://refactoringguru.cn/design-patterns/composite">组合</a>树或其他复杂对象。</p></li></ol><p><strong>优点</strong></p><ul><li><p>你可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。</p></li><li><p>&#x20;生成不同形式的产品时， 你可以复用相同的制造代码。</p></li><li><p>&#x20;<em>单一职责原则</em>。 你可以将复杂构造代码从产品的业务逻辑中分离出来。</p></li></ul><p><strong>缺点</strong></p><ul><li>由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。</li></ul><p><strong>区别</strong></p><ul><li><a href="https://refactoringguru.cn/design-patterns/builder"><strong>生成器</strong></a>重点关注如何分步生成复杂对象。 <a href="https://refactoringguru.cn/design-patterns/abstract-factory"><strong>抽象工厂</strong></a>专门用于生产一系列相关对象。 <em>抽象工厂</em>会马上返回产品， <em>生成器</em>则允许你在获取产品前执行一些额外构造步骤。</li></ul><h2 id="2-4-原型模式"><a href="#2-4-原型模式" class="headerlink" title="2.4 原型模式"></a>2.4 原型模式</h2><p><strong>原型模式</strong>是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-10.png"></p><ol><li><p><strong>原型</strong> （Prototype） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 <code>clone</code>克隆的方法。</p></li><li><p><strong>具体原型</strong> （Concrete Prototype） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。</p></li><li><p><strong>客户端</strong> （Client） 可以复制实现了原型接口的任何对象。</p></li></ol><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-3.png"></p><p><strong>使用场景</strong></p><ol><li><p>如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。</p></li><li><p>如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。</p></li></ol><p><strong>实现步骤</strong></p><ol><li><p>创建原型接口， 并在其中声明 <code>克隆</code>方法。 如果你已有类层次结构， 则只需在其所有类中添加该方法即可。</p></li><li><p>原型类必须另行定义一个以该类对象为参数的构造函数。 构造函数必须复制参数对象中的所有成员变量值到新建实体中。 如果你需要修改子类， 则必须调用父类构造函数， 让父类复制其私有成员变量值。</p></li><li><p>克隆方法通常只有一行代码： 使用 <code>new</code>运算符调用原型版本的构造函数。</p></li><li><p>你还可以创建一个中心化原型注册表， 用于存储常用原型。</p></li></ol><p><strong>优点</strong></p><ul><li><p>你可以克隆对象， 而无需与它们所属的具体类相耦合。</p></li><li><p>你可以克隆预生成原型， 避免反复运行初始化代码。</p></li><li><p>你可以更方便地生成复杂对象。</p></li><li><p>你可以用继承以外的方式来处理复杂对象的不同配置。</p></li></ul><p><strong>缺点</strong></p><ul><li>克隆包含循环引用的复杂对象可能会非常麻烦。</li></ul><h2 id="2-5-单例模式"><a href="#2-5-单例模式" class="headerlink" title="2.5 单例模式"></a>2.5 单例模式</h2><p><strong>单例模式</strong>是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p><p>单例模式同时解决了两个问题， 所以违反了<em>单一职责原则</em>：</p><ol><li><p><strong>保证一个类只有一个实例</strong>。 它的运作方式是这样的： 如果你创建了一个对象， 同时过一会儿后你决定再创建一个新对象， 此时你会获得之前已创建的对象， 而不是一个新对象。注意， 普通构造函数无法实现上述行为， 因为构造函数的设计决定了它<strong>必须</strong>总是返回一个新对象。</p></li><li><p><strong>为该实例提供一个全局访问节点</strong>。&#x20;</p></li></ol><p>&#x20;    和全局变量一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-5.png"></p><ol><li><p><strong>单例</strong> （Singleton） 类声明了一个名为 <code>get­Instance</code>获取实例的静态方法来返回其所属类的一个相同实例。</p></li><li><p>单例的构造函数必须对客户端 （Client） 代码隐藏。 调用 <code>获取实例</code>方法必须是获取单例对象的唯一方式。</p></li></ol><p><strong>使用场景</strong></p><ul><li><p>如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。</p></li><li><p>如果你需要更加严格地控制全局变量， 可以使用单例模式。</p></li></ul><p><strong>实现方式</strong></p><ol><li><p>在类中添加一个私有静态成员变量用于保存单例实例。</p></li><li><p>声明一个公有静态构建方法用于获取单例实例。</p></li><li><p>在静态方法中实现”延迟初始化”。 该方法会在首次被调用时创建一个新对象， 并将其存储在静态成员变量中。 此后该方法每次被调用时都返回该实例。</p></li><li><p>将类的构造函数<strong>设为私有</strong>。 类的静态方法仍能调用构造函数， 但是其他对象不能调用。</p></li><li><p>检查客户端代码， 将对单例的构造函数的调用替换为<strong>对其静态构建方法的调用</strong>。</p></li></ol><p>总结一下，就是构造静态方法创建并访问，阻止所有其他可以new一个实例的方法。</p><p><strong>优点</strong></p><ul><li><p>你可以保证一个类只有一个实例。</p></li><li><p>&#x20;你获得了一个指向该实例的全局访问节点。</p></li><li><p>&#x20;仅在首次请求单例对象时对其进行初始化。</p></li></ul><p><strong>缺点</strong></p><ul><li><p>违反了<em>单一职责原则</em>。 该模式同时解决了两个问题。</p></li><li><p>单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。</p></li><li><p>该模式在多线程环境下需要进行特殊处理， <strong>避免多个线程多次创建单例对象</strong>。</p></li><li><p>单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。</p></li></ul><h1 id="3-结构型模式"><a href="#3-结构型模式" class="headerlink" title="3 结构型模式"></a>3 结构型模式</h1><h2 id="3-1-适配器模式"><a href="#3-1-适配器模式" class="headerlink" title="3.1 适配器模式"></a>3.1 适配器模式</h2><p><strong>适配器模式</strong>是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-1.png"></p><ol><li><p><strong>客户端</strong> （Client） 是包含当前程序业务逻辑的类。</p></li><li><p><strong>客户端接口</strong> （Client Interface） 描述了其他类与客户端代码合作时必须遵循的<strong>协议</strong>。</p></li><li><p><strong>服务</strong> （Service） 中有一些功能类 （通常来自第三方或遗留系统）。 客户端<strong>与其接口不兼容</strong>， 因此无法直接调用其功能。</p></li><li><p><strong>适配器</strong> （Adapter） 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时封装了服务对象。 适配器接受客户端通过适配器接口发起的调用， 并将其转换为适用于被封装服务对象的调用。</p></li><li><p>客户端代码只需<strong>通过接口</strong>与适配器交互即可， <strong>无需与具体</strong>的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。</p></li></ol><p><strong>适用场景</strong></p><ul><li><p>当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。</p></li><li><p>如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。</p></li></ul><p><strong>实现方式</strong></p><ol><li><p>确保至少有两个类的接口不兼容：</p><ul><li><p>一个无法修改 （通常是第三方、 遗留系统或者存在众多已有依赖的类） 的功能性<em>服务</em>类。</p></li><li><p>一个或多个将受益于使用服务类的<em>客户端</em>类。</p></li></ul></li><li><p>声明客户端接口， 描述客户端如何与服务交互。</p></li><li><p>创建遵循客户端接口的适配器类。 所有方法暂时都为空。</p></li><li><p>在适配器类中添加一个成员变量用于保存对于服务对象的引用。 通常情况下会通过构造函数对该成员变量进行初始化， 但有时在调用其方法时将该变量传递给适配器会更方便。</p></li><li><p>依次实现适配器类客户端接口的所有方法。 适配器会将实际工作委派给服务对象， <strong>自身只负责接口或数据格式的转换</strong>。</p></li><li><p>客户端必须通过客户端接口使用适配器。 这样一来， 你就可以在不影响客户端代码的情况下修改或扩展适配器。</p></li></ol><p><strong>优点</strong></p><ul><li><p><em>单一职责原则</em>你可以将接口或数据转换代码从程序主要业务逻辑中分离。</p></li><li><p>&#x20;<em>开闭原则</em>。 只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。</p></li></ul><p><strong>缺点</strong></p><ul><li>代码整体复杂度增加， 因为你需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。</li></ul><h2 id="3-2-桥接模式"><a href="#3-2-桥接模式" class="headerlink" title="3.2 桥接模式"></a>3.2 桥接模式</h2><p><strong>桥接模式</strong>是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为<strong>抽象</strong>和<strong>实现</strong>两个独立的层次结构， 从而能在开发时分别使用。</p><p><em>抽象部分</em> （也被称为<em>接口</em>） 是一些实体的高阶控制层。 该层自身不完成任何具体的工作， 它需要将工作委派给<em>实现部分</em>层 （也被称为<em>平台</em>）。</p><p>注意， 这里提到的内容与编程语言中的<em>接口</em>或<em>抽象类</em>无关。 它们并不是一回事。</p><p>在实际的程序中， 抽象部分是图形用户界面 （GUI）， 而实现部分则是底层操作系统代码 （API）， GUI 层调用 API 层来对用户的各种操作做出响应。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image.png"></p><p>将一个类层次转化为多个相关的类层次， 避免单个类层次的失控。</p><p>根据该方法， 我们可以将颜色相关的代码抽取到拥有 <code>红色</code>和 <code>蓝色</code>两个子类的颜色类中， 然后在 <code>形状</code>类中添加一个指向某一颜色对象的引用成员变量。 现在， 形状类可以将所有与颜色相关的工作委派给连入的颜色对象。 这样的引用就成为了 <code>形状</code>和 <code>颜色</code>之间的桥梁。 此后， 新增颜色将不再需要修改形状的类层次， 反之亦然。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-2.png"></p><ol><li><p><strong>抽象部分</strong> （Abstraction） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。</p></li><li><p><strong>实现部分</strong> （Implementation） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。</p></li></ol><p>&#x20;     抽象部分可以列出和实现部分一样的方法， 但是抽象       部分通常声明一些复杂行为， 这些行为依赖于多种由       实现部分声明的原语操作。</p><ul><li><p><strong>具体实现</strong> （Concrete Implementations） 中包括特定于平台的代码。</p></li><li><p><strong>精确抽象</strong> （Refined Abstraction） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。</p></li><li><p>通常情况下， <strong>客户端</strong> （Client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。</p></li></ul><p><strong>适用场景</strong></p><ul><li><p>如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。</p></li><li><p>如果你希望在几个独立维度上扩展一个类， 可使用该模式。</p></li><li><p>&#x20;如果你需要在运行时切换不同实现方法， 可使用桥接模式。</p></li></ul><p><strong>实现方式</strong></p><ol><li><p>明确类中独立的维度。 独立的概念可能是： 抽象&#x2F;平台， 域&#x2F;基础设施， 前端&#x2F;后端或接口&#x2F;实现。</p></li><li><p>了解客户端的业务需求， 并在抽象基类中定义它们。</p></li><li><p>确定在所有平台上都可执行的业务。 并在通用实现接口中声明抽象部分所需的业务。</p></li><li><p>为你域内的所有平台创建实现类， 但需确保它们遵循实现部分的接口。</p></li><li><p>在抽象类中添加指向实现类型的引用成员变量。 抽象部分会<strong>将大部分工作委派给该成员变量所指向的实现对象。</strong></p></li><li><p>如果你的高层逻辑有多个变体， 则可通过<strong>扩展抽象基类</strong>为每个变体创建一个精确抽象。</p></li><li><p>客户端代码必须将实现对象传递给抽象部分的构造函数才能使其能够相互关联。 此后， 客户端只需与抽象对象进行交互， 无需和实现对象打交道。</p></li></ol><p><strong>优点</strong></p><ul><li><p>你可以创建与平台无关的类和程序。</p></li><li><p>客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。</p></li><li><p><em>开闭原则</em>。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响。</p></li><li><p><em>单一职责原则</em>。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节。</p></li></ul><p><strong>缺点</strong></p><ul><li>对高内聚的类使用该模式可能会让代码更加复杂。</li></ul><h2 id="3-3-组合模式"><a href="#3-3-组合模式" class="headerlink" title="3.3 组合模式"></a>3.3 组合模式</h2><p><strong>组合模式</strong>是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-29.png"></p><ol><li><p><strong>组件</strong> （Component） 接口描述了树中简单项目和复杂项目所共有的操作。</p></li><li><p><strong>叶节点</strong> （Leaf） 是树的基本结构， 它不包含子项目。一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。</p></li><li><p><strong>容器</strong> （Container）——又名 “组合（Composite）”——是包含叶节点或其他容器等子项目的单位。 容器<strong>不知道其子项目所属的具体类</strong>， 它只通过通用的组件接口与其子项目交互。</p></li></ol><p>&#x20;    容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。</p><ul><li><strong>客户端</strong> （Client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。</li></ul><p><strong>适用场景</strong></p><ul><li><p>&#x20;如果你需要实现树状对象结构， 可以使用组合模式。</p></li><li><p>&#x20;如果你希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。</p></li></ul><p><strong>实现方式</strong></p><ol><li><p>确保应用的核心模型能够以树状结构表示。 尝试将其分解为简单元素和容器。 记住， 容器必须能够同时包含简单元素和其他容器。</p></li><li><p>声明组件接口及其一系列方法， 这些方法对简单和复杂元素都有意义。</p></li><li><p>创建一个叶节点类表示简单元素。 程序中可以有多个不同的叶节点类。</p></li><li><p>创建一个容器类表示复杂元素。 在该类中， 创建一个数组成员变量来存储对于其子元素的引用。 该数组必须能够同时保存叶节点和容器， 因此请确保将其声明为组合接口类型。</p></li></ol><p>&#x20;     实现组件接口方法时， 记住容器应该将大部分工作交给其子元素来完成。</p><ul><li>最后，在容器中定义<strong>添加和删除</strong>子元素的方法。</li></ul><p>&#x20;     记住，这些操作可在组件接口中声明。 这将会违反<em>接口隔离原则</em>， 因为叶节点类中的这些方法为空。 但是， 这可以让客户端无差别地访问所有元素， 即使是组成树状结构的元素。</p><p><strong>优点</strong></p><ul><li><p>你可以利用多态和递归机制更方便地使用复杂树结构。</p></li><li><p><em>开闭原则</em>。 无需更改现有代码， 你就可以在应用中添加新元素， 使其成为对象树的一部分。</p></li></ul><p><strong>缺点&#x20;</strong></p><ul><li>对于功能差异较大的类， 提供公共接口或许会有困难。 在特定情况下， 你需要过度一般化组件接口， 使其变得令人难以理解。</li></ul><h2 id="3-4-装饰模式"><a href="#3-4-装饰模式" class="headerlink" title="3.4 装饰模式"></a>3.4 装饰模式</h2><p><strong>装饰模式</strong>是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-25.png"></p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-28.png"></p><p>客户端代码必须将基础通知器放入一系列自己所需的装饰中。 因此最后的对象将形成一个栈结构。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-26.png"></p><p><strong>装饰器模式结构</strong></p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-27.png"></p><ol><li><p><strong>部件</strong>（Component）声明封装器和被封装对象的公用接口。</p></li><li><p><strong>具体部件</strong>（Concrete Component）类是被封装对象所属的类。 它定义了基础行为， 但装饰类可以改变这些行为。</p></li><li><p><strong>基础装饰</strong> （Base Decorator）类拥有一个指向<strong>被封装对象的引用成员变量</strong>。 该变量的类型应当被声明为通用部件接口， 这样它就可以引用具体的部件和装饰。 装饰基类会将所有操作委派给被封装的对象。</p></li><li><p><strong>具体装饰类</strong> （Concrete Decorators） 定义了可动态添加到部件的<strong>额外行为</strong>。 具体装饰类会重写装饰基类的方法， 并在调用父类方法之前或之后进行额外的行为。</p></li><li><p><strong>客户端</strong> （Client）可以使用多层装饰来封装部件， 只要它能使用通用接口与所有对象互动即可。</p></li></ol><p><strong>适用场景</strong></p><ul><li><p>如果你希望在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式。</p></li><li><p>如果用继承来扩展对象行为的方案难以实现或者根本不可行，你可以使用该模式。</p></li></ul><p><strong>实现方式</strong></p><ol><li><p>确保业务逻辑可用一个基本组件及多个额外可选层次表示。</p></li><li><p>找出基本组件和可选层次的通用方法。 创建一个组件接口并在其中声明这些方法。</p></li><li><p>创建一个具体组件类， 并定义其基础行为。</p></li><li><p>创建装饰基类， 使用一个成员变量存储指向被封装对象的引用。 该成员变量必须被声明为组件接口类型， 从而能在运行时连接具体组件和装饰。 装饰基类必须将所有工作委派给被封装的对象。</p></li><li><p>确保所有类实现组件接口。</p></li><li><p>将装饰基类扩展为具体装饰。 具体装饰必须在调用父类方法 （总是委派给被封装对象） 之前或之后执行自身的行为。</p></li><li><p>客户端代码负责创建装饰并将其组合成客户端所需的形式。</p></li></ol><p><strong>优点</strong></p><ul><li><p>&#x20;你无需创建新子类即可扩展对象的行为。</p></li><li><p>&#x20;你可以在运行时添加或删除对象的功能。</p></li><li><p>&#x20;你可以用多个装饰封装对象来组合几种行为。</p></li><li><p>&#x20;<em>单一职责原则</em>。 你可以将实现了许多不同行为的一个大类拆分为多个较小的类。</p></li></ul><p><strong>缺点</strong></p><ul><li><p>&#x20;在封装器栈中删除特定封装器比较困难。</p></li><li><p>&#x20;实现行为不受装饰栈顺序影响的装饰比较困难。</p></li><li><p>&#x20;各层的初始化配置代码看上去可能会很糟糕。</p></li></ul><h2 id="3-5-外观模式"><a href="#3-5-外观模式" class="headerlink" title="3.5 外观模式"></a>3.5 外观模式</h2><p><strong>外观模式</strong>是一种结构型设计模式，能为程序库、框架或其他复杂类提供一个简单的接口。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-24.png"></p><ol><li><p><strong>外观</strong> （Facade） 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。</p></li><li><p><strong>创建附加外观</strong> （Additional Facade） 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。</p></li><li><p><strong>复杂子系统</strong> （Complex Subsystem） 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。</p></li></ol><p>&#x20;     子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。</p><ul><li><strong>客户端</strong> （Client） 使用外观代替对子系统对象的直接调用。</li></ul><p><strong>适用场景</strong></p><ul><li><p>如果你需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。</p></li><li><p>如果需要将子系统组织为多层结构， 可以使用外观。</p></li></ul><p><strong>实现方式</strong></p><ol><li><p>考虑能否在现有子系统的基础上提供一个更简单的接口。如果该接口能让客户端代码独立于众多子系统类，那么你的方向就是正确的。</p></li><li><p>在一个新的外观类中声明并实现该接口。 外观应将客户端代码的调用重定向到子系统中的相应对象处。 如果客户端代码没有对子系统进行初始化，也没有对其后续生命周期进行管理，那么外观必须完成此类工作。</p></li><li><p>如果要充分发挥这一模式的优势，你必须确保所有客户端代码仅通过外观来与子系统进行交互。此后客户端代码将不会受到任何由子系统代码修改而造成的影响，比如子系统升级后，你只需修改外观中的代码即可。</p></li><li><p>如果外观变得<a href="https://refactoringguru.cn/smells/large-class">过于臃肿</a>，你可以考虑将其部分行为抽取为一个新的专用外观类。</p></li></ol><p><strong>优点</strong></p><ul><li>你可以让自己的代码独立于复杂子系统。</li></ul><p><strong>缺点</strong></p><ul><li>外观可能成为与程序中所有类都耦合的<a href="https://refactoringguru.cn/antipatterns/god-object"><strong>上帝对象</strong></a>。</li></ul><h2 id="3-6-享元模式"><a href="#3-6-享元模式" class="headerlink" title="3.6 享元模式"></a>3.6 享元模式</h2><p><strong>享元模式</strong>是一种结构型设计模式，它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。</p><p>对象的<strong>常量数据</strong>通常被称&#x4E3A;<em><strong>内在状态</strong></em>， 其位于对象中， 其他对象只能读取但不能修改其数值。 而对象的其他状态常常能被其他对象 <strong>“从外部” 改变</strong>， 因此被称&#x4E3A;<strong><em>外在状态</em>。</strong></p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-23.png"></p><ol><li><p>享元模式只是一种<strong>优化。</strong> 在应用该模式之前， 你要确定程序中存在与<strong>大量类似对象</strong>同时占用内存相关的内存消耗问题， 并且确保该问题无法使用其他更好的方式来解决。</p></li><li><p><strong>享元</strong> （Flyweight） 类包含原始对象中部分能在多个对象中共享的状态。 同一享元对象可在许多不同情景中使用。 享元中存储的状态被称为 “内在状态”。 传递给享元方法的状态被称为 “外在状态”。</p></li><li><p><strong>情景</strong> （Context） 类包含原始对象中各不相同的外在状态。 情景与享元对象组合在一起就能表示原始对象的全部状态。</p></li><li><p>通常情况下， 原始对象的行为会保留在享元类中。 因此调用享元方法必须提供部分外在状态作为参数。 但你也可将行为移动到情景类中， 然后将连入的享元作为单纯的数据对象。</p></li><li><p><strong>客户端</strong> （Client） 负责计算或存储享元的外在状态。 在客户端看来， 享元是一种可在运行时进行配置的模板对象， 具体的配置方式为向其方法中传入一些情景数据参数。</p></li><li><p><strong>享元工厂</strong> （Flyweight Factory） 会对已有享元的缓存池进行管理。 有了工厂后， 客户端就无需直接创建享元， 它们只需调用工厂并向其传递目标享元的一些内在状态即可。 工厂会根据参数在之前已创建的享元中进行查找， 如果找到满足条件的享元就将其返回； 如果没有找到就根据参数新建享元。</p></li></ol><p><strong>适用场景</strong></p><ul><li>&#x20;仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。</li></ul><p><strong>实现方式</strong></p><ol><li><p>将需要改写为享元的类成员变量拆分为两个部分：</p><ul><li><p><strong>内在状态</strong>： 包含不变的、 可在许多对象中重复使用的数据的成员变量。</p></li><li><p><strong>外在状态</strong>： 包含每个对象各自不同的情景数据的成员变量</p></li></ul></li><li><p>保留类中表示内在状态的成员变量， 并将其属性设置为不可修改。 这些变量仅可在构造函数中获得初始数值。</p></li><li><p>找到所有使用外在状态成员变量的方法， 为在方法中所用的每个成员变量新建一个参数， 并使用该参数代替成员变量。</p></li><li><p>你可以有选择地创建工厂类来管理享元缓存池， 它负责在新建享元时检查已有的享元。 如果选择使用工厂， 客户端就只能通过工厂来请求享元， 它们需要将享元的内在状态作为参数传递给工厂。</p></li><li><p>客户端必须存储和计算外在状态 （情景） 的数值， 因为只有这样才能调用享元对象的方法。 为了使用方便， 外在状态和引用享元的成员变量可以移动到单独的情景类中。</p></li></ol><p><strong>优点</strong></p><ul><li>&#x20;如果程序中有很多相似对象， 那么你将可以节省大量内存。</li></ul><p><strong>缺点</strong></p><ul><li><p>&#x20;你可能需要牺牲执行速度来换取内存， 因为他人每次调用享元方法时都需要重新计算部分情景数据。</p></li><li><p>&#x20;代码会变得更加复杂。 团队中的新成员总是会问：  “为什么要像这样拆分一个实体的状态？”。</p></li></ul><h2 id="3-7-代理模式"><a href="#3-7-代理模式" class="headerlink" title="3.7 代理模式"></a>3.7 代理模式</h2><p><strong>代理模式</strong>是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-22.png"></p><ol><li><p><strong>服务接口</strong> （Service Interface） 声明了服务接口。 代理必须<strong>遵循该接口才能伪装成服务对象</strong>。</p></li><li><p><strong>服务</strong> （Service） 类提供了一些实用的业务逻辑。</p></li><li><p><strong>代理</strong> （Proxy） 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。</p></li></ol><p>&#x20;    通常情况下， 代理会对其服务对象的整个生命周期进行管理。</p><ul><li><strong>客户端</strong> （Client） 能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。</li></ul><p><strong>实现方式：</strong></p><ol><li><p>如果没有现成的服务接口， 你就需要创建一个接口来实现代理和服务对象的可交换性。 从服务类中抽取接口并非总是可行的， 因为你需要对服务的所有客户端进行修改， 让它们使用接口。 备选计划是将代理作为服务类的子类， 这样代理就能继承服务的所有接口了。</p></li><li><p>创建代理类， 其中必须包含一个存储<strong>指向服务的引用</strong>的成员变量。 通常情况下， 代理负责创建服务并对其整个生命周期进行管理。 在一些特殊情况下， 客户端会通过构造函数将服务传递给代理。</p></li><li><p>根据需求实现代理方法。 在大部分情况下，代理在完成一些任务后应将工作委派给服务对象。</p></li><li><p>可以考虑新建一个构建方法来判断客户端可获取的是代理还是实际服务。 你可以在代理类中创建一个简单的静态方法， 也可以创建一个完整的工厂方法。</p></li><li><p>可以考虑为服务对象实现延迟初始化。</p></li></ol><p><strong>优点：</strong></p><ul><li><p>&#x20;你可以在客户端毫无察觉的情况下控制服务对象。</p></li><li><p>&#x20;如果客户端对服务对象的生命周期没有特殊要求， 你可以对生命周期进行管理。</p></li><li><p>&#x20;即使服务对象还未准备好或不存在， 代理也可以正常工作。</p></li><li><p>&#x20;<em>开闭原则</em>。 你可以在不对服务或客户端做出修改的情况下创建新代理。</p></li></ul><p><strong>缺点：</strong></p><ul><li><p>代码可能会变得复杂， 因为需要新建许多类。</p></li><li><p>&#x20;服务响应可能会延迟。</p></li></ul><h1 id="4-行为模式"><a href="#4-行为模式" class="headerlink" title="4 行为模式"></a>4 行为模式</h1><h2 id="4-1-责任链模式"><a href="#4-1-责任链模式" class="headerlink" title="4.1 责任链模式"></a>4.1 责任链模式</h2><p><strong>责任链模式</strong>是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个<strong>处理者均可对请求进行处理</strong>， 或将其传递给链上的下个处理者。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-21.png"></p><ol><li><p><strong>处理者</strong> （Handler） 声明了<strong>所有具体处理者</strong>的通用接口。 该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法。</p></li><li><p><strong>基础处理者</strong> （Base Handler） 是一个<strong>可选</strong>的类， 你可以将所有处理者<strong>共用的</strong>样本代码放置在其中。</p></li></ol><p>&#x20;    通常情况下， 该类中定义了一个保存<strong>对于下个处理者引用的成员变量</strong>。 客户端可通过将处理者传递给上个处理者的构造函数或设定方法来创建链。 该类还可以实现默认的处理行为：确定下个处理者存在后再将请求传递给它。</p><ul><li><strong>具体处理者</strong> （Concrete Handlers） 包含处理请求的实际代码。 每个处理者接收到请求后， 都必须决定是否进行处理， 以及是否沿着链传递请求。</li></ul><p>&#x20;    处理者通常是独立且不可变的， 需要通过构造函数<strong>一次性地获得所有必要地数据。</strong></p><ul><li><strong>客户端</strong> （Client） 可根据程序逻辑一次性或者动态地生成链。 值得注意的是， 请求可发送给链上的<strong>任意一个处理者， 而非必须是第一个处理者。</strong></li></ul><h2 id="4-2-命令模式"><a href="#4-2-命令模式" class="headerlink" title="4.2 命令模式"></a>4.2 命令模式</h2><p><strong>命令模式</strong>是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-19.png"></p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-18.png"></p><ol><li><p><strong>发送者</strong> （Sender）——亦称 “触发者 （Invoker）”——类负责对请求进行初始化， 其中必须包含一个成员变量来存储对于命令对象的引用。 发送者触发命令， 而不向接收者直接发送请求。 注意，发送者并不负责创建命令对象： 它通常会通过构造函数从客户端处获得预先生成的命令。</p></li><li><p><strong>命令</strong> （Command） 接口通常仅声明一个执行命令的方法。</p></li><li><p><strong>具体命令</strong> （Concrete Commands） 会实现各种类型的请求。 具体命令自身并不完成工作， 而是会将调用委派给一个业务逻辑对象。 但为了简化代码， 这些类可以进行合并。</p></li></ol><p>&#x20;    接收对象执行方法所需的参数可以声明为具体命令的成员变量。 你可以将命令对象设为不可变， 仅允许通过构造函数对这些成员变量进行初始化。</p><ul><li><p><strong>接收者</strong> （Receiver） 类包含<strong>部分业务</strong>逻辑。 几乎任何对象都可以作为接收者。 绝大部分命令只处理如何将请求传递到接收者的细节， 接收者自己会完成实际的工作。</p></li><li><p><strong>客户端</strong> （Client） 会创建并配置具体命令对象。 客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。 此后， 生成的命令就可以与一个或多个发送者相关联了。</p></li></ul><p><strong>适用场景</strong></p><ul><li><p>如果你需要通过操作来参数化对象， 可使用命令模式。</p></li><li><p>如果你想要将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式。</p></li></ul><p><strong>优点</strong></p><ul><li><p>&#x20;<em>单一职责原则</em>。 你可以解耦触发和执行操作的类。</p></li><li><p>&#x20;<em>开闭原则</em>。 你可以在不修改已有客户端代码的情况下在程序中创建新的命令。</p></li><li><p>&#x20;你可以实现撤销和恢复功能。</p></li><li><p>&#x20;你可以实现操作的延迟执行。</p></li><li><p>&#x20;你可以将一组简单命令组合成一个复杂命令。</p></li></ul><p><strong>缺点</strong></p><ul><li>&#x20;代码可能会变得更加复杂， 因为你在发送者和接收者之间增加了一个全新的层次。</li></ul><h2 id="4-3-迭代器模式"><a href="#4-3-迭代器模式" class="headerlink" title="4.3 迭代器模式"></a>4.3 迭代器模式</h2><p><strong>迭代器模式</strong>是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-17.png"></p><ol><li><p><strong>迭代器</strong> （Iterator） 接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。</p></li><li><p><strong>具体迭代器</strong> （Concrete Iterators） 实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。</p></li><li><p><strong>集合</strong> （Collection） 接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意，返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。</p></li><li><p><strong>具体集合</strong> （Concrete Collections） 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 你可能会琢磨， 剩下的集合代码在什么地方呢？ 不用担心， 它也会在同一个类中。 只是这些细节对于实际模式来说并不重要， 所以我们将其省略了而已。</p></li><li><p><strong>客户端</strong> （Client） 通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。</p></li></ol><p>&#x20;    客户端通常不会自行创建迭代器， 而是会从集合中获取。 但在特定情况下， 客户端可以直接创建一个迭代器 （例如当客户端需要自定义特殊迭代器时）。</p><h2 id="4-4-中介者模式"><a href="#4-4-中介者模式" class="headerlink" title="4.4 中介者模式"></a>4.4 中介者模式</h2><p><strong>中介者模式</strong>是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。</p><p>如果直接在表单元素代码中实现业务逻辑， 你将很难在程序其他表单中<strong>复用</strong>这些元素类。 例如， 由于复选框类与狗狗的文本框相耦合， 所以将无法在其他表单中使用它。 你要么使用渲染资料表单时用到的所有类， 要么一个都不用。</p><p>解决方案</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-16.png"></p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20.png"></p><ol><li><p><strong>组件</strong> （Component） 是各种包含业务逻辑的类。 每个组件都有一个指向中介者的引用， 该引用被声明为中介者接口类型。 组件不知道中介者实际所属的类， 因此你可通过将其连接到不同的中介者以使其能在其他程序中复用。</p></li><li><p><strong>中介者</strong> （Mediator） 接口声明了与组件交流的方法， 但通常仅包括一个通知方法。 组件可将任意上下文 （包括自己的对象） 作为该方法的参数， 只有这样接收组件和发送者类之间才不会耦合。</p></li><li><p><strong>具体中介者</strong> （Concrete Mediator） 封装了多种组件间的关系。 具体中介者通常会保存所有组件的引用并对其进行管理， 甚至有时会对其生命周期进行管理。</p></li><li><p>组件并不知道其他组件的情况。 如果组件内发生了重要事件， 它只能通知中介者。 中介者收到通知后能轻易地确定发送者， 这或许已足以判断接下来需要触发的组件了。</p></li></ol><p>&#x20;    对于组件来说， 中介者看上去完全就是一个<strong>黑箱</strong>。 发送者不知道最终会由谁来处理自己的请求， 接收者也不知道最初是谁发出了请求。</p><p><strong>优点：</strong></p><ul><li><p>&#x20;<em>单一职责原则</em>。 你可以将多个组件间的交流抽取到同一位置， 使其更易于理解和维护。</p></li><li><p>&#x20;<em>开闭原则</em>。 你无需修改实际组件就能增加新的中介者。</p></li><li><p>&#x20;你可以减轻应用中多个组件间的耦合情况。</p></li><li><p>&#x20;你可以更方便地复用各个组件。</p></li></ul><p><strong>缺点：</strong></p><ul><li>一段时间后， 中介者可能会演化成为<a href="https://refactoringguru.cn/antipatterns/god-object"><strong>上帝对象</strong></a>。</li></ul><h2 id="4-5-备忘录模式"><a href="#4-5-备忘录模式" class="headerlink" title="4.5 备忘录模式"></a>4.5 备忘录模式</h2><p><strong>备忘录模式</strong>是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-15.png"></p><ol><li><p>这种实现方式允许存在多种不同类型的原发器和备忘录。 每种原发器都和其相应的备忘录类进行交互。 原发器和备忘录都不会将其状态暴露给其他类。</p></li><li><p>负责人此时被明确禁止修改存储在备忘录中的状态。 但负责人类将独立于原发器， 因为此时恢复方法被定义在了备忘录类中。</p></li><li><p>每个备忘录将与创建了自身的原发器连接。 原发器会将自己及状态传递给备忘录的构造函数。 由于这些类之间的紧密联系， 只要原发器定义了合适的设置器 （setter）， 备忘录就能恢复其状态。</p></li></ol><h2 id="4-6-观察者模式"><a href="#4-6-观察者模式" class="headerlink" title="4.6 观察者模式"></a>4.6 观察者模式</h2><p><strong>观察者模式</strong>是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-36.png"></p><ol><li><p><strong>发布者</strong> （Publisher）会向其他对象发送值得关注的事件。 事件会在发布者自身状态改变或执行特定行为后发生。 发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。</p></li><li><p>当新事件发生时， 发送者会<strong>遍历订阅列表</strong>并调用每个订阅者对象的通知方法。 该方法是在订阅者接口中声明的。</p></li><li><p><strong>订阅者</strong> （Subscriber）接口声明了通知接口。 在绝大多数情况下， 该接口仅包含一个 <code>update</code>更新方法。 该方法可以拥有多个参数， 使发布者能在更新时传递事件的详细信息。</p></li><li><p><strong>具体订阅者</strong>（Concrete Subscribers）可以执行一些操作来回应发布者的通知。所有具体订阅者类都实现了同样的接口， 因此发布者不需要与具体类相耦合。</p></li><li><p>订阅者通常需要一些上下文信息来正确地处理更新。 因此，发布者通常会将一些上下文数据作为通知方法的参数进行传递。发布者也可将自身作为参数进行传递， 使订阅者直接获取所需的数据。</p></li><li><p><strong>客户端</strong>（Client）会分别创建发布者和订阅者对象，然后为订阅者注册发布者更新。</p></li></ol><h2 id="4-7-状态模式"><a href="#4-7-状态模式" class="headerlink" title="4.7 状态模式"></a>4.7 状态模式</h2><p><strong>状态模式</strong>是一种行为设计模式， 让你能在一个对象的<strong>内部状态变化时改变其行为</strong>， 使其看上去就像改变了自身所属的类一样。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-34.png"></p><ol><li><p><strong>上下文</strong> （Context） 保存了对于一个具体状态对象的引用，并会将所有与该状态相关的工作委派给它。上下文通过状态接口与状态对象交互，且会提供一个设置器用于传递新的状态对象。</p></li><li><p><strong>状态</strong> （State） 接口会声明特定于状态的方法。 这些方法应能被其他所有具体状态所理解，因为你不希望某些状态所拥有的方法永远不会被调用。</p></li><li><p><strong>具体状态</strong> （Concrete States） 会自行实现特定于状态的方法。 为了避免多个状态中包含相似代码，你可以提供一个封装有部分通用行为的中间抽象类。</p></li></ol><p>&#x20;    状态对象可存储对于上下文对象的<strong>反向引用</strong>。状态可以通过该引用从上下文处获取所需信息，并且能触发状态转移。</p><ul><li>上下文和具体状态都可以设置上下文的下个状态，并可通过替换连接到上下文的状态对象来完成实际的状态转换。</li></ul><p><strong>优点：</strong></p><ul><li><p><em>单一职责原则</em>。 将与特定状态相关的代码放在单独的类中。</p></li><li><p><em>开闭原则</em>。 无需修改已有状态类和上下文就能引入新状态。</p></li><li><p>通过消除臃肿的状态机条件语句简化上下文代码。</p></li></ul><p><strong>缺点：</strong></p><ul><li>如果状态机只有很少的几个状态， 或者很少发生改变， 那么应用该模式可能会显得小题大作。</li></ul><p><strong>比较：</strong></p><ul><li>在<strong>状态模式</strong>中， 特定状态知道其他所有状态的存在， 且能触发从一个状态到另一个状态的转换； <strong>策略</strong>则几乎完全不知道其他策略的存在。</li></ul><h2 id="4-8-策略模式"><a href="#4-8-策略模式" class="headerlink" title="4.8 策略模式"></a>4.8 策略模式</h2><p><strong>策略模式</strong>是一种行为设计模式， 它能让你定义一系列算法， 并将<strong>每种算法分别放入独立的类</strong>中， 以使<strong>算法的对象</strong>能够<strong>相互替换</strong>。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-33.png"></p><p>&#x20;      在导游应用中， 每个路线规划算法都可被抽取到只有一个 <code>build­Route</code>生成路线方法的独立类中。该方法接收起点和终点作为参数， 并返回路线中途点的集合。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-32.png"></p><ol><li><p><strong>上下文</strong> （Context） 维护指向具体策略的引用， 且仅通过策略接口与该对象进行交流。</p></li><li><p><strong>策略</strong> （Strategy） 接口是所有具体策略的通用接口， 它声明了一个上下文用于执行策略的方法。</p></li><li><p><strong>具体策略</strong> （Concrete Strategies） 实现了上下文所用算法的各种不同变体。</p></li><li><p>当上下文需要运行算法时， 它会在其已连接的策略对象上调用执行方法。 上下文不清楚其所涉及的策略类型与算法的执行方式。</p></li><li><p><strong>客户端</strong> （Client） 会创建一个特定策略对象并将其传递给上下文。 上下文则会提供一个设置器以便客户端在运行时替换相关联的策略。</p></li></ol><h2 id="4-9-模版方法模式"><a href="#4-9-模版方法模式" class="headerlink" title="4.9 模版方法模式"></a>4.9 模版方法模式</h2><p><strong>模板方法模式</strong>是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许<strong>子类</strong>在<strong>不修改结构的情况下</strong>重写算法的特定步骤。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-35.png"></p><ol><li><p><strong>抽象类</strong> （Abstract­Class） 会声明作为<strong>算法步骤</strong>的方法， 以及<strong>依次调用</strong>它们的实际模板方法。 算法步骤可以被声明为 <code>抽象</code>类型， 也可以提供一些默认实现。</p></li><li><p><strong>具体类</strong> （Concrete­Class） 可以重写所有步骤， 但不能重写模板方法自身。</p></li></ol><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-31.png"></p><p><strong>适用场景：</strong></p><ul><li><p>当你只希望客户端扩展某个特定算法步骤， 而不是整个算法或其结构时， 可使用模板方法模式。</p></li><li><p>当多个类的算法除一些细微不同之外几乎完全一样时， 你可使用该模式。 但其后果就是， 只要算法发生变化， 你就可能需要修改所有的类。</p></li></ul><h2 id="4-10-访问者模式"><a href="#4-10-访问者模式" class="headerlink" title="4.10 访问者模式"></a>4.10 访问者模式</h2><p><strong>访问者模式</strong>是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。</p><p>访问者模式建议将新行为放入一个名为<em>访问者</em>的独立类中， 而不是试图将其整合到已有类中。 <strong>需要执行操作的原始对象</strong>将<strong>作为参数</strong>被传递给访问者中的方法， 让方法能访问对象所包含的一切必要数据。</p><p><img src="/2024/12/26/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-30.png"></p><ol><li><p><strong>访问者</strong> （Visitor） 接口声明了一系列以对象结构的具体元素为参数的访问者方法。 如果编程语言支持重载， 这些方法的名称可以是相同的， 但是其参数一定是不同的。</p></li><li><p><strong>具体访问者</strong> （Concrete Visitor） 会为不同的具体元素类实现相同行为的几个不同版本。</p></li><li><p><strong>元素</strong> （Element） 接口声明了一个方法来 “接收” 访问者。 该方法必须有一个参数被声明为访问者接口类型。</p></li><li><p><strong>具体元素</strong> （Concrete Element） 必须实现接收方法。 该方法的目的是根据当前元素类将其调用重定向到相应访问者的方法。 请注意， 即使元素基类实现了该方法， 所有子类都必须对其进行重写并调用访问者对象中的合适方法。</p></li><li><p><strong>客户端</strong> （Client） 通常会作为集合或其他复杂对象 （例如一个<a href="https://refactoringguru.cn/design-patterns/composite"><strong>组合</strong></a>树） 的代表。 客户端通常不知晓所有的具体元素类， 因为它们会通过抽象接口与集合中的对象进行交互。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 大学课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言期中复习</title>
      <link href="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/"/>
      <url>/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="2-R基础语法"><a href="#2-R基础语法" class="headerlink" title="2 R基础语法"></a>2 R基础语法</h1><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/1.png" alt="img"></p><h2 id="2-1-vector"><a href="#2-1-vector" class="headerlink" title="2.1 vector"></a>2.1 vector</h2><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/2.png" alt="img"></p><h3 id="2-1-1-排除元素"><a href="#2-1-1-排除元素" class="headerlink" title="2.1.1 排除元素"></a>2.1.1 排除元素</h3><p>使用负索引</p><p>暂时无法在飞书文档外展示此内容</p><h3 id="2-1-2-提取满足条件的元素"><a href="#2-1-2-提取满足条件的元素" class="headerlink" title="2.1.2 提取满足条件的元素"></a><strong>2.1.2 提取满足条件的元素</strong></h3><p>可以使用逻辑条件（如 <code>==</code>、<code>&lt;</code>、<code>&gt;</code> 等）来筛选元素。</p><p>暂时无法在飞书文档外展示此内容</p><h3 id="2-1-3-which-函数"><a href="#2-1-3-which-函数" class="headerlink" title="2.1.3**which()** 函数"></a>2.1.3**<code>which()</code>** <strong>函数</strong></h3><p><code>which()</code> 函数用于返回满足条件的元素的下标索引。它返回的是逻辑条件为 <code>TRUE</code> 的元素的索引位置。</p><p><strong>示例：找到大于30的元素的下标</strong></p><p>暂时无法在飞书文档外展示此内容</p><p><strong>输出：</strong></p><p>暂时无法在飞书文档外展示此内容</p><p><code>which(vec &gt; 30)</code> 返回的是大于30的元素的下标位置，即第4个和第5个元素。</p><h3 id="2-1-4-which-min-和-which-max-函数"><a href="#2-1-4-which-min-和-which-max-函数" class="headerlink" title="2.1.4 which.min() 和 which.max() 函数"></a>2.1.4 <strong><code>which.min()</code></strong> <strong>和</strong> <strong><code>which.max()</code></strong> <strong>函数</strong></h3><ul><li><code>which.min()</code>：返回向量中最小值的下标。</li><li><code>which.max()</code>：返回向量中最大值的下标。</li></ul><p><strong>示例：找到最小值和最大值的下标</strong></p><p>暂时无法在飞书文档外展示此内容</p><p><strong>输出：</strong></p><p>暂时无法在飞书文档外展示此内容</p><p>在这个例子中，<code>which.min(vec)</code> 返回最小值 <code>10</code> 的下标 <code>1</code>，而 <code>which.max(vec)</code> 返回最大值 <code>50</code> 的下标 <code>5</code>。</p><h3 id="2-1-5-向量运算"><a href="#2-1-5-向量运算" class="headerlink" title="2.1.5 向量运算"></a>2.1.5 向量运算</h3><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/3.png" alt="img"></p><h2 id="2-2-数组"><a href="#2-2-数组" class="headerlink" title="2.2 数组"></a>2.2 数组</h2><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/4.png" alt="img"></p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/5.png" alt="img"></p><h2 id="2-3-Matrices"><a href="#2-3-Matrices" class="headerlink" title="2.3 Matrices"></a>2.3 Matrices</h2><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/6.png" alt="img"></p><p>默认是by col</p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/7.png" alt="img"></p><p>A[c(1,3), c(2,4)]</p><ul><li><code>c(1,3)</code> 选择了矩阵的第1行和第3行。</li><li><code>c(2,4)</code> 选择了矩阵的第2列和第4列。</li></ul><p>他们形成一个新的矩阵。</p><p>矩阵融合</p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/8.png" alt="img"></p><h2 id="2-4-data-frame"><a href="#2-4-data-frame" class="headerlink" title="2.4 data_frame"></a>2.4 data_frame</h2><h3 id="2-4-1-merge"><a href="#2-4-1-merge" class="headerlink" title="2.4.1 merge()"></a>2.4.1 merge()</h3><p><strong>示例：</strong></p><p>暂时无法在飞书文档外展示此内容</p><p>输出：</p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/9.png" alt="img"></p><h3 id="2-4-2-aggregate"><a href="#2-4-2-aggregate" class="headerlink" title="2.4.2 aggregate()"></a>2.4.2 aggregate()</h3><p><code>aggregate()</code> 用于对数据进行分组汇总（例如求和、平均、计数等），类似于 SQL 中的 <code>GROUP BY</code>。</p><p>暂时无法在飞书文档外展示此内容</p><ul><li><code>x</code>：要汇总的数据。可以是数据框的列，也可以是一个数据框。</li><li><code>by</code>：分组的变量，通常是一个列或由多个列组成的列表。</li><li><code>FUN</code>：用于汇总数据的函数（如 <code>sum()</code>、<code>mean()</code>、<code>median()</code> 等）。</li><li><code>...</code>：其他参数，可以传递给 <code>FUN</code>。</li></ul><p>实例:</p><p>暂时无法在飞书文档外展示此内容</p><p>在 R 语言中，<code>Score ~ Name</code> 是一种公式（formula）写法，用于指定变量之间的关系，通常用于统计建模和数据操作。公式形式为 <code>y ~ x</code>，表示 <code>y</code> 是因变量（目标变量），<code>x</code> 是自变量（预测变量）。</p><p>因此，<code>Score ~ Name</code>：表示我们将 <code>Score</code> 列按 <code>Name</code> 列进行分组。</p><h3 id="2-4-3-stack"><a href="#2-4-3-stack" class="headerlink" title="2.4.3 stack()"></a>2.4.3 stack()</h3><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/10.png" alt="img"></p><h2 id="2-5-Lists"><a href="#2-5-Lists" class="headerlink" title="2.5 Lists"></a>2.5 Lists</h2><p>能包含所有类型</p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/11.png" alt="img"></p><h2 id="2-6-Data-Types"><a href="#2-6-Data-Types" class="headerlink" title="2.6 Data Types"></a>2.6 Data Types</h2><p>• Logical – True&#x2F;False </p><p>• Integer – 4, 6, 2 </p><p>• Numeric – 3.4, 566, 2.34 </p><p>• Character – “a”, “hello” </p><p>• Factor – “Female”, “Male” </p><p>• Date &amp; Times – “2021-09-15”, “ 2021-09-15 13:30:00”</p><h2 id="2-7-Character-String-Split"><a href="#2-7-Character-String-Split" class="headerlink" title="2.7 Character&amp;String Split"></a>2.7 Character&amp;String Split</h2><p>nchar(),substring(),paste(),regexpr(),grep(),blob2rx(),gsub()</p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/12.png" alt="img"></p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/13.png" alt="img"></p><h2 id="2-8-factor"><a href="#2-8-factor" class="headerlink" title="2.8 factor"></a>2.8 factor</h2><h3 id="2-8-1-名义型，有序型"><a href="#2-8-1-名义型，有序型" class="headerlink" title="2.8.1 名义型，有序型"></a>2.8.1 名义型，有序型</h3><ul><li><strong>名义型</strong>变量是没有顺序之分的类别变量。下表中，糖尿病类型Diabetes（Type1、 Type2）是名义型变量的一例。即使在数据中Type1编码为1而Type2编码为2，这 也并不意味着二者是有序的。 </li><li><strong>有序型</strong>变量表示一种顺序关系，而非数量关系。病情Status（poor, improved,  excellent）是顺序型变量的典型示例。我们知道，病情为poor（较差）病人的 状态不如improved（病情好转）的病人，但并不知道相差多少。</li></ul><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/14.png" alt="img"></p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/15.png" alt="img"></p><h3 id="2-8-2-将连续数据转化为分类变量-factors"><a href="#2-8-2-将连续数据转化为分类变量-factors" class="headerlink" title="2.8.2 将连续数据转化为分类变量(factors)"></a>2.8.2 将连续数据转化为分类变量(factors)</h3><ul><li>cut()</li></ul><p>假设我们有一个包含连续数值的向量 <code>x</code></p><p>暂时无法在飞书文档外展示此内容</p><p>暂时无法在飞书文档外展示此内容</p><ol><li><strong>最小值</strong>：<code>min(x)</code> &#x3D; 5</li><li><strong>最大值</strong>：<code>max(x)</code> &#x3D; 35</li><li><strong>区间宽度</strong>： <code>(35 - 5) / 3 = 10</code></li></ol><p>基于这些计算，<code>cut()</code> 会将 <code>x</code> 划分为以下三个区间：</p><ul><li>第一个区间：<code>(5, 15]</code>（包含 15）</li><li>第二个区间：<code>(15, 25]</code>（包含 25）</li><li>第三个区间：<code>(25, 35]</code>（包含 35）</li></ul><p>暂时无法在飞书文档外展示此内容</p><h2 id="2-9-operation"><a href="#2-9-operation" class="headerlink" title="2.9 operation"></a>2.9 operation</h2><h3 id="2-9-1-运算符号"><a href="#2-9-1-运算符号" class="headerlink" title="2.9.1 运算符号"></a>2.9.1 运算符号</h3><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/16.png" alt="img"></p><h3 id="2-9-2-Regular-Convert-Operation"><a href="#2-9-2-Regular-Convert-Operation" class="headerlink" title="2.9.2 Regular&amp;Convert Operation"></a>2.9.2 Regular&amp;Convert Operation</h3><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/17.png" alt="img"></p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/18.png" alt="img"></p><h3 id="2-9-3-repicate"><a href="#2-9-3-repicate" class="headerlink" title="2.9.3 repicate()"></a>2.9.3 repicate()</h3><p>暂时无法在飞书文档外展示此内容</p><ul><li><strong>n</strong>: 要重复的次数。</li><li><strong>expr</strong>: 需要重复执行的表达式或者函数调用。</li><li><strong>simplify</strong>: 一个逻辑值，控制返回值的简化方式。默认为 <code>TRUE</code>，表示如果可能将结果简化为一个数组或向量；如果是 <code>FALSE</code>，则返回一个列表。</li></ul><h2 id="2-10-condition-loop"><a href="#2-10-condition-loop" class="headerlink" title="2.10 condition&amp;loop"></a>2.10 condition&amp;loop</h2><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/19.png" alt="img"></p><h1 id="3-数据可视化"><a href="#3-数据可视化" class="headerlink" title="3 数据可视化"></a>3 数据可视化</h1><h2 id="3-1-数据摘要"><a href="#3-1-数据摘要" class="headerlink" title="3.1 数据摘要"></a>3.1 数据摘要</h2><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/20.png" alt="img"><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/21.png" alt="img"></p><h2 id="3-2-箱线图"><a href="#3-2-箱线图" class="headerlink" title="3.2 箱线图"></a>3.2 箱线图</h2><p>在 R 中，使用 <code>boxplot()</code> 函数可以绘制箱线图。</p><p><strong>示例 1：绘制单一变量的箱线图</strong></p><p>假设我们有一个数据向量 <code>x</code>，想绘制它的箱线图：</p><p>暂时无法在飞书文档外展示此内容</p><p><strong>示例 2：多个变量的箱线图</strong></p><p>如果你有一个数据框 <code>df</code>，包含多个变量，想要同时绘制多个变量的箱线图：</p><p>暂时无法在飞书文档外展示此内容</p><p><strong>示例 3：分组绘制箱线图</strong></p><p>如果你有分组变量（例如分类变量），并且想要绘制各组的箱线图，可以使用 <code>boxplot()</code> 中的分组参数。例如，假设你有一个分组变量 <code>group</code>：</p><p>暂时无法在飞书文档外展示此内容</p><p><strong>解释箱线图的优势</strong></p><ol><li><strong>展示分布形态</strong>：箱线图直观地展示了数据的对称性和偏态。例如，如果中位数接近箱体的中心，且上下四分位数差不多，说明数据比较对称；如果中位数偏向箱体的一端，说明数据偏态。</li><li><strong>发现离群点</strong>：离群点在箱线图中表现为图外的小点，能帮助我们识别可能的异常值。</li><li><strong>对比不同组</strong>：通过多个箱线图的对比，我们可以直观地比较不同组的分布情况。</li></ol><h2 id="3-3-直方图"><a href="#3-3-直方图" class="headerlink" title="3.3 直方图"></a>3.3 直方图</h2><p>在 R 中，使用 <code>boxplot()</code> 函数可以绘制箱线图。</p><p><strong>示例 1：绘制单一变量的箱线图</strong></p><p>假设我们有一个数据向量 <code>x</code>，想绘制它的箱线图：</p><p>暂时无法在飞书文档外展示此内容</p><p><strong>示例 2：多个变量的箱线图</strong></p><p>如果你有一个数据框 <code>df</code>，包含多个变量，想要同时绘制多个变量的箱线图：</p><p>暂时无法在飞书文档外展示此内容</p><p><strong>示例 3：分组绘制箱线图</strong></p><p>如果你有分组变量（例如分类变量），并且想要绘制各组的箱线图，可以使用 <code>boxplot()</code> 中的分组参数。例如，假设你有一个分组变量 <code>group</code>：</p><p>暂时无法在飞书文档外展示此内容</p><p><strong>直方图的应用场景</strong></p><ol><li><strong>数据分布分析</strong>：直方图帮助我们了解数据的分布类型（如正态分布、偏态分布等）。</li><li><strong>检测异常值</strong>：通过观察数据的分布，我们可以识别是否存在异常值（如数据的尾部异常偏离）。</li><li><strong>选择合适的模型</strong>：直方图可以帮助我们判断数据是否符合某种统计模型（例如正态分布），从而选择合适的分析方法或假设检验。</li></ol><h2 id="3-4-plot和ggplot"><a href="#3-4-plot和ggplot" class="headerlink" title="3.4 plot和ggplot"></a>3.4 plot和ggplot</h2><h1 id="4-数据预处理"><a href="#4-数据预处理" class="headerlink" title="4 数据预处理"></a>4 数据预处理</h1><h2 id="4-1-数据过滤"><a href="#4-1-数据过滤" class="headerlink" title="4.1 数据过滤"></a>4.1 数据过滤</h2><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/22.png" alt="img"></p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/23.png" alt="img"></p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/24.png" alt="img"></p><h2 id="4-2-缺失值处理"><a href="#4-2-缺失值处理" class="headerlink" title="4.2 缺失值处理"></a>4.2 缺失值处理</h2><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/25.png" alt="img"></p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/26.png" alt="img"></p><h2 id="4-3-异常值检测"><a href="#4-3-异常值检测" class="headerlink" title="4.3 异常值检测"></a>4.3 异常值检测</h2><h2 id="4-4-数据去重"><a href="#4-4-数据去重" class="headerlink" title="4.4 数据去重"></a>4.4 数据去重</h2><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/27.png" alt="img"></p><ul><li>duplicated()</li></ul><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/28.png" alt="img"></p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/29.png" alt="img"></p><ul><li>Unique</li></ul><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/30.png" alt="img"></p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/31.png" alt="img"></p><h2 id="4-5-数据规范"><a href="#4-5-数据规范" class="headerlink" title="4.5 数据规范"></a>4.5 数据规范</h2><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/32.png" alt="img"></p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/33.png" alt="img"></p><h2 id="4-6-数据采样"><a href="#4-6-数据采样" class="headerlink" title="4.6 数据采样"></a>4.6 数据采样</h2><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/34.png" alt="img"></p><h2 id="4-7-数据排序"><a href="#4-7-数据排序" class="headerlink" title="4.7 数据排序"></a>4.7 数据排序</h2><p>sort()</p><p>暂时无法在飞书文档外展示此内容</p><h2 id="4-8-数据向量化"><a href="#4-8-数据向量化" class="headerlink" title="4.8 数据向量化"></a>4.8 数据向量化</h2><ul><li>as.vector()</li></ul><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/35.png" alt="img"></p><ul><li>Unlist()</li></ul><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/37.png" alt="img"></p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/36.png" alt="img"></p><h2 id="4-9-列联表"><a href="#4-9-列联表" class="headerlink" title="4.9 列联表"></a>4.9 列联表</h2><ul><li>Table</li></ul><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/38.png" alt="img"></p><h2 id="4-10-分组汇总"><a href="#4-10-分组汇总" class="headerlink" title="4.10 分组汇总"></a>4.10 分组汇总</h2><p>用法</p><p>暂时无法在飞书文档外展示此内容</p><ul><li><code>formula</code>：一个公式，通常的形式是 <code>response ~ group</code>，其中 <code>response</code> 是你想要聚合的变量（因变量），<code>group</code> 是分组的变量（自变量）。例如，<code>y ~ x</code> 表示按 <code>x</code> 分组，对 <code>y</code> 进行聚合。</li><li><code>data</code>：一个数据框，包含要进行聚合的变量。</li><li><code>FUN</code>：聚合函数，表示对每个组要应用的函数，例如 <code>sum</code>（求和）、<code>mean</code>（求平均值）、<code>median</code>（求中位数）等。</li><li><code>...</code>：其他可选参数，传递给聚合函数。</li></ul><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/39.png" alt="img"></p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/40.png" alt="img"></p><h1 id="5-数据分布拟合"><a href="#5-数据分布拟合" class="headerlink" title="5 数据分布拟合"></a>5 数据分布拟合</h1><h2 id="5-1-正态分布"><a href="#5-1-正态分布" class="headerlink" title="5.1 正态分布"></a>5.1 正态分布</h2><ul><li>rnorm()</li><li>**<code>p</code>**：累积分布函数（CDF），计算 P(X ≤ x)。</li><li>**<code>d</code>**：概率密度函数（PDF），计算概率密度。</li><li>**<code>q</code>**：分位数函数，计算给定概率对应的分位数。</li><li>**<code>r</code>**：随机数生成函数，生成符合某种分布的随机数。</li></ul><p>在R中，<code>p</code>、<code>d</code>、<code>q</code> 和 <code>r</code> 是正态分布相关函数的常用前缀，它们分别对应不同的功能。这些函数用于处理与概率分布（如正态分布）相关的常见任务。具体来说，<code>p</code>、<code>d</code>、<code>q</code> 和 <code>r</code> 代表：</p><p><strong>1.</strong> <strong><code>p</code></strong> <strong>累积分布函数（CDF）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p 函数计算的是一个给定数值或一组数值的累计概率。它返回的是 `**`P(X ≤ x)`**`，即随机变量小于或等于某个值的概率。</span><br></pre></td></tr></table></figure><p><strong>示例：<code>pnorm()</code></strong></p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/41.png" alt="img"></p><p><strong>2.</strong> <strong><code>d</code></strong> <strong>概率密度函数（PDF）</strong></p><p><code>d</code> 函数计算的是 <strong>在某个点的概率密度</strong>，即随机变量取特定值的“概率”。对于连续分布，这个“概率”实际上是密度，表示该点附近的概率区间的大小。</p><p><strong>示例：<code>dnorm()</code>（正态分布的PDF）</strong></p><p>我们计算标准正态分布下 <code>X = 0</code> 的概率密度：</p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/42.png" alt="img"></p><p><strong>3.</strong> <strong><code>q</code></strong> <strong>分位数函数（逆CDF）</strong></p><p><code>q</code> 函数计算的是给定累计概率对应的值，也就是反向操作。你输入的是概率，输出的是对应的分位数（例如 Z 值）。</p><p><strong>示例：<code>qnorm()</code>（正态分布的分位数函数）</strong></p><p>我们想知道在标准正态分布下，累计概率为 0.95 对应的 Z 值是多少。</p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/44.png" alt="img"></p><p><strong>4.</strong> <strong><code>r</code></strong> <strong>随机数生成函数</strong></p><p><code>r</code> 用于生成符合某种分布的随机数。例如，<code>rnorm()</code> 用于生成正态分布的随机数。</p><p><strong>示例：<code>rnorm()</code></strong></p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/45.png" alt="img"></p><h2 id="5-2-二项分布"><a href="#5-2-二项分布" class="headerlink" title="5.2 二项分布"></a>5.2 二项分布</h2><ol><li><strong><code>dbinom()</code></strong> — 二项分布的概率质量函数 (PMF)</li></ol><p><code>dbinom()</code> 用于计算给定参数下，二项分布的某个具体值的概率。</p><p>语法：</p><p>暂时无法在飞书文档外展示此内容</p><ul><li><strong>x</strong>：需要计算概率的值（可能的成功次数）。</li><li><strong>size</strong>：试验的次数（例如，总共进行多少次独立实验）。</li><li><strong>prob</strong>：每次试验中成功的概率。</li></ul><p>示例：</p><p>假设我们进行 10 次独立试验，每次试验成功的概率是 0.3，想知道恰好有 3 次成功的概率是多少：</p><p>暂时无法在飞书文档外展示此内容</p><p>这个函数会返回二项分布中，10 次试验中恰好 3 次成功的概率。</p><ol start="2"><li><strong><code>pbinom()</code></strong> — 二项分布的累积分布函数 (CDF)</li></ol><p><code>pbinom()</code> 用于计算在二项分布中，某个值 <strong>x</strong> 或更小的事件发生的累积概率。</p><p>语法：</p><p>暂时无法在飞书文档外展示此内容</p><ul><li><strong>q</strong>：累积概率对应的值（例如，累计的成功次数）。</li><li><strong>size</strong>：试验的次数。</li><li><strong>prob</strong>：每次试验中成功的概率。</li></ul><p>示例：</p><p>如果我们进行 10 次试验，每次成功的概率是 0.3，想知道成功次数小于或等于 3 次的概率是多少：</p><p>暂时无法在飞书文档外展示此内容</p><p>这个函数会返回成功次数小于或等于 3 次的累积概率。</p><ol start="3"><li><strong><code>qbinom()</code></strong> — 二项分布的分位数函数</li></ol><p><code>qbinom()</code> 用于计算给定概率下的分位数，即返回一个值，这个值表示在给定的累积概率下可能的最大成功次数。</p><p>语法：</p><p>暂时无法在飞书文档外展示此内容</p><ul><li><strong>p</strong>：累积概率（例如，0.95 表示 95% 的概率）。</li><li><strong>size</strong>：试验次数。</li><li><strong>prob</strong>：每次试验中成功的概率。</li></ul><p>示例：</p><p>假设我们进行 10 次试验，每次试验成功的概率是 0.3，想知道，累积概率达到 0.8 时，最大成功次数是多少：</p><p>暂时无法在飞书文档外展示此内容</p><p>这个函数会返回当累积概率为 0.8 时，最大成功次数的分位数。</p><p>例子：完整示范</p><p>假设我们进行 20 次独立试验，每次试验成功的概率是 0.4，下面是如何使用这三个函数的示例：</p><p>暂时无法在飞书文档外展示此内容</p><p>例题：</p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/46.png" alt="img"></p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/47.png" alt="img"></p><h2 id="5-3-泊松分布"><a href="#5-3-泊松分布" class="headerlink" title="5.3 泊松分布"></a>5.3 泊松分布</h2><p><strong>示例 1：计算单位时间内发生特定次数事件的概率</strong></p><p>假设某个区域内每小时平均发生 3 次事故，我们想知道在该区域内 1 小时内恰好发生 2 次事故的概率是多少：</p><p>暂时无法在飞书文档外展示此内容</p><p><strong>示例 2：计算单位时间内发生最多 2 次事故的累积概率</strong></p><p>继续上面的例子，计算单位时间内发生 <strong>最多</strong> 2 次事故的概率：</p><p>暂时无法在飞书文档外展示此内容</p><p><strong>示例 3：确定累积概率为 0.95 时最多发生的事故次数</strong></p><p>假设每小时平均发生 3 次事故，计算当累积概率为 0.95 时，最多会发生多少次事故：</p><p>暂时无法在飞书文档外展示此内容</p><p><strong>示例 4：从泊松分布中生成随机数</strong></p><p>生成 5 个符合泊松分布的随机事故次数（假设每小时平均发生 3 次事故）：</p><p>暂时无法在飞书文档外展示此内容</p><h2 id="5-4-几何分布"><a href="#5-4-几何分布" class="headerlink" title="5.4 几何分布"></a>5.4 几何分布</h2><p><strong>用来描述在一系列独立的伯努利试验中，直到第一次成功出现之前失败的次数。</strong></p><p>对于某射击测试，可以最多射击10次，射中8环以上就算通过， 如果某学生每次射击击中8环以上的概率为0.2，每次射击之间互 不影响 </p><p>• 请问该学生第1次通过测试的概率为多少？ </p><p>• 请问该学生第10次才通过测试的概率为多少？ </p><p>• 请问该学生无法通过测试的概率为多少？</p><p>暂时无法在飞书文档外展示此内容</p><h2 id="5-5-负二项分布"><a href="#5-5-负二项分布" class="headerlink" title="5.5 负二项分布"></a>5.5 负二项分布</h2><p><strong>求解r次成功需要的实验次数x的概率</strong></p><p><strong>语法：</strong></p><p>暂时无法在飞书文档外展示此内容</p><ul><li><code>x</code>: 失败次数（或事件次数，非负整数）。</li><li><code>size</code>: 所需成功次数。</li><li><code>prob</code>: 每次试验成功的概率。</li></ul><p><strong>示例：</strong></p><p>假设我们想计算在进行 10 次试验之前，成功 3 次，失败次数为 5 的概率。设成功概率为 0.4：</p><p>暂时无法在飞书文档外展示此内容</p><p>这个例子会返回得到 5 次失败，且在 3 次成功之前的概率。</p><p><strong>2.</strong> <strong>pnbinom: 计算负二项分布的累积分布函数（CDF）</strong></p><p><code>pnbinom</code> 函数用于计算负二项分布的累积分布函数（CDF），即计算小于或等于给定失败次数的累计概率。</p><p><strong>语法：</strong></p><p>暂时无法在飞书文档外展示此内容</p><ul><li><code>q</code>: 失败次数（或事件次数，非负整数）。</li><li><code>size</code>: 所需成功次数。</li><li><code>prob</code>: 每次试验成功的概率。</li></ul><p><strong>示例：</strong></p><p>如果我们想知道，在进行 3 次成功之前，失败次数小于或等于 5 次的累计概率，可以使用：</p><p>暂时无法在飞书文档外展示此内容</p><p>这个函数会返回累计概率，即失败次数小于等于 5 时的总概率。</p><p><strong>3.</strong> <strong>qnbinom: 计算负二项分布的分位数函数（逆CDF）</strong></p><p><code>qnbinom</code> 函数用于根据给定的累积概率，反向计算对应的失败次数。换句话说，它可以根据概率值查找对应的失败次数（或事件发生次数）。</p><p><strong>语法：</strong></p><p>暂时无法在飞书文档外展示此内容</p><ul><li><code>p</code>: 累积概率（0 到 1 之间的数值）。</li><li><code>size</code>: 所需成功次数。</li><li><code>prob</code>: 每次试验成功的概率。</li></ul><p><strong>示例：</strong></p><p>如果我们知道，累计概率为 0.7，并且成功次数为 3，我们想要找出对应的失败次数：</p><p>暂时无法在飞书文档外展示此内容</p><p>这个例子会返回在 3 次成功之前，失败次数对应的第一个分位数。</p><p><strong>4.</strong> <strong>rnbinom: 生成负二项分布的随机数</strong></p><p><code>rnbinom</code> 函数用于根据指定的参数生成负二项分布的随机样本。可以用于模拟负二项分布的样本。</p><p><strong>语法：</strong></p><p>暂时无法在飞书文档外展示此内容</p><ul><li><code>n</code>: 生成的随机数的个数。</li><li><code>size</code>: 所需成功次数。</li><li><code>prob</code>: 每次试验成功的概率。</li></ul><p><strong>示例：</strong></p><p>如果我们想生成 10 个样本，表示在 3 次成功之前的失败次数，且每次试验成功的概率为 0.4：</p><p>暂时无法在飞书文档外展示此内容</p><p>这个例子将生成 10 个符合负二项分布的随机样本，表示在进行 3 次成功之前的失败次数。</p><h2 id="5-6-指数分布"><a href="#5-6-指数分布" class="headerlink" title="5.6 指数分布"></a>5.6 指数分布</h2><p><strong>随机变量X：一段时间内事件发生的时间间隔 1个参数：事件平均发生的频次</strong></p><p><strong>1.</strong> <strong>dexp: 计算指数分布的概率密度函数（PDF）</strong></p><p><code>dexp</code> 函数用于计算给定值下的概率密度函数值，即在特定时间点（或值）处，事件发生的概率密度。</p><p><strong>语法：</strong></p><p>暂时无法在飞书文档外展示此内容</p><ul><li><code>x</code>: 事件发生时间或间隔，必须为非负数。</li><li><code>rate</code>: 事件的发生率参数，默认为 1。它是分布的反参数，通常等于 1&#x2F;平均等待时间。</li></ul><p><strong>示例：</strong></p><p>假设事件发生的平均时间间隔是 2，计算在时间 3 处的概率密度：</p><p>暂时无法在飞书文档外展示此内容</p><p>这个例子返回在时间 3 处的概率密度值。</p><p><strong>2.</strong> <strong>pexp: 计算指数分布的累积分布函数（CDF）</strong></p><p><code>pexp</code> 函数用于计算指数分布的累积分布函数值，即计算随机变量小于或等于给定值时的累积概率。</p><p><strong>语法：</strong></p><p>暂时无法在飞书文档外展示此内容</p><ul><li><code>q</code>: 给定的时间或间隔，必须为非负数。</li><li><code>rate</code>: 事件发生率，默认为 1。</li></ul><p><strong>示例：</strong></p><p>假设事件发生的平均间隔时间是 2，计算在时间 3 之前发生事件的累计概率：</p><p>暂时无法在飞书文档外展示此内容</p><p>这个例子会返回在时间 3 之前发生事件的概率。</p><p><strong>3.</strong> <strong>qexp: 计算指数分布的分位数函数（逆CDF）</strong></p><p><code>qexp</code> 函数用于根据给定的累积概率，反向计算对应的时间或间隔值。也就是说，给定一个累积概率，它会告诉你事件发生的时间（或间隔）。</p><p><strong>语法：</strong></p><p>暂时无法在飞书文档外展示此内容</p><ul><li><code>p</code>: 累积概率值（0 到 1 之间）。</li><li><code>rate</code>: 事件发生率，默认为 1。</li></ul><p><strong>示例：</strong></p><p>如果我们知道事件发生的平均时间间隔是 2，且我们想知道累计概率为 0.8 时事件发生的时间，可以使用：</p><p>暂时无法在飞书文档外展示此内容</p><p>这个例子会返回在 80% 累积概率下，事件发生的时间。</p><p><strong>4.</strong> <strong>rexp: 生成指数分布的随机数</strong></p><p><code>rexp</code> 函数用于生成符合指数分布的随机样本。它可以用来模拟指数分布的样本数据。</p><p><strong>语法：</strong></p><p>暂时无法在飞书文档外展示此内容</p><ul><li><code>n</code>: 需要生成的随机数的数量。</li><li><code>rate</code>: 事件发生率，默认为 1。</li></ul><p><strong>示例：</strong></p><p>假设事件发生的平均时间间隔是 2，生成 5 个随机样本：</p><p>暂时无法在飞书文档外展示此内容</p><p>这个例子将返回 5 个符合指数分布的随机数，表示事件发生的时间间隔。</p><h2 id="5-7-卡方分布"><a href="#5-7-卡方分布" class="headerlink" title="5.7 卡方分布"></a>5.7 卡方分布</h2><p><strong>语法：</strong></p><p>暂时无法在飞书文档外展示此内容</p><ul><li><code>q</code>: 给定的卡方值（必须为非负数）。</li><li><code>df</code>: 自由度。</li></ul><h1 id="6-假设检验"><a href="#6-假设检验" class="headerlink" title="6 假设检验"></a>6 假设检验</h1><h2 id="6-1-单个总体的均值检验"><a href="#6-1-单个总体的均值检验" class="headerlink" title="6.1 单个总体的均值检验"></a>6.1 单个总体的均值检验</h2><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/48.png" alt="img"></p><p>样本量&gt;&#x3D;30算大</p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/49.png" alt="img"></p><h3 id="6-1-1-z检验"><a href="#6-1-1-z检验" class="headerlink" title="6.1.1 z检验"></a>6.1.1 z检验</h3><p>某切割机正常工作时,切割每段金属棒的平均长度为10.5cm,标准差是0.15cm。今从一批产品中随机的抽取15段进行测量,其结果如下： </p><p>10.4，10.9，10.6，10.6，10.1，10.8，10.4，10.5 </p><p>10.5，10.7，10.3，10.2，10.3，10.7，10.2 </p><p>假定切割的长度服从正态分布，且标准差没有变化，试问该机工作是否正常?(𝛼 &#x3D;0.05)</p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/50.png" alt="img"></p><h3 id="6-1-2-t检验"><a href="#6-1-2-t检验" class="headerlink" title="6.1.2 t检验"></a>6.1.2 t检验</h3><p><strong>在 R 中进行单样本 t 检验</strong></p><p>R 提供了 <code>t.test()</code> 函数来执行单样本 t 检验。</p><p><strong>语法</strong></p><p>暂时无法在飞书文档外展示此内容</p><ul><li><strong>x</strong>：一个数值型向量，表示样本数据。</li><li><strong>mu</strong>：假定的总体均值，默认值是 0。</li><li><strong>alternative</strong>：假设检验的类型。可选值有：<ul><li><code>&quot;two.sided&quot;</code>（双尾检验，默认值）：检验均值是否等于 <code>mu</code>。</li><li><code>&quot;greater&quot;</code>：检验样本均值是否大于 <code>mu</code>。</li><li><code>&quot;less&quot;</code>：检验样本均值是否小于 <code>mu</code>。</li></ul></li><li><strong>conf.level</strong>：置信水平，默认值是 0.95（即 95% 置信区间）。</li></ul><p><strong>示例 1: 单样本 t 检验</strong></p><p>假设我们有一个样本数据，想检验这个样本的均值是否等于 50。</p><p>暂时无法在飞书文档外展示此内容</p><p><strong>输出</strong></p><p>暂时无法在飞书文档外展示此内容</p><p>在这个例子中，t 统计量为 0.2321，自由度为 9，p 值为 0.8194，表示我们不能拒绝零假设，即样本均值与 50 没有显著差异。95% 置信区间为 [48.814, 51.186]。</p><p><strong>示例 2: 单样本 t 检验（单尾检验）</strong></p><p>如果你只关心样本均值是否大于或小于某个值，你可以使用单尾检验。例如，检验样本均值是否大于 50：</p><p>暂时无法在飞书文档外展示此内容</p><p><strong>输出</strong></p><p>暂时无法在飞书文档外展示此内容</p><p>在单尾检验中，p 值为 0.5897，表示不能拒绝假设，样本均值并不显著大于 50。</p><p><strong>结果解释</strong></p><ul><li><strong>t 统计量（t-value）</strong>：表示样本均值与假设总体均值的差异程度。</li><li><strong>p 值（p-value）</strong>：表示观察到当前数据或更极端数据的概率。若 p 值小于显著性水平（如 0.05），则拒绝零假设。</li><li><strong>置信区间</strong>：给出了样本均值的可能范围，可以帮助我们判断总体均值所在的区间。</li></ul><p><strong>注意事项</strong></p><ol><li><strong>样本的正态性</strong>：单样本 t 检验假定样本数据来自正态分布。若样本数据较小（例如 n &lt; 30），最好进行正态性检验，如使用 Shapiro-Wilk 检验 (<code>shapiro.test()</code>)，或者通过直方图、QQ 图等方法可视化数据。</li><li><strong>样本量较小</strong>：当样本量较小（例如小于 30）时，t 检验的假定条件更加严格。此时，检验结果可能受到影响。</li></ol><h2 id="6-2-两个总体的均值检验"><a href="#6-2-两个总体的均值检验" class="headerlink" title="6.2 两个总体的均值检验"></a>6.2 两个总体的均值检验</h2><p><strong>情形1</strong>：σ1 2 和σ2 2 已知 </p><p><strong>情形2</strong>： σ1 2和σ2 2未知， σ1  2&#x3D; σ2 2，且n较小 </p><p><strong>情形3</strong>： σ1 2和σ2 2未知， σ1 2 ≠ σ2 2，且n较小</p><h3 id="6-2-1-情形1"><a href="#6-2-1-情形1" class="headerlink" title="6.2.1 情形1"></a>6.2.1 情形1</h3><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/51.png" alt="img"></p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/52.png" alt="img"></p><h3 id="6-2-2-情形2"><a href="#6-2-2-情形2" class="headerlink" title="6.2.2 情形2"></a>6.2.2 情形2</h3><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/53.png" alt="img"></p><h2 id="6-3-单个总体方差检验"><a href="#6-3-单个总体方差检验" class="headerlink" title="6.3 单个总体方差检验"></a>6.3 单个总体方差检验</h2><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/54.png" alt="img"></p><h2 id="6-4-两个总体的方差检验"><a href="#6-4-两个总体的方差检验" class="headerlink" title="6.4 两个总体的方差检验"></a>6.4 两个总体的方差检验</h2><p>以下的的两个F可以用qf()来求</p><p>暂时无法在飞书文档外展示此内容</p><p>两台车床加工同一零件，分别取6件和9件测量直径， 得<em>s</em>1 2 &#x3D; 0.345， <em>s</em>2 2 &#x3D; 0.357。假定零件的直径服从正态分布，能否据此断 定两个总体的方差相等？（<em>a</em>&#x3D;0.05）</p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/55.png" alt="img"></p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/56.png" alt="img"></p><h1 id="7-方差分析"><a href="#7-方差分析" class="headerlink" title="7 方差分析"></a>7 方差分析</h1><h2 id="7-1-单因素方差分析"><a href="#7-1-单因素方差分析" class="headerlink" title="7.1 单因素方差分析"></a>7.1 单因素方差分析</h2><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/57.png" alt="img"></p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/58.png" alt="img"></p><h2 id="7-2-双因素方差分析"><a href="#7-2-双因素方差分析" class="headerlink" title="7.2 双因素方差分析"></a>7.2 双因素方差分析</h2><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/59.png" alt="img"></p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/60.png" alt="img"></p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/61.png" alt="img"></p><h1 id="8-相关分析"><a href="#8-相关分析" class="headerlink" title="8 相关分析"></a>8 相关分析</h1><h2 id="8-1-相关关系"><a href="#8-1-相关关系" class="headerlink" title="8.1 相关关系"></a>8.1 相关关系</h2><ul><li>相关方向（正相关、负相关）</li><li>相关程度（完全相关、不完全相关、不相关）</li></ul><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/62.png" alt="img"><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/63.png" alt="img"><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/64.png" alt="img"></p><h2 id="8-2-相关系数"><a href="#8-2-相关系数" class="headerlink" title="8.2 相关系数"></a>8.2 相关系数</h2><p>• 线性相关系数的定义 </p><p>• 相关系数(coefficient of correlation)是描述两个变量之间线性相关密切 </p><p>程度和相关方向的统计分析指标 </p><p>• 相关系数计算 </p><p>• <strong>皮尔逊(Pearson)相关系数</strong> </p><p>• 斯皮尔曼等级相关系数或肯特尔等级相关系数</p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/65.png" alt="img"></p><h3 id="8-2-1-cor-cov-var"><a href="#8-2-1-cor-cov-var" class="headerlink" title="8.2.1 cor(),cov(),var()"></a>8.2.1 cor(),cov(),var()</h3><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/66.png" alt="img"></p><p>在 R 语言中，<code>cor()</code> 函数用于计算 <strong>相关系数</strong>（correlation coefficient），即衡量两个变量之间线性关系的强度和方向。</p><p><strong>语法：</strong></p><p>暂时无法在飞书文档外展示此内容</p><ul><li><strong>x</strong> 和 <strong>y</strong>：两个数值型向量、矩阵或数据框，表示要计算相关性的变量。如果只传入一个矩阵或数据框，<code>cor()</code> 会返回各列之间的相关系数矩阵。</li><li><strong>method</strong>：指定计算相关系数的方法。可以是以下三种之一：<ul><li><code>&quot;pearson&quot;</code>（默认值）：皮尔逊相关系数，用于衡量两个变量之间的线性关系。</li><li><code>&quot;kendall&quot;</code>：肯德尔秩相关系数，适用于秩数据，评估变量之间的单调关系。</li><li><code>&quot;spearman&quot;</code>：斯皮尔曼秩相关系数，评估变量之间的单调关系，适用于非线性关系。</li></ul></li><li><strong>use</strong>：指定如何处理缺失值（NA）。常见的选项有：<ul><li><code>&quot;everything&quot;</code>：默认值，要求没有缺失值。</li><li><code>&quot;complete.obs&quot;</code>：仅使用完整的观测值（忽略含有缺失值的行）。</li><li><code>&quot;pairwise.complete.obs&quot;</code>：使用每对观测值的完整数据。</li></ul></li></ul><h2 id="8-3-相关系数显著性差异"><a href="#8-3-相关系数显著性差异" class="headerlink" title="8.3 相关系数显著性差异"></a>8.3 相关系数显著性差异</h2><ul><li>cor.test()</li></ul><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/67.png" alt="img"></p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/68.png" alt="img"></p><p><img src="/2024/12/04/R%E8%AF%AD%E8%A8%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/69.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 大学课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3</title>
      <link href="/2024/10/03/vue3/"/>
      <url>/2024/10/03/vue3/</url>
      
        <content type="html"><![CDATA[<h2 id="组合式api返回对象"><a href="#组合式api返回对象" class="headerlink" title="组合式api返回对象"></a>组合式api返回对象</h2><p>它实际上是返回对象的简写形式<code>return &#123;name,age&#125;;</code><br>或者你也可以写<code>return &#123;a:name,b:age&#125;</code><br><img src="/2024/10/03/vue3/7fee285159bcf278bfa8f81209f1ceb7.png"></p><h2 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h2><p>首先提一下，this在vue3中变成了undefined（注意，前提是在setup中）。由于setup的生命周期在breforecreate之前，所以旧的（data，methods）可以通过this读取setup中的内容，但是反过来不可以。<br><img src="/2024/10/03/vue3/2f7277c9730d8f11a413e87533ae9d72.png"><br>这张图用let定义，不是响应式的，更改过后也不会内部会更新但是模板输出不会更新。</p><h2 id="setup表示相当于setup函数加自动return"><a href="#setup表示相当于setup函数加自动return" class="headerlink" title="setup表示相当于setup函数加自动return"></a>setup表示相当于setup函数加自动return</h2><p><img src="/2024/10/03/vue3/73f8e8c5b22c707564c31fad32465470.png"><br>这种情况下，下图不能写<br><img src="/2024/10/03/vue3/456557323f8b333674db052c5b9adfad.png"></p><p>所以有的vue3项目有两个script，一个写name，一个setup。<br>如果直接<img src="/2024/10/03/vue3/8b7f2c413cb2f9882a77a3cfce71422d.png"><br>需要装插件<img src="/2024/10/03/vue3/a025417569e54de3bff9e4a22a61ec29.png"><br>然后配置<code>vite.config.json</code><br><img src="/2024/10/03/vue3/0123240820e96973310aef01cb87bbbf.png"></p><h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p>vue2中data自动就是响应式的。<br><img src="/2024/10/03/vue3/c6073ab69051e31a1a3f7d5e8ba6ea07.png"></p><p><img src="/2024/10/03/vue3/07486b6f44eb6c1a240f43da4d30fb31.png"><br>用ref处理对象时，底层还是用reactive<br><img src="/2024/10/03/vue3/e47dc2278c890159c19ae47b609e4586.png"><br>注意，数组也是对象。<br><img src="/2024/10/03/vue3/d4be66e06ebe351c2833068bad44015c.png"></p><p>:key相当于v-bind:key，将“g.id”当成表达式。</p><p><img src="/2024/10/03/vue3/4d47e3b72fe091b4e87f0c19bf1e3158.png"><br>又比如<br><img src="/2024/10/03/vue3/d72c57109c5538af076bbced7040c1f0.png"></p><h3 id="reactive中嵌套ref不用-value拆包"><a href="#reactive中嵌套ref不用-value拆包" class="headerlink" title="reactive中嵌套ref不用.value拆包"></a>reactive中嵌套ref不用.value拆包</h3><p><img src="/2024/10/03/vue3/330a373c6d7f2ac7256356a526cb3aad.png"><br>不用.value</p><h3 id="reactive定义的对象不能直接复值修改"><a href="#reactive定义的对象不能直接复值修改" class="headerlink" title="reactive定义的对象不能直接复值修改"></a>reactive定义的对象不能直接复值修改</h3><p><img src="/2024/10/03/vue3/b16eaf6b6fa6696090b025b20cb7fa52.png"><img src="/2024/10/03/vue3/2d1f2ad88380e7ca0eed7ee5432db07c.png"><br>也不能<br><img src="/2024/10/03/vue3/61726f1f1d827288ba63c3bc3eadb19d.png"><br><strong>可以这么写</strong><br><img src="/2024/10/03/vue3/0ea445200a59795a885c5e135adbc946.png"><br><img src="/2024/10/03/vue3/5fd05833a76a7fde119ec72e0c60a004.png"></p><p><strong>注意，如果是ref定义的对象可以整体改</strong><br><img src="/2024/10/03/vue3/49cf1a37cc0aeb0f372a8691a5cfa16b.png"></p><p><img src="/2024/10/03/vue3/713d268f6cbe163c9da6b89cde9887b8.png"></p><h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs()"></a>toRefs()</h3><p>如图，此时name和age变成了响应数据（相当于定义一个响应式对象，对象内容用person中的），如果不用，则相当于用let定义，不会改变。<br><img src="/2024/10/03/vue3/bd89aa67ba7995a9dbdb20b3c4c7a746.png"><br>相当于<br><img src="/2024/10/03/vue3/84576135e68aac69724b25abfc7d77b6.png"></p><h2 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed"></a>计算属性computed</h2><p>方法和计算属性比较<br>方法要自己调用，计算方法直接写fullName就可以用。<br><strong>计算属性有缓存，重复的不用重新调用，直接读缓存</strong><br><img src="/2024/10/03/vue3/f81830c696d12acd78bbb8e7b7fbcc0c.png"><strong>注意</strong>：这里fullName被改了之后是只读的，不能修改。<br>要想修改，用get和set<br><img src="/2024/10/03/vue3/7d4120da4d493b926490b957f294e9a1.png"></p><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p><img src="/2024/10/03/vue3/b8dfac52b507e60ed0b06906498eed73.png"></p><h3 id="监视ref定义的基本数据类型"><a href="#监视ref定义的基本数据类型" class="headerlink" title="监视ref定义的基本数据类型"></a>监视ref定义的基本数据类型</h3><p>watch格式<br><img src="/2024/10/03/vue3/61d122d0e0fb0d837b2c9d2f565c5f06.png"><br>他会接受两个值：新值和旧址值（注意，这里没有.value）<br><img src="/2024/10/03/vue3/6b5a7d8ba37ed817150f3c592fd3c123.png"></p><h4 id="停止监视"><a href="#停止监视" class="headerlink" title="停止监视"></a>停止监视</h4><p>watch的返回值是一个函数，调用的话会监视停止。<br><img src="/2024/10/03/vue3/28c7ec6c872a918acdcce1345ecca90a.png"></p><h3 id="ref监视的对象数据类型"><a href="#ref监视的对象数据类型" class="headerlink" title="ref监视的对象数据类型"></a>ref监视的对象数据类型</h3><p>如图，在这种情况下，如果只改变某一个属性的值，不监视，因为他只检测地址。<br><img src="/2024/10/03/vue3/844459404e13d0f370b09d83e138bc7c.png"><br>可以这样改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(someObject, <span class="function">(<span class="params">newValue, oldValue</span>)</span></span><br><span class="line"><span class="function">  =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;对象变化:&#x27;</span>, newValue); &#125;</span><br><span class="line">  , &#123; <span class="attr">deep</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><p>加上第三个参数，此时修改属性也会监听。<br><strong>watch的第3个选项</strong>（可选）：可以传入一个对象，包含如下选项：</p><ul><li><code>immediate</code>：如果为 <code>true</code>，则在监听开始时立即调用回调。</li><li><code>deep</code>：如果为 <code>true</code>，则深度观察对象内部的变化。</li></ul><p><strong>注意</strong><br><img src="/2024/10/03/vue3/ac20cecb21c6dba27a18c51d0a328afa.png"><br>所以很多人直接<code>watch(someObject,(value)=&gt;&#123;&#125;,&#123;deep:true)</code></p><h3 id="reactive监视的对象"><a href="#reactive监视的对象" class="headerlink" title="reactive监视的对象"></a>reactive监视的对象</h3><p>如下图，且不能通过deep:false关闭<br><img src="/2024/10/03/vue3/a787bdf8ceecee8485b0a284b7259c00.png"></p><h3 id="用ref和reactive监视对象中的某一个数据"><a href="#用ref和reactive监视对象中的某一个数据" class="headerlink" title="用ref和reactive监视对象中的某一个数据"></a>用ref和reactive监视对象中的某一个数据</h3><p>注意，不能直接用person.name(因为他是基本数据类型，不能直接写)，注意能被监视的4种对象。<br><img src="/2024/10/03/vue3/ce05f78f92739b1299508a51db04ac12.png"></p><h3 id="监视上述多个数据"><a href="#监视上述多个数据" class="headerlink" title="监视上述多个数据"></a>监视上述多个数据</h3><p><img src="/2024/10/03/vue3/f13e3caf8100dedc4d09680f14d0c678.png"></p><h2 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h2><p>watch要先指出监视的对象，watchEffect则不用<br><img src="/2024/10/03/vue3/a7c01b2272819b86dfdffc63d8ff1d1e.png"></p><h2 id="ref修饰标签"><a href="#ref修饰标签" class="headerlink" title="ref修饰标签"></a>ref修饰标签</h2><p>使用ref定义标签防止污染。<br>比如别人写了<img src="/2024/10/03/vue3/39b2a742c7efce303a13dbb9645ce00d.png"><br>且调用你的页面，你也写了这个id，可能会有id冲突（何况他调用你的，页面先加载）。<br>解决方案就是用ref &#x3D; “title2”<br>然后title2 &#x3D; ref()</p><p>他可以定义htnl标签和自定义标签<br>自定义标签要这样声明允许访问的内容（用defineExpose）。<br><img src="/2024/10/03/vue3/dd47788cdd4fc7e28b172abdfe3efe7e.png"></p><h2 id="js的3种暴露方式"><a href="#js的3种暴露方式" class="headerlink" title="js的3种暴露方式"></a>js的3种暴露方式</h2><p>在 JavaScript 中，模块系统允许我们通过不同的方式导出和导入功能。以下是三种主要的导出方式：</p><h3 id="1-默认暴露（Default-Export）"><a href="#1-默认暴露（Default-Export）" class="headerlink" title="1. 默认暴露（Default Export）"></a>1. 默认暴露（Default Export）</h3><p>使用 <code>export default</code> 语法进行导出，每个模块只能有一个默认导出。导入时可以使用任意名称。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">myFunction</span> = (<span class="params"></span>) =&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> myFunction;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> anyName <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="2-分别暴露（Named-Exports）"><a href="#2-分别暴露（Named-Exports）" class="headerlink" title="2. 分别暴露（Named Exports）"></a>2. 分别暴露（Named Exports）</h3><p>使用 <code>export</code> 关键字导出多个变量或函数，每个模块可以有多个分别暴露。导入时需要使用相同的名称。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">bar</span> = (<span class="params"></span>) =&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span>;</span><br></pre></td></tr></table></figure><p>引入接口如下<br><img src="/2024/10/03/vue3/9f7182a78f8fcb4a0732376ab50d1790.png"><br>定义数组如下<br><img src="/2024/10/03/vue3/2a21a49a1648bf2bd2100030c8215014.png"><br>或者定义一个自定义类型。<br><img src="/2024/10/03/vue3/5df79555b71e97d9e32891ba9df73637.png"><br><img src="/2024/10/03/vue3/5985c5e14c3af17109404a4ef476a476.png"></p><h3 id="3-统一暴露（Aggregate-Exports）"><a href="#3-统一暴露（Aggregate-Exports）" class="headerlink" title="3. 统一暴露（Aggregate Exports）"></a>3. 统一暴露（Aggregate Exports）</h3><p>通过 <code>export * from &#39;module&#39;</code> 语法将其他模块的导出统一暴露，通常用于重新导出。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module1.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// module2.js</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./module1.js&#x27;</span>; <span class="comment">// 统一暴露</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; a, b &#125; <span class="keyword">from</span> <span class="string">&#x27;./module2.js&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这三种方式提供了灵活的模块化方法，可以根据需求选择适合的导出方式。</p><h2 id="props的使用"><a href="#props的使用" class="headerlink" title="props的使用"></a>props的使用</h2><p>definexxx一般是宏函数，可以不用引入<br><img src="/2024/10/03/vue3/e6de3c86d6d181960f0d17081ef76045.png"></p><h2 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h2><p>简单来说，4个阶段，8个钩子<br><img src="/2024/10/03/vue3/9a30c9823599da56c6da3a2a0bdeb771.png"></p><h3 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h3><p>将创建的两个过程改为setup函数<br><img src="/2024/10/03/vue3/6fb12b8d7ff71a8057c06d19410e5eac.png"><br>vue3子组件挂载好之后父组件才会挂载。</p><h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><p><img src="/2024/10/03/vue3/70cb66d75dffd63f174ed347f334861b.png"><br><img src="/2024/10/03/vue3/ecac695249720d24b5449cbea40cc7c8.png"></p><h2 id="v-if和v-show"><a href="#v-if和v-show" class="headerlink" title="v-if和v-show"></a>v-if和v-show</h2><p>前者如果不满足条件的话，会直接删除他标记的结构；而后者则只是隐藏。</p><h2 id="route"><a href="#route" class="headerlink" title="route"></a>route</h2><p>SPA单html应用<br><img src="/2024/10/03/vue3/6e8ba119e2f695aea71830ee89d958c0.png"></p><h3 id="routerLink"><a href="#routerLink" class="headerlink" title="routerLink"></a>routerLink</h3><p>将active-class和routerLink结合，选中哪个页面哪个亮。<br>切换之后，被销毁</p><h3 id="工程化开发标准"><a href="#工程化开发标准" class="headerlink" title="工程化开发标准"></a>工程化开发标准</h3><p>views&#x2F;pages放路由器组件<br>components放自定义组件</p><h3 id="路由器工作模式"><a href="#路由器工作模式" class="headerlink" title="路由器工作模式"></a>路由器工作模式</h3><p><strong>SEO的作用是让你的网站更容易被搜索引擎搜到</strong><br><img src="/2024/10/03/vue3/48b3c30d40ca88d726db34c43f43dbcf.png"></p><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p><img src="/2024/10/03/vue3/9904e81d5df7b1c86f68463e51ff53dd.png"></p><h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><h4 id="query传参"><a href="#query传参" class="headerlink" title="query传参"></a>query传参</h4><p>在父组件定义好想要传递给子组件的参数<br>写法一：用?和&amp;<br><img src="/2024/10/03/vue3/e0f21e720b388fc0ec09b98fe527f2c0.png"><br>写法二：<br><img src="/2024/10/03/vue3/c9a407bd97adfcff8b79e78cbc9ab5f6.png"></p><p>子页面显示(注意引入useRoute)<br><img src="/2024/10/03/vue3/83eacb60f7d45ca02105d1e6d5570892.png"><br>或通过解构，<strong>注意要加toRefs()，不然let对象会让ref性质消失</strong><br><img src="/2024/10/03/vue3/6171df8870345dda2895ff17a0c15102.png"></p><h3 id="params传参"><a href="#params传参" class="headerlink" title="params传参"></a>params传参</h3><p>和query不同，path后面写上占位符表示你要传递的参数<br><img src="/2024/10/03/vue3/261e1c1d70ec4f6e500a99d0eb194dd7.png"><br>如果加问号就表示可传可不传<br><img src="/2024/10/03/vue3/2f52ac1c818932be48f0f688ba3dcfd6.png"></p><p>传参路径不能path，只能用name<br><img src="/2024/10/03/vue3/2616856e3440619339f6eb98b289194d.png"><br>不能传递对象和数组</p><h3 id="路由的props配置"><a href="#路由的props配置" class="headerlink" title="路由的props配置"></a>路由的props配置</h3><h4 id="写法一：将路由收到的所有params参数作为props参数传给路由组件"><a href="#写法一：将路由收到的所有params参数作为props参数传给路由组件" class="headerlink" title="写法一：将路由收到的所有params参数作为props参数传给路由组件"></a>写法一：将路由收到的所有params参数作为props参数传给路由组件</h4><p>设置main.ts中的props为真<br><img src="/2024/10/03/vue3/428fde4e621a767bdd25263f1d0d57cd.png"><br>可以理解为组件props中的写法<br><img src="/2024/10/03/vue3/cafbfb55c0d6dc207edd6c8b6f1c655e.png"><br>这种情况下，可以这样写<br><img src="/2024/10/03/vue3/134e8d72c992ae5e943bad83443e1c2d.png"></p><h4 id="第二种写法，可以自己决定将什么作为props给路由组件"><a href="#第二种写法，可以自己决定将什么作为props给路由组件" class="headerlink" title="第二种写法，可以自己决定将什么作为props给路由组件"></a>第二种写法，可以自己决定将什么作为props给路由组件</h4><p><img src="/2024/10/03/vue3/438b82d9b531f68a3f1b82609b579d4a.png"><br>但是这么写就写死了，可以这么改</p><p><img src="/2024/10/03/vue3/3c85d7162ad95c130e934376f63366dd.png">#### 第3种写法，写死<br><img src="/2024/10/03/vue3/c592c6ffb148e378429434b047599f52.png"></p><h3 id="路由-replace属性"><a href="#路由-replace属性" class="headerlink" title="路由 replace属性"></a>路由 replace属性</h3><p>replace的作用是能够让页面不可以通过&lt;-和-&gt;移动</p><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><p>目前为止所有的导航都是通过router-link导航的，最终会转化为一个html原生的a标签。所以如果要实现比如按button跳转就无法实现，又比如到了主页面等待3秒钟自动跳转。</p><p><strong>编程式导航</strong>就是脱离router-link进行跳转</p><p>引入useRouter（注意结尾带r，是路由器而不是路由）<br>使用push跳转，允许用户返回先前页面<br><img src="/2024/10/03/vue3/740c143d8bf35dc7058d6bbf6b983b52.png"><br>稍微复杂一点的例子<br>点击button，调用一个自己写的函数跳转路由<br><img src="/2024/10/03/vue3/5025e1365fdd984422e26681db84f3b6.png"><br><strong>link-to有什么写法，router.push中就有什么写法</strong></p><h3 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h3><p>既可以写在嵌套路由的内部和外部。</p><p><img src="/2024/10/03/vue3/4f65c4dbb4847b97ac1ca75351e722f8.png"></p><h3 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h3><p>用于<strong>集中式状态管理类</strong>，相对的概念是<strong>分布式状态管理</strong></p><h4 id="搭建pinia环境"><a href="#搭建pinia环境" class="headerlink" title="搭建pinia环境"></a>搭建pinia环境</h4><p>npm i pinia<br>然后再main.ts中配置环境<br><img src="/2024/10/03/vue3/ee79497286b37f5e9e1c73878864ef3c.png"><img src="/2024/10/03/vue3/1d2126c0f37bb1332e0f4b1cd9f4e885.png"></p><h4 id="在src中构建store文件夹（规范要求）"><a href="#在src中构建store文件夹（规范要求）" class="headerlink" title="在src中构建store文件夹（规范要求）"></a>在src中构建store文件夹（规范要求）</h4><p>defineStore中接受两个参数，第一个用ts文件的名称，第二个如图。<br><img src="/2024/10/03/vue3/f2e20b293d0a9a82238742b54192a321.png"></p><h5 id="如何存储和读取数据"><a href="#如何存储和读取数据" class="headerlink" title="如何存储和读取数据"></a>如何存储和读取数据</h5><p>如图，有两种方法可以拿到state中的数据。<br><img src="/2024/10/03/vue3/af08998bd536e4b72e66456154a790b8.png"></p><h5 id="如何修改数据"><a href="#如何修改数据" class="headerlink" title="如何修改数据"></a>如何修改数据</h5><p>方法一<br>pinia支持直接用countStore.sum++就可以(pinia是符合直觉的状态管理库的体现之一)</p><p>方法二（批量修改patch（直译过来有碎片的意思））<br>当你数据很多的时候使用，比如有以下数据<br><img src="/2024/10/03/vue3/738b009caf477931032e86d80b8dcdf9.png"><br>这样修改<br><img src="/2024/10/03/vue3/69ac0fc04a36f43358726752dc03f2a1.png"><br>方法三<br>使用actions<br>首先定义actions<br><img src="/2024/10/03/vue3/9fd925fc28548fe5f6631051e083a218.png"><br>再使用<br><img src="/2024/10/03/vue3/9565aa58b308c0641637c6237fc98d0b.png"></p><h4 id="storeToRefs"><a href="#storeToRefs" class="headerlink" title="storeToRefs"></a>storeToRefs</h4><p><img src="/2024/10/03/vue3/c8c74dbbbadfa68c6dbf730bfe05854e.png"></p><h5 id="的使用"><a href="#的使用" class="headerlink" title=":的使用"></a>:的使用</h5><p>在 JavaScript 中，当你定义对象的方法时，如果方法名是有效的标识符，可以直接使用函数名而不需要加冒号。以下是具体说明：<br>在对象字面量中，你可以使用简写语法定义方法。这种情况下，方法名后面不需要加冒号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="title function_">methodName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 Pinia 中，定义 <code>actions</code> 时也可以使用这种简写语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">  <span class="title function_">addItem</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(item); <span class="comment">// 这是方法定义</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式与使用冒号的写法等效，但更简洁。实际上，下面的代码是等价的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">  <span class="attr">addItem</span>: <span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(item);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在对象字面量中，方法的简写形式允许你省略冒号。</li><li>使用简写语法时，方法名和方法体之间不需要冒号。</li></ul><h4 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h4><p>它的作用是对state中的数据进行加工。<br><img src="/2024/10/03/vue3/f3700588365c1f1ea3407488e955f947.png"></p><h4 id="subscribe方法"><a href="#subscribe方法" class="headerlink" title="$subscribe方法"></a>$subscribe方法</h4><p>相当于store的watch方法，<strong>！注意，state.talkList不用再.value解包了，他自动帮你解包</strong><br>举个例子，使用localStorage.setItem使用本地存储<br><img src="/2024/10/03/vue3/b92cb14a3e4a935558f9b7eb3777c93e.png"><br>解析的时候这么写<br><img src="/2024/10/03/vue3/4370c69baa36ec98c420e6211bd429c3.png"></p><h4 id="store组合式写法"><a href="#store组合式写法" class="headerlink" title="store组合式写法"></a>store组合式写法</h4><p>action写成函数，存储的数据类似setup中的定义方式<br><img src="/2024/10/03/vue3/a776e296b20818b71862370f542080a8.png"></p><p>​  </p><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><h3 id="方式一：props"><a href="#方式一：props" class="headerlink" title="方式一：props"></a>方式一：props</h3><p><img src="/2024/10/03/vue3/670f61464869a7e71d6e3a3255390e69.png"><br>父组件给子组件直接转，但是子组件给父组件要求父组件首先传一个函数给子组件，子组件在调用这个函数传递给父组件。（父传子，非函数；子传父，函数）</p><h3 id="方式二：自定义事件"><a href="#方式二：自定义事件" class="headerlink" title="方式二：自定义事件"></a>方式二：自定义事件</h3><p>事件对象$event（是一个特殊的占位符）<br>在子组件中通过<code>$emit</code>注册事件，将数据作为参数传入，在父组件中直接通过<code>$event</code>接收。<br><img src="/2024/10/03/vue3/43c58e1e94bb7ccf54d213d41c46f6e0.png"><br>此时c对应的就是事件对象</p><p>下图中左边接受，右边发送。<br><img src="/2024/10/03/vue3/e6ae9dad925c7eb322774ec51bc55c1a.png"><br>按照这个思路，可以修改方式一中的发送函数。<br>注意这里的命名风格@send-toy是<strong>kebab-case</strong>d的命名风格（官方推荐，当事件名是多个单词组成的时）<br><img src="/2024/10/03/vue3/50dbbbf2b85a5eedacf2c1bed63814d3.png"><br><img src="/2024/10/03/vue3/c21f60cfbdd61c76bc531a6779595c5b.png"></p><h3 id="mitt"><a href="#mitt" class="headerlink" title="mitt"></a>mitt</h3><p>首先安装npm i mitt，再配置main.js<br><img src="/2024/10/03/vue3/3f8817698c90e0c4c39b97364d72038d.png"><br>配置的工具类，放在工具tools或utils文件夹中<br><img src="/2024/10/03/vue3/c2d74e9e734b57e9b1815f7b3e3c90f6.png"></p><p>要实现<br><img src="/2024/10/03/vue3/5ea83a33870e086d7e378f045c23ad9d.png"><br>左边发送，右边接受（<strong>可以看到无论是哪种方式，emit在哪里，哪里发送</strong>）</p><p><img src="/2024/10/03/vue3/5767f5be71a90309bb9377f0d9f1b2d9.png"><br>别忘了，销毁时解绑<br><img src="/2024/10/03/vue3/bc152c24ca140a9948ef9c450ee504eb.png"></p><p><img src="/2024/10/03/vue3/d8d0c309ce5a2c2dc8897d0af32f4c70.png"></p><h3 id="v-model原理"><a href="#v-model原理" class="headerlink" title="v-model原理"></a>v-model原理</h3><p><img src="/2024/10/03/vue3/0eb49bab000cc19a0c5d78a190b7780c.png"></p><h3 id="attrs"><a href="#attrs" class="headerlink" title="$attrs"></a>$attrs</h3><p>用于祖组件向孙组件传递值。<br>中间人用v-bind&#x3D;”$attrs”传递给孙他没用过的剩下的props，同样如果孙传祖就用函数。<br>（v-bind&#x3D;”{ a: valueA, b: valueB }”,它拆开来就是:a &#x3D; “valueA” :b&#x3D;”valueB”）<br><img src="/2024/10/03/vue3/d793596fa7370891367398cd70b0ff08.png"></p><h3 id="refs和-parent"><a href="#refs和-parent" class="headerlink" title="$refs和$parent"></a><code>$refs</code>和<code>$parent</code></h3><p>$refs用于父对子通信<br><img src="/2024/10/03/vue3/0dbff8e22e579340789665611787663a.png"><br>直接输出$refs的内容如下<br><img src="/2024/10/03/vue3/261fe9fbfdf2db7d1f56a8693e0bf81f.png"><br>或者直接any也可以<br><img src="/2024/10/03/vue3/646212adef580d15896538e04f1b1d22.png"></p><p>$parent用法同上。</p><h3 id="provide和inject"><a href="#provide和inject" class="headerlink" title="provide和inject"></a>provide和inject</h3><p>直接祖孙传递，而不像$attrs依赖子。<br>祖宗传给孙，祖宗用provide，孙子用inject。如果想要子多用于祖先，那就让祖先传递给子他的函数<br><img src="/2024/10/03/vue3/a14441d081bba0db7aa8e3309523858d.png"></p><h2 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h2><h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><p>默认插槽有一个默认名字的default<br><img src="/2024/10/03/vue3/2c9b114ade8e813bf9b91e4455f3153c.png"></p><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>插槽上写名字name，使用v-slot:关联。<br><img src="/2024/10/03/vue3/7aba271e698dbe7c84090e95c3bb18ac.png"></p><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>出现的原因是因为父亲想要孩子的数据。<br><img src="/2024/10/03/vue3/0c9b615b15f79f49d83fc30a34788ca6.png"><br>作用域插槽也可以有名字<br><img src="/2024/10/03/vue3/3183e76137553ee14f4057014cd227b3.png"></p><p>vue语法糖支持用#替换v-slot</p><h2 id="shallowRef和shallowReactive"><a href="#shallowRef和shallowReactive" class="headerlink" title="shallowRef和shallowReactive"></a>shallowRef和shallowReactive</h2><p>shallow用于整体修改，效率更高</p><h2 id="toRow和markRow"><a href="#toRow和markRow" class="headerlink" title="toRow和markRow"></a>toRow和markRow</h2><p><img src="/2024/10/03/vue3/1e7cb716f751461f1985c5b71667013b.png"><br><img src="/2024/10/03/vue3/6122b0a8d11a37f895b70eedf90e0a42.png"></p><h3 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h3><p><img src="/2024/10/03/vue3/68381547eaf17311dd4cdaf2092b34fc.png"><br>但是只能用console打印，它内部的值还是原来的“你好”，也就是get返回的值。</p><p>你可能想这么解决，但是会有问题<br><img src="/2024/10/03/vue3/826c33f304d307ea5c65b99364eb2fd7.png"><br>要加上track()和trigger()进行跟踪，和告诉vue的功能。<br><img src="/2024/10/03/vue3/5f248eab8bd4779b27432a0559cd6237.png"></p><p><img src="/2024/10/03/vue3/ffff759c59fb749f8765075c0644cf98.png"><br>封装成hooks(注意hooks应该有返回值)<br><img src="/2024/10/03/vue3/0b52faf9cd12a2ae17f1f9757448bd81.png"><br>使用<br><img src="/2024/10/03/vue3/5d1e6669c5932182d84088a6c3be93df.png"></p><h2 id="杂项记录"><a href="#杂项记录" class="headerlink" title="杂项记录"></a>杂项记录</h2><h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift"></a>unshift</h3><p><code>unshift</code> 是 JavaScript 中数组的一个方法，用于向数组的开头添加一个或多个元素，并返回新数组的长度。</p><p><strong>语法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.<span class="title function_">unshift</span>(element1, element2, ..., elementN)</span><br></pre></td></tr></table></figure><ul><li><strong>element1, element2, …, elementN</strong>: 要添加到数组开头的元素。</li></ul><p><strong>返回值</strong></p><p>返回更新后数组的长度。</p><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数组开头添加一个元素</span></span><br><span class="line"><span class="keyword">let</span> newLength = numbers.<span class="title function_">unshift</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers); <span class="comment">// 输出: [1, 2, 3, 4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newLength); <span class="comment">// 输出: 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数组开头添加多个元素</span></span><br><span class="line">newLength = numbers.<span class="title function_">unshift</span>(-<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers); <span class="comment">// 输出: [-1, 0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newLength); <span class="comment">// 输出: 6</span></span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li><code>unshift</code> 会改变原数组，而不是返回一个新数组。</li><li>如果没有参数传递给 <code>unshift</code>，数组的长度会保持不变。</li></ul><p><strong>使用场景</strong></p><p><code>unshift</code> 方法常用于需要在数组前面添加元素的场景，例如实现队列、管理历史记录等。</p><h3 id="router-link和router-view的对应关系"><a href="#router-link和router-view的对应关系" class="headerlink" title="router-link和router-view的对应关系"></a>router-link和router-view的对应关系</h3><p>做了几个测试，目前来看router-link和router-view的对应关系是层级一一对应，比如在router&#x2F;index.js定义的的最外层路由就对应对外层的router-view（比如App.vue中我写一个router-view），和router-link或者编程式导航所在的位置无关。</p><h3 id="emit和defineEmits"><a href="#emit和defineEmits" class="headerlink" title="$emit和defineEmits"></a>$emit和defineEmits</h3><p>在 Vue 3 中，<code>$emit</code> 和 <code>defineEmit</code> 都用于处理事件的发射，但它们的使用场景和方式略有不同。</p><h4 id="1-emit"><a href="#1-emit" class="headerlink" title="1. $emit"></a>1. <code>$emit</code></h4><ul><li><p><strong>用法</strong>：这是 Vue 2 和 Vue 3 中都可以使用的方法。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;event-name&#x27;</span>, eventData);</span><br></pre></td></tr></table></figure></li><li><p><strong>特点</strong>：</p><ul><li>你可以在组件的任何方法中调用它。</li><li>通常在组件的 <code>methods</code> 中使用。</li></ul></li></ul><p> 示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;update&#x27;</span>, newValue);</span><br></pre></td></tr></table></figure><h4 id="2-defineEmit"><a href="#2-defineEmit" class="headerlink" title="2. defineEmit"></a>2. <code>defineEmit</code></h4><ul><li><p><strong>用法</strong>：这是 Vue 3 Composition API 中的一种方式，专门设计用于定义组件的事件。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> emit = <span class="title function_">defineEmit</span>([<span class="string">&#x27;event-name&#x27;</span>]);</span><br></pre></td></tr></table></figure></li><li><p><strong>特点</strong>：</p><ul><li><code>defineEmit</code> 在 <code>&lt;script setup&gt;</code> 中使用，简化了事件定义和发射的语法。</li><li>需要先定义事件名，然后通过 <code>emit()</code> 方法发射事件。</li></ul></li></ul><p> 示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const emit = defineEmit([&#x27;update&#x27;]);</span><br><span class="line"></span><br><span class="line">function handleClick() &#123;</span><br><span class="line">  emit(&#x27;update&#x27;, newValue);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p> 区别总结</p><ol><li><p><strong>上下文</strong>：</p><ul><li><code>$emit</code> 可以在任何方法中使用，适用于传统的 Options API。</li><li><code>defineEmit</code> 仅在 <code>&lt;script setup&gt;</code> 中使用，适用于 Composition API。</li></ul></li><li><p><strong>定义方式</strong>：</p><ul><li><code>$emit</code> 不需要提前声明事件名称。</li><li><code>defineEmit</code> 需要在组件的顶部声明事件名称，有助于更好地组织代码和提供类型推导。</li></ul></li><li><p><strong>简洁性</strong>：</p><ul><li><code>defineEmit</code> 在使用 Composition API 时使代码更简洁、结构更清晰。</li></ul></li></ol><p>总的来说，选择哪个方法取决于你使用的是 Options API 还是 Composition API，以及个人的编码习惯。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux</title>
      <link href="/2024/09/25/linux/"/>
      <url>/2024/09/25/linux/</url>
      
        <content type="html"><![CDATA[<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><p>linux运维工程师</p><ul><li>规划</li><li>优化</li><li>监控<br>linux嵌入式工程师：掌握linux下驱动的开发。</li></ul><h3 id="linux应用领域"><a href="#linux应用领域" class="headerlink" title="linux应用领域"></a>linux应用领域</h3><p>桌面领域（不强）<br><strong>服务器领域</strong>（最常见）：linux稳定高效<br><strong>嵌入式领域</strong>（常见）：运行稳定，可根据软件进行裁剪，内核最小可以到几百KB。应用于如机顶盒，手机，PDA，智能家居。</p><h3 id="linux介绍"><a href="#linux介绍" class="headerlink" title="linux介绍"></a>linux介绍</h3><p>linux吉祥物，企鹅Tux。<br>Linux之父 Linux Torvalds也是Git创造者。<br>linux发行版：Ubuntu（乌班图），RedHat（红帽），CentOS，Debain（蝶变）<br><strong>注意linux是一个kernel</strong>，发行版是在内核的基础上开发之后在发行，例如开发python的一般会用ubuntu。</p><h3 id="linux和Unix"><a href="#linux和Unix" class="headerlink" title="linux和Unix"></a>linux和Unix</h3><p>Unix由 Ken tompsom和Dennis richres合作使用C语言写，一开始有大公司基于Unix开发心得操作系统，如BSD，IBM AIX，Sun Solaris，AT&amp;T system V，但是这些都是只针对大型主机和服务器，因为服务器部署需要大量资金，一般人用不了。</p><p>因此stallman看不下去了，提出每个人都应有阅读软件源代码并修改的权利，提出了GNU计划。</p><p>linux就诞生于GNU计划，Linux Torvalds（linux之父）就参加了这个计划，贡献了linux内核。<br>所以linux的完整叫法应该是GNU&#x2F;LINUX。</p><p>linus是基于AT&amp;T system V衍生出的Minix基础上开发的，适用于x86的个人计算机（拜托了大型主机或服务器）。</p><h2 id="linux分区"><a href="#linux分区" class="headerlink" title="linux分区"></a>linux分区</h2><p>linux系统分区可以分为3个部分</p><ul><li>boot分区（引导分区）</li><li>交换分区（swap）</li><li>根分区（root）<br>一般而言，放的文件主要是在root分区。<br>swap分区的作用是临时充当内存（如果内存已经存不下了就放在swap分区，类似虚拟地址）</li></ul><h2 id="网络连接的3种模式"><a href="#网络连接的3种模式" class="headerlink" title="网络连接的3种模式"></a>网络连接的3种模式</h2><p>假设有三个人abc在同一个教室，他们的ip地址如下<br>a 192.168.0.20<br>b 192.168.0.30<br>c 192.168.0.50</p><h3 id="1-桥接模式"><a href="#1-桥接模式" class="headerlink" title="1.桥接模式"></a>1.桥接模式</h3><p>桥接模式，虚拟系统费可以和外部系统进行通信，但是容易造成ip冲突。<br>例如：<br>如果按照桥接模式进行设置，a的linux的网络ip的网段和192.168.0.20这个网段的ip，如192.168.0.50</p><h3 id="2-NAT模式"><a href="#2-NAT模式" class="headerlink" title="2.NAT模式"></a>2.NAT模式</h3><p>NAT（网络地址转换模式），虚拟地址可以和外部通讯，不造成ip冲突。<br>例如：<br>b按NAT模式配虚拟系统ip为192.168.100.88,在他的主机上会生成另一个ip如192.168.100.99,他们两个ip可以互通，虚拟系统可以和外部通讯，且用的不是同一个网段。</p><h3 id="3-主机模式"><a href="#3-主机模式" class="headerlink" title="3.主机模式"></a>3.主机模式</h3><p>主机模式就是一个独立的系统，不和外部发生联系。</p><h2 id="虚拟机克隆"><a href="#虚拟机克隆" class="headerlink" title="虚拟机克隆"></a>虚拟机克隆</h2><p>如果你一件安装了一台linux超过系统，还想要更多的，只需拷贝一份安装好的虚拟机文件安装到其他地方即可，再用VMWare打开即可（打开.VMX）。</p><h2 id="虚拟机快照"><a href="#虚拟机快照" class="headerlink" title="虚拟机快照"></a>虚拟机快照</h2><p>将虚拟机返回之前的某一个状态，在vmware右键管理快照。</p><h2 id="虚拟机的迁移和删除"><a href="#虚拟机的迁移和删除" class="headerlink" title="虚拟机的迁移和删除"></a>虚拟机的迁移和删除</h2><p>移动只需要剪切就可以了<br>使用vmware进行移除，点击菜单-&gt;从磁盘删除。</p><h2 id="共享文件夹"><a href="#共享文件夹" class="headerlink" title="共享文件夹"></a>共享文件夹</h2><p>在mnt&#x2F;hfgs中<br>但是实际开发中，一般使用<strong>远程连接</strong></p><h2 id="linux的文件目录"><a href="#linux的文件目录" class="headerlink" title="linux的文件目录"></a>linux的文件目录</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>linux的文件系统是采用级层式的树状目录机构，在此结构中的最上层是根目录“&#x2F;”，然后在此目录下再创建其他的目录。<br>深刻理解linux树状文件目录是非常重要的。(框架需要背)<br>记住一句经典的话：在Linux世界里，一切皆文件。<br>注：linux会将硬件映射成文件来进行管理。</p><h3 id="具体的目录结构-不用背，知道即可"><a href="#具体的目录结构-不用背，知道即可" class="headerlink" title="具体的目录结构(不用背，知道即可)"></a>具体的目录结构(不用背，知道即可)</h3><p><img src="/2024/09/25/linux/3c1fb9c2cb68d865a7b219954924213b.png"><br>&#x2F;bin （常用） (&#x2F;usr&#x2F;bin、&#x2F;usr&#x2F;local&#x2F;bin)：<br>是Binary的缩写，这个目录存放着最经常使用的指令，如cd指令。</p><p>&#x2F;sbin (&#x2F;usr&#x2F;sbin、&#x2F;usr&#x2F;local&#x2F;sbin)：<br>s是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p><p>&#x2F;home（常用）：<br>存放普通用户的根目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名。可以在终端用下面命令创建和删除linux用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd jack <span class="comment"># 创建名为jack的用户，同时在/home目录下会创建jack目录</span></span><br><span class="line">userdel -r jack <span class="comment"># 移除jack用户，同时在/home目录下会移除jack目录</span></span><br></pre></td></tr></table></figure><p>&#x2F;root（常用）：<br>该目录为系统管理员，也称作超级权限者的用户主目录</p><p>&#x2F;lib：系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p><p>&#x2F;lost+found这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件(lost+found目录一般是隐藏的，通过在终端，在根目录输入ls可以查看到)</p><p>&#x2F;etc （常用）：所有的系统管理所需要的配置文件和子目录，比如安装mysql数据库，则数据库的配置文件会默认放在etc下面。当然etc也有系统的一些配置文件。</p><p>&#x2F;usr （常用）: 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录(windows下安装的程序默认的目录)。</p><p>&#x2F;boot （常用）：存放的是启动Linux时的一些核心文件，包括一些连接文件以及镜像文件。</p><p>&#x2F;proc (不能动)：这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。</p><p>&#x2F;srv  (不能动): service缩写，该目录存放一些服务启动之后需要提取的数据。</p><p>&#x2F;sys  (不能动): 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs。</p><p>&#x2F;tmp: 这个目录是用来存放一些临时文件的。</p><p>&#x2F;dev：类似于windows的设备管理器，把所有的硬件用文件的形式存储，如cpu，硬盘等</p><p>&#x2F;media （常用）：linux系统会自动识别一些设备，如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p><p>&#x2F;mnt （常用）：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看里面的内容了。如之前的共享文件夹d:&#x2F;myshare</p><p>&#x2F;opt：这是给主机额外<strong>安装软件</strong>所存放的目录。如安装ORACLE数据库就可以放到该目录下。默认为空。</p><p>&#x2F;usr&#x2F;local （常用）：这是另一个给主机额外安装软件安装的目录。(软件安装好存放的目录)一般是通过编译源码方式安装的程序。</p><p>&#x2F;var （常用）：这个目录中存放着不断扩充着的东西，习惯将经常被修改的目录放在该目录下。包括各种<strong>日志文件</strong>。</p><p>&#x2F;selinux (security-enhanced linux): SELinux是一种安全子系统，它能控制程序只访问特定文件，有三种工作模式，可自行设置。</p><h2 id="远程登录linux"><a href="#远程登录linux" class="headerlink" title="远程登录linux"></a>远程登录linux</h2><p>将来开发的时候，linux是部署到公网上的，余姚远程登录进行管理。<br>怎么登录？工具-xshell<br>怎么上传下载文件？工具-xftp</p><p>首先演示xshell，配置好虚拟机汇总的ifconfig显示的ip，点击确定建立会话连接<br><img src="/2024/09/25/linux/60cd2bfba9ab8abeb792cb970cfa0473.png"><br>xftp类似，想要传输右键文件点击传输即可。</p><h2 id="vi和vim编辑器"><a href="#vi和vim编辑器" class="headerlink" title="vi和vim编辑器"></a>vi和vim编辑器</h2><p>Linux系统会内置vi文本编辑器。<br>Vim具有程序编程的能力，可以看作是Vi的增强版本，可以主动地以字体颜色辨别语法的正确性，方便程序设计。代码补全、编译及错误跳转等方便编程的功能特别丰富，再程序员中被广泛使用。</p><h3 id="vi和vim常用的三种模式"><a href="#vi和vim常用的三种模式" class="headerlink" title="vi和vim常用的三种模式"></a>vi和vim常用的三种模式</h3><h4 id="正常模式："><a href="#正常模式：" class="headerlink" title="正常模式："></a>正常模式：</h4><p>以vim打开一个档案就直接进入一般模式(默认模式)。在这个模式中，你可以使用<strong>上下左右</strong>按键来移动光标，你可以使用<strong>删除字符</strong>或<strong>删除整行</strong>来处理档案内容，也可以使用<strong>复制、粘贴</strong>来处理你的文件数据。</p><h4 id="插入模式："><a href="#插入模式：" class="headerlink" title="插入模式："></a>插入模式：</h4><p>按下i，I，o，O，a，A，r，R等任何一个字母之后才会进入编辑模式，<strong>一般来说按i即可</strong>。</p><h4 id="命令行模式："><a href="#命令行模式：" class="headerlink" title="命令行模式："></a>命令行模式：</h4><p>先输入esc，再输入冒号”:”或“&#x2F;”，就能切换到命令行模式。在这个模式中，可以提供你相关指令，完成读取、写入(w)、替换、离开vim(q)、显示行号、写入并退出(wq)等动作。<br><strong>wq是保存并退出，q是直接退出</strong>，具体如下<br><img src="/2024/09/25/linux/5774837696671fa28430de0e3d6affa8.png"></p><h3 id="vi和vim快捷键"><a href="#vi和vim快捷键" class="headerlink" title="vi和vim快捷键"></a>vi和vim快捷键</h3><p>拷贝当前行：在一般模式下输入yy ；拷贝当前行向下的5行：在一般模式下输入5yy ；并粘贴(输入p)</p><p>删除当前行：在一般模式下输入dd ；删除当前行向下的5行：在一般模式下输入5dd</p><p>在文件中查找某个单词：在<strong>命令行模式</strong>下输入&#x2F;单词，回车就会对单词进行查找，<strong>输入n就是查找下一个单词的位置</strong></p><p>设置文件的行号，取消文件的行号：在<strong>命令行模式</strong>下，输入“:set nu”和“:set nonu”</p><p>编辑&#x2F;etc&#x2F;profile文件，在一般模式下，使用快捷键到该文档的最末行<strong>G</strong>和最首行<strong>gg</strong><br>在一个文件中输入“hello”，然后又撤销这个动作：在<strong>一般模式</strong>下，输入<strong>u</strong></p><p>编辑&#x2F;etc&#x2F;profile文件，并将光标移动到20行：在<strong>一般模式</strong>下，<strong>输入“20“再输入”shift+g”</strong><br>更多的看整理的文档<br><img src="/2024/09/25/linux/484f46f9f156a8e3d257194d52fcbf93.png"></p><h2 id="关机-重启命令"><a href="#关机-重启命令" class="headerlink" title="关机&amp;重启命令"></a>关机&amp;重启命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now        立刻关机   h代表halt，停止的意思</span><br><span class="line">shutdown -h 1          1分钟之后关机，shutdown默认代表该命令</span><br><span class="line">shutdown -r now        r代表reboot，现在立刻重启计算机</span><br><span class="line">halt                   关机，和上面作用一样</span><br><span class="line">reboot                 现在重启计算机</span><br><span class="line">sync                   把内存的数据同步到磁盘，房子在内存中的数据丢失（建议关机和重启的时候运行这个命令，一般而言关机和重启命令就已经执行了sync）</span><br></pre></td></tr></table></figure><h2 id="用户登录和注销"><a href="#用户登录和注销" class="headerlink" title="用户登录和注销"></a>用户登录和注销</h2><p>一般而言，登录时尽量少用root账号登录，因为他是张傲管理员，有最大权限。<br>可以利用普通用户登录在使用su-用户名切换为管理员模式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - root</span><br></pre></td></tr></table></figure><p>如何退出（注销）该用户呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logout</span><br></pre></td></tr></table></figure><p><strong>logout只有在运行级别3有效（shell）</strong></p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>用户管理<strong>要求在root的权限下进行添加</strong></p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><p>添加一个用户mlan，默认该目录的家目录是在home&#x2F;milan。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd milan</span><br></pre></td></tr></table></figure><p>也可以通过 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -d /home/test milan</span><br></pre></td></tr></table></figure><p>将其目录指定在一个指定的文件夹中。</p><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><p>例如给milan修改密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd milan</span><br></pre></td></tr></table></figure><p>注意，如果不指定密码，默认修改当前用户的密码，要指定用户名。</p><h3 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h3><p>例如给删除milan，分两种情况。<br>第一种，保留家目录如&#x2F;home&#x2F;milan</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel milan</span><br></pre></td></tr></table></figure><p>第二种，连同家目录一起删除（这一部分要慎重，会连同用户的资料一起消失），一般情况下建议保留（**-r 代表recursive，递归删除**）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel -r milan</span><br></pre></td></tr></table></figure><h3 id="查询用户信息"><a href="#查询用户信息" class="headerlink" title="查询用户信息"></a>查询用户信息</h3><p>查询root用户信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id root</span><br></pre></td></tr></table></figure><p>会显示uid，gid和组。</p><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p>已经讲过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - root</span><br></pre></td></tr></table></figure><p>小细节，权限高到权限低的用户不用输入密码，反之要输入密码。<br>使用exit或者logout退出。</p><h3 id="查看当前用户"><a href="#查看当前用户" class="headerlink" title="查看当前用户"></a>查看当前用户</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who am i</span><br></pre></td></tr></table></figure><p>会告诉我第一次登录用户名称是什么，登录的时间，登录的ip。（<strong>显示的全是第一次登录的用户信息</strong>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><p>这个只输出用户名（而且是当前用户而不是第一次登录的用户）</p><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><p>类似于角色，系统可以对有共性（可以理解为是权限）的角色进行统一管理。</p><h4 id="新增组"><a href="#新增组" class="headerlink" title="新增组"></a>新增组</h4><p>新增组wudang</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd wudang</span><br></pre></td></tr></table></figure><h4 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h4><p>删除组wudang</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel wudang</span><br></pre></td></tr></table></figure><h4 id="增加用户直接上组"><a href="#增加用户直接上组" class="headerlink" title="增加用户直接上组"></a>增加用户直接上组</h4><p>如果新加了一个用户（如milan）且没有分配组的话，会默认创建一个叫milan的组，并把milan放进去（<strong>之前介绍可可以通过id username查看</strong>）</p><p>如果想要新增用户能够直接上组，可以通过以下方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useradd -g 用户组 用户名</span><br><span class="line">例如</span><br><span class="line">useradd -g wudang milan  把milan添加到wudang这个组中</span><br></pre></td></tr></table></figure><h4 id="修改用户的组"><a href="#修改用户的组" class="headerlink" title="修改用户的组"></a>修改用户的组</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -g 用户组 用户名</span><br></pre></td></tr></table></figure><h4 id="用户和组相关的文件"><a href="#用户和组相关的文件" class="headerlink" title="用户和组相关的文件"></a>用户和组相关的文件</h4><p><strong>复习一下：&#x2F;etc存所有的系统管理所需要的配置文件和子目录</strong></p><ul><li>&#x2F;etc&#x2F;passwd文件<br>用户（user）的配置文件，记录用户的各种信息<br>每行的含义：<strong>用户名：口令(写为x是因为你看不到，加密了)：用户标识号（uid）：组标识号（gid）：注释性描述：主目录（家目录）：登录Shell(我们用的一般是bash)</strong><br>举个例子</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure><p>补充：cd指令，linux内核无法识别，要通过shell翻译解释，而shell的种类很多，有bash，tcsh，csh等等</p><ul><li><p>&#x2F;etc&#x2F;shadow文件<br>口令的配置文件<br>每行的含义：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志<br>注意：<br>1.每次输入的口令，会在shadow文件中验证<br>2.最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志都是用一种特殊的标识表示的，你是看不懂的</p></li><li><p>&#x2F;etc&#x2F;group文件<br>组（group）的配置文件，记录Linux包含的组的信息<br>每行含义：组名：口令：组标识号：组内用户列表<br>注意：组内用户列表看不到，它隐藏了</p></li></ul><h2 id="linux实操篇——实用指令"><a href="#linux实操篇——实用指令" class="headerlink" title="linux实操篇——实用指令"></a>linux实操篇——实用指令</h2><h3 id="linux运行级别"><a href="#linux运行级别" class="headerlink" title="linux运行级别"></a>linux运行级别</h3><h4 id="基本级别说明："><a href="#基本级别说明：" class="headerlink" title="基本级别说明："></a>基本级别说明：</h4><p>0：关机<br>1：单用户【<strong>找回丢失密码</strong>】<br>2：多用户状态没有网络服务（用的很少）<br>3：多用户状态有网络服务（用的最多的，不带图形界面，节省资源；支持多用户且有网络服务-在实际生产环境中使用最多）<br>4：系统未使用保留给用户（用的比较少）<br>5：图形界面（启动后默认进入的级别，是多用户的）<br>6：系统重启<br>常用运行级别是3和5，也可以指定默认运行级别，后面演示</p><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>命令：init [0123456]<br>应用案例：通过init来切换不同的运行级别，比如修改级别为3：则命令为init 3</p><h4 id="CentOS7运行级别说明"><a href="#CentOS7运行级别说明" class="headerlink" title="CentOS7运行级别说明"></a>CentOS7运行级别说明</h4><p>在centos7以前，我们是在&#x2F;etc&#x2F;inittab文件中进行修改，它里面有个数字。<br>到了centos7，进行了简化，在&#x2F;etc&#x2F;inittab文件中有如下：<br>multi-user.target：analogous to runlevel 3 (多用户，等价于级别3)<br>graphical.target：analogous to runlevel 5 (图形化，等价于级别5)</p><h4 id="To-view-current-default-target-run-（以下指令可以查看当前运行级别）"><a href="#To-view-current-default-target-run-（以下指令可以查看当前运行级别）" class="headerlink" title="To view current default target, run:（以下指令可以查看当前运行级别）"></a>To view current default target, run:（以下指令可以查看当前运行级别）</h4><p>systemctl get-default</p><h4 id="To-set-a-default-target-run-（以下指令可以设置默认运行级别）"><a href="#To-set-a-default-target-run-（以下指令可以设置默认运行级别）" class="headerlink" title="To set a default target, run:（以下指令可以设置默认运行级别）"></a>To set a default target, run:（以下指令可以设置默认运行级别）</h4><p>systemctl set-default TARGET.target</p><h3 id="找回root密码"><a href="#找回root密码" class="headerlink" title="找回root密码"></a>找回root密码</h3><p>注意：不同版本找回密码的方式可能有一些小区别<br>1.首先，启动系统，进入开机界面，在界面中按”e“进入编辑界面。如图<br><img src="/2024/09/25/linux/927fd6e5f7bdb856347d6f3cacdf4d98.png"><br>2.进入编辑界面，使用键盘的上下键将光标往下移动，找到以”Linux16“开头内容所在的行数，在行的最后面输入：init&#x3D;&#x2F;bin&#x2F;sh。如图<br><img src="/2024/09/25/linux/8d7617d00dc5edb9281ce95f7e828cdf.png"><br>3.接着，输入完成后，直接按快捷键：Ctrl+x进入单用户模式。<br>4.接着，在光标闪烁的位置中输入：mount -o remount,rw &#x2F; （注意：各个单词间有空格），完成后按键盘的回车键，如图。<br><img src="/2024/09/25/linux/a4ae70310e5ee5a8da638ac16f317f25.png"><br>5.在新的一行最后面输入：passwd，完成后按键盘的回车键(Enter)。输入密码，然后再次确认密码即可（密码长度最好是8位以上，但不是必须的），密码修改成功后，会显示passwd。。。的样式，说明密码修改成功。<br>6.接着，在光标闪烁的位置中(最后一行中)输入：touch &#x2F;.autorelabel（注意：touch与 &#x2F;之间有一个空格），完成后按键盘的回车键（Enter）。<br>7.继续在光标闪烁的位置中，输入：exec &#x2F;sbin&#x2F;init（注意： exec与 &#x2F;之间有一个空格），完成后按键盘的回车键（Enter），等待系统自动修改密码（这个过程时间可能有点长，耐心等待），完成后，系统会自动重启，新的密码生效了</p><h3 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h3><h4 id="man获取帮助信息"><a href="#man获取帮助信息" class="headerlink" title="man获取帮助信息"></a>man获取帮助信息</h4><p><strong>man的全名是manual</strong><br>基本语法：man【命令或配置文件】（功能描述：获取帮助信息）<br>案例：查看ls命令的帮助信息：man ls<br>注意：<br>1.如果帮助信息太长，没有显示完全，那么按空格键，会继续往下显示。<br>2.ls中常用的选项<br>-a：列出所有文件，包括以”.“开头的隐含文件（在linux中，隐含文件是以”.“开头的，a代表all）。<br>-l：单行输出。</p><p>举个例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br><span class="line">drwx------. 14 root root 4096 9月 28 16:42 .cache</span><br></pre></td></tr></table></figure><p>这一行显示的是一个目录的详细信息，通常是通过 <code>ls -l</code> 命令获取的。各个字段的含义如下：</p><ol><li><p>**drwx——**：表示文件类型和权限。</p><ul><li><code>d</code> 表示这是一个目录。</li><li><code>rwx</code> 表示所有者（root）有读、写和执行权限。</li><li><code>------</code> 表示与组用户和其他用户没有任何权限。</li></ul></li><li><p><strong>14</strong>：表示目录中包含的硬链接数（即子目录数量加上当前目录 <code>.</code> 和父目录 <code>..</code> 的链接）。</p></li><li><p><strong>root</strong>：表示目录的所有者用户名。</p></li><li><p><strong>root</strong>：表示目录所属的用户组名。</p></li><li><p><strong>4096</strong>：表示目录的大小，单位为字节（这里是 4096 字节）。</p></li><li><p><strong>9月 28 16:42</strong>：表示最后修改时间，格式为“月份 日 时:分”。</p></li><li><p><strong>.cache</strong>：这是目录的名称。</p></li></ol><p>3.按h寻求man指令的帮助，按q退出man指令。<br>4.选项可以组合使用，如-la（顺序无所谓，也可以是-al），则表示单行输出，且包含所有隐藏文件<br>5.ls -al默认是查看当前目录的，如果要查看root目录下的文件，则可以用ls -al &#x2F;root</p><h4 id="help指令"><a href="#help指令" class="headerlink" title="help指令"></a>help指令</h4><p>基本语法：help命令（功能描述：获得shell内置命令的帮助信息）<br>注意：<br>help命令只能显示shell内置命令的帮助信息，而linux系统中绝大多数命令是外部命令。而通过man命令查看其它命令的详细文档。没有内部与外部命令的区分，因为 man 工具是显示系统手册页中的内容，man 得到的内容比 help 更多更详细。</p><p>案例：查看shell内置的cd命令的帮助信息: help cd</p><h3 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h3><h4 id="pwd指令"><a href="#pwd指令" class="headerlink" title="pwd指令"></a>pwd指令</h4><p>基本语法：pwd （功能描述：显示当前工作目录的绝对路径）<br>应用实例：案例：显示当前工作目录的绝对路径</p><h4 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a>ls指令</h4><p>基本语法：ls【选项】【目录或是文件】<br>常用选项<br>-a：显示当前目录所有的文件和目录，包括隐藏的<br>-l：以列表的方式显示信息</p><p>应用实例<br>案例：查看当前目录的所有内容信息：ls</p><h4 id="cd指令"><a href="#cd指令" class="headerlink" title="cd指令"></a>cd指令</h4><p>基本语法：cd【参数】(功能描述：切换到指定目录)<br>理解：绝对路径和相对路径<br>cd ~或cd：回到自己的家目录，比如你是root，cd ~，则到&#x2F;root，如果是tom，cd ~，则到&#x2F;home&#x2F;tom<br>cd .. 回到当前目录的上一级目录</p><p>应用实例<br>案例1：使用绝对路径切换到root目录：cd &#x2F;root<br>案例2：使用相对路径到&#x2F;root目录：比如在&#x2F;home&#x2F;tom，cd …&#x2F;…&#x2F;root<br>案例3：表示回到当前目录的上一级目录：cd …<br>案例4：回到家目录：cd ~</p><h4 id="mkdir指令-make-directory"><a href="#mkdir指令-make-directory" class="headerlink" title="mkdir指令(make directory)"></a>mkdir指令(make directory)</h4><p>mkdier指令用于创建目录<br>基本语法：mkdir 【选项】 要创建的目录<br>常用选项<br>-p：创建多级目录<br>应用案例<br>案例1：创建一个目录&#x2F;home&#x2F;dog：mkdir &#x2F;home&#x2F;dog<br>案例2：创建多级目录&#x2F;home&#x2F;animal&#x2F;tiger：mkdir -p &#x2F;home&#x2F;animal&#x2F;tiger</p><h4 id="rmdir指令"><a href="#rmdir指令" class="headerlink" title="rmdir指令"></a>rmdir指令</h4><p><strong>rm是remove的意思</strong><br>rmdir指令删除空目录<br>基本语法<br>rmdir 【选项】要删除的空目录<br>应用实例<br>案例：删除一个空目录 &#x2F;home&#x2F;dog：rmdir &#x2F;home&#x2F;dog<br>使用细节<br>rmdir 删除的是空目录，如果目录下有内容时无法删除的。<br>提示：如果需要删除非空目录，需要使用 ’rm -rf 要删除的目录‘（-rf表示强制递归）<br>比如：rm -rf &#x2F;home&#x2F;animal<br>注意：<br>1.使用rm -rf进行删除时，要非常谨慎。<br>2.rm指令单独只能删除文件，加上参数-r可以删除包含文件的文件夹。但是在删除前shell会询问。</p><h4 id="touch指令"><a href="#touch指令" class="headerlink" title="touch指令"></a>touch指令</h4><p>touch指令创建空文件<br>基本语法<br>touch文件名称<br>应用实例<br>案例：在&#x2F;home目录下，创建一个空文件 hello.txt：touch hello.txt</p><h4 id="cp指令"><a href="#cp指令" class="headerlink" title="cp指令"></a>cp指令</h4><p>cp指令拷贝文件到指定目录</p><p>基本语法<br>cp 【选项】 source dest<br>常用选项<br>-r：递归复制整个文件夹</p><p>应用实例：<br>案例1：将&#x2F;home&#x2F;hello.txt拷贝到&#x2F;home&#x2F;bbb目录下：在&#x2F;home目录下，cp hello.txt bbb<br>案例2：递归复制整个文件夹，比如将&#x2F;home&#x2F;bbb整个目录，拷贝到&#x2F;opt：cp -r &#x2F;home&#x2F;bbb &#x2F;opt（这样拷贝是将整个目录，包括目录bbb本身，都拷贝到&#x2F;opt下的）<br>使用细节<br>强制覆盖不提示的方法：\cp：如上面的指令如果要强制覆盖，则为\cp -r &#x2F;home&#x2F;bbb &#x2F;opt</p><h4 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a>rm指令</h4><p>说明：rm指令移除文件或目录<br>基本语法<br>rm 【选项】要删除的文件或目录<br>常用选项<br>-r：递归删除整个文件夹<br>-f：强制删除不提示</p><p>应用实例<br>案例1：将&#x2F;home&#x2F;hello.txt删除：rm &#x2F;home&#x2F;hello.txt ，在提示中选择y<br>案例2：递归删除整个目录 &#x2F;home&#x2F;bbb：rm -r &#x2F;home&#x2F;bbb（删除整个目录，但每删其中的一个文件都会提示）<br>使用细节：<br>强制删除不提示的方法：带上-f参数即可</p><h4 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a>mv指令</h4><p>mv<strong>移动文件与目录</strong>或<strong>重命名</strong><br>基本语法<br>mv oldNameFile newNameFile （功能描述：重命名）<br>mv &#x2F;temp&#x2F;movefile &#x2F;targetFolder（功能描述：移动文件）<br>注意：<br>1.重命名是在同一个目录下<br>2.移动是在不同的目录下</p><p>应用实例<br>案例1：将&#x2F;home&#x2F;cat.txt文件重新命名为pig.txt：在&#x2F;home目录下，mv cat.txt pig.txt<br>案例2：将&#x2F;home&#x2F;pig.txt文件移动到&#x2F;root目录下：在home目录下，mv cat.txt &#x2F;root<br>案例3：移动整个目录，比如将&#x2F;opt&#x2F;bbb移动到&#x2F;home下，并重命名为uuu：mv &#x2F;opt&#x2F;bbb &#x2F;home&#x2F;uuu（<strong>注意，&#x2F;home目录下本来没有&#x2F;uuu目录</strong>）<br>注意：<br>对案例3，如果&#x2F;home目录下本来有&#x2F;uuu目录，则mv &#x2F;opt&#x2F;bbb &#x2F;home&#x2F;uuu命令会把&#x2F;bbb目录移到&#x2F;home&#x2F;uuu目录下</p><h4 id="cat指令"><a href="#cat指令" class="headerlink" title="cat指令"></a>cat指令</h4><p>cat查看文件内容（与vim的区别是，cat只能查看，不能修改，更安全）<br>基本语法<br>cat [选项] 要查看的文件<br>常用选项<br>-n：显示行号<br>应用实例：<br>案例1：&#x2F;etc&#x2F;profile 文件内容，并显示行号：cat -n &#x2F;etc&#x2F;profile<br>使用细节<br>cat只能浏览文件，而不能修改文件，为了浏览方便，一般会带上 管道命令：| more<br>补充：管道命令有点类似于，将前面的结果，再交给下一个指令进行处理，管道命令就是一个竖杠，再带一个其他命令</p><h4 id="more指令"><a href="#more指令" class="headerlink" title="more指令"></a>more指令</h4><p>more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more指令中内置了若干快捷键（交互的指令），详见操作说明<br>基本语法<br>more要查看的文件<br>操作说明，如图</p><p><img src="/2024/09/25/linux/87f2aacfbbb5f62c555082ef20c0bdc8.png"><br>应用实例<br>案例：采用more查看文件&#x2F;etc&#x2F;profile</p><h4 id="less指令"><a href="#less指令" class="headerlink" title="less指令"></a>less指令</h4><p>less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。<br>基本语法<br>less要查看的文件<br>操作说明<br><img src="/2024/09/25/linux/76946b4c302229bdf7ea1f19ecd119f6.png"><br>应用实例<br>案例：采用less查看一个大文本文件：less &#x2F;opt&#x2F;杂文.txt</p><h4 id="echo指令"><a href="#echo指令" class="headerlink" title="echo指令"></a>echo指令</h4><p>echo输出内容到控制台<br>基本语法<br>echo [选项] [输出内容]<br>应用实例<br>案例1：使用echo指令输出环境变量，比如输出环境变量$PATH：echo $PATH ；输出主机名$HOSTNAME: echo $HOSTNAME<br>案例2：使用echo指令输出hello,world！：echo ‘hello，world~“（引号可加可不加）</p><h4 id="head指令"><a href="#head指令" class="headerlink" title="head指令"></a>head指令</h4><p>head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容<br>基本语法<br>head 文件（功能描述：查看文件头10行内容）<br>head -n 5文件 （功能描述：查看文件头5行内容，5可以是任意行数）<br>应用实例<br>案例：查看&#x2F;etc&#x2F;profile的前面5行代码：head -n 5 &#x2F;etc&#x2F;profile（去掉-n 5，默认看前10行）<br>注意：空行也算一行</p><h4 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a>tail指令</h4><p>tail用于输出文件中尾部的内容，默认情况下tail指令显示文件的前10行内容。<br>基本语法<br>1.tail 文件 (功能描述：查看文件尾10行内容）<br>2.tail -n 5 文件 （功能描述：查看文件尾5行内容，5可以是任意行数)<br>3.tail -f 文件 （功能描述：实时追踪该文档的所有更新）<br>应用实例<br>案例1：查看&#x2F;etc&#x2F;profile最后5行的代码：tail -n 5 &#x2F;etc&#x2F;profile<br>案例2：实时监控mydate.txt，看看当该文件有变化时，是否看到，实时追加hello,world</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch mydate.txt</span><br><span class="line">tail -f mydate.txt</span><br></pre></td></tr></table></figure><p>此时在另一个终端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;hello&#x27; &gt; /home/mydate.txt</span><br></pre></td></tr></table></figure><p>此时第一个终端输出hello<br>注意：<br>退出监控是ctrl+C</p><h4 id="指令和-指令"><a href="#指令和-指令" class="headerlink" title="&gt;指令和&gt;&gt;指令"></a>&gt;指令和&gt;&gt;指令</h4><p>关于&gt;输出重定向和&gt;&gt;追加<br>基本语法<br>1.ls -l &gt;文件 （功能描述：列表的内容写入文件a.txt中（覆盖写））<br>2.ls -al &gt;&gt;文件 （功能描述：列表的内容追加到文件aa.txt的末尾）<br>3.cat 文件1&gt;文件2 （功能描述：将文件1的内容覆盖到文件2的内容）<br>4.echo ’内容‘ &gt;&gt; 文件 （功能描述：将内容追加到文件中）<br>应用实例<br>案例1：将&#x2F;home目录下的文件列表写入&#x2F;home&#x2F;info.txt中，覆盖写入：ls -l &#x2F;home &gt; &#x2F;home&#x2F;info.txt（如果没有info.txt，则会创建）<br>案例2：将当前日历信息追加到&#x2F;home&#x2F;mycal文件中：cal &gt;&gt; &#x2F;home&#x2F;mycal</p><h4 id="ln指令"><a href="#ln指令" class="headerlink" title="ln指令"></a>ln指令</h4><p>软链接也称为符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径<br>基本语法<br>ln -s 【原文件或目录】 【软链接名】 （功能描述：给原文件创建一个软链接）<br>应用实例<br>案例1：在&#x2F;home目录下创建一个软链接myroot，连接到&#x2F;root目录：ln -s &#x2F;root &#x2F;home&#x2F;myroot<br>案例2：删除软连接myroot：rm &#x2F;home&#x2F;myroot（会提示是否删除符号链接）<br>注意：<br>如果rm &#x2F;home&#x2F;myroot&#x2F;，会提示无法删除&#x2F;home&#x2F;myroot&#x2F;，是一个目录<br>细节说明<br>当我们使用pwd指令查看目录时，仍然看到的是软链接所在目录</p><h4 id="history指令"><a href="#history指令" class="headerlink" title="history指令"></a>history指令</h4><p>查看已经执行过的历史指令，也可以执行历史指令<br>基本语法<br>history（功能描述：查看已经执行过的历史命令）<br>应用实例<br>案例1：显示所有的历史命令：history<br>案例2：显示最近使用过的10个指令：history 10<br>案例3：执行历史编号为5的指令：**!5** （可以输入负数，表示倒数的指令）</p><h3 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h3><h4 id="date指令-显示当前日期"><a href="#date指令-显示当前日期" class="headerlink" title="date指令-显示当前日期"></a>date指令-显示当前日期</h4><p>基本语法<br>1.date （功能描述：显示当前时间）<br>2.date +%Y （功能描述：显示当前年份）<br>3.date +%m （功能描述：显示当前月份）<br>4.date +%d （功能描述：显示当前是哪一天）<br>5.date ’+%Y-%m-%d %H:%M:%S‘ （功能描述：显示年月日时分秒，<strong>这里的-和:是为了分隔，你用+也是一样的，只不过会显示+罢了,但是最好还是按照规范输出</strong>。）<br>应用实例<br>案例1：显示当前时间信息：date （2023年 01月 06日 星期五 09:58:54 CST）<br>案例2：显示当前时间年月日：date ’+%Y-%m-%d‘<br>案例3：显示当前时间年月日时分秒：date ‘+%Y-%m-%d %H:%M:%S’</p><h4 id="date指令-设置日期"><a href="#date指令-设置日期" class="headerlink" title="date指令-设置日期"></a>date指令-设置日期</h4><p>基本语法<br>date -s 字符串时间<br>应用实例<br>案例1：设置系统当前时间，比如设置成2021-11-11 11:22:22：date -s ‘2021-11-11 11:22:22’</p><h4 id="cal指令"><a href="#cal指令" class="headerlink" title="cal指令"></a>cal指令</h4><p>查看日历指令<br>基本语法<br>cal 【选项】（功能描述：不加选项，显示本月日历）<br>应用实例<br>案例1：显示当前日历：cal<br>案例2：显示2020年日历：cal 2020</p><h3 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h3><h4 id="find指令"><a href="#find指令" class="headerlink" title="find指令"></a>find指令</h4><p>find指令将从指定目录向下<strong>递归</strong>地遍历其各个子目录，将满足条件的文件或者目录显示在终端。<br>基本语法<br>find 【搜索范围】【选项】<br>搜索返回写路径，如&#x2F;home是搜索home 文件夹之下的。<strong>如果是整个系统下，则用&#x2F;</strong><br>选项说明<br><img src="/2024/09/25/linux/20c39cdb248921e4f8293693e1310ee5.png"></p><p>应用案例<br>案例1：按文件名：根据名称查找&#x2F;home目录下的hello.txt文件：find &#x2F;home -name hello.txt(没找到就没有信息)<br>案例2：按拥有者：查找&#x2F;opt目录下，用户名称为nobody的文件：find &#x2F;opt -user nobody<br>案例3：查找整个linux系统下大于200M的文件（+n大于 -n小于 n等于，单位有k,M,G）：find &#x2F; -size +200M<br>补充：<br>ls -lh，h表示人可以看清楚的形式展示，此时显示的文件大小会自动转化为人可以看明白的xx M</p><h4 id="locate指令"><a href="#locate指令" class="headerlink" title="locate指令"></a>locate指令</h4><p>locate指令可以快速定位文件路径。<strong>locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件</strong>。locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。<br>基本语法:<br>locate 搜索文件<br>特别说明:<br><strong>由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库</strong><br>应用实例<br>案例1：请使用locate指令快速定位hello.txt文件所在目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">updatedb</span><br><span class="line">locate hello.txt</span><br></pre></td></tr></table></figure><h4 id="which指令"><a href="#which指令" class="headerlink" title="which指令"></a>which指令</h4><p>可以查看某个指令在哪个目录下，比如ls指令在哪个目录：which ls<br>从而显示这个指令的代码在那个路径中。</p><h4 id="grep指令和管道符号"><a href="#grep指令和管道符号" class="headerlink" title="grep指令和管道符号|"></a>grep指令和管道符号|</h4><p>grep过滤查找，管道符，“|”，表示将前一个命令的处理结果传递给后面的命令处理<br>基本语法<br>grep 【选项】 查找内容 源文件<br>常用选项<br><img src="/2024/09/25/linux/95f3b604c552fa9cbc7d697efa24b0fd.png"><br>应用实例<br>案例1：请在hello.txt文件中，查找’yes‘所在行，并显示行号<br>方法1：cat &#x2F;home&#x2F;hello.txt | grep -n ’yes‘<br>方法2：grep -n ’yes‘ &#x2F;home&#x2F;hello.txt</p><h3 id="压缩和解压类"><a href="#压缩和解压类" class="headerlink" title="压缩和解压类"></a>压缩和解压类</h3><h4 id="gzip-gunzip指令"><a href="#gzip-gunzip指令" class="headerlink" title="gzip&#x2F;gunzip指令"></a>gzip&#x2F;gunzip指令</h4><p>gzip用于压缩文件，gunzip用于解压的<br>基本语法<br>gzip文件 （功能描述：压缩文件，只能将文件压缩为*.gz文件）<br>gunzip文件.gz （功能描述：解压缩文件命令）<br>应用实例<br>案例1：gzip压缩，将&#x2F;home下的hello.txt文件进行压缩：gzip &#x2F;home&#x2F;hello.txt<br>案例2：gunzip压缩，将&#x2F;home下的hello.txt.gz文件进行解压缩：gunzip &#x2F;home&#x2F;hello.txt.gz</p><h4 id="zip-unzip指令"><a href="#zip-unzip指令" class="headerlink" title="zip&#x2F;unzip指令"></a>zip&#x2F;unzip指令</h4><p>zip用于压缩文件（<strong>或目录</strong>），unzip用于解压的，这个在项目打包发布中很有用的<br>基本语法<br>zip 【选项】xxx.zip 将要压缩的内容（功能描述：压缩文件和目录的命令）<br>unzip【选项】 xxx.zip （功能描述：解压缩文件）<br>zip常用选项<br>-r：递归压缩，即压缩目录<br>unzip的常用选项<br>-d&lt;目录&gt;：指定解压后文件的存放目录<br>应用实例<br>案例1：将&#x2F;home下的所有文件进行压缩成myhome.zip：zip -r myhome.zip &#x2F;home(将home目录<strong>及</strong>其包含的文件和子文件夹都压缩）<br>案例2：将myhome.zip解压到&#x2F;opt&#x2F;tmp目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /opt/tmp</span><br><span class="line">unzip -d /opt/tmp /home/myhome.zip</span><br></pre></td></tr></table></figure><h4 id="tar指令"><a href="#tar指令" class="headerlink" title="tar指令"></a>tar指令</h4><p>tar指令是打包指令，最后打包后的文件是.tar.gz的文件<br>基本语法<br>tar 【选项】xxx.tar.gz 打包的内容 （功能描述：打包目录，压缩后的文件格式.tar.gz）<br>选项说明<br><img src="/2024/09/25/linux/78fb8bac831ae6b71b992c559ea18c81.png"><br><strong>-z表示指定gzip格式压缩或解压</strong><br><strong>-v  verbose</strong><br>应用实例<br>案例1：压缩多个文件，将&#x2F;home&#x2F;pig.txt和&#x2F;home&#x2F;cat.txt压缩成pc.tar.gz：<br>tar -zcvf pc.tar.gz &#x2F;home&#x2F;pig.txt &#x2F;home&#x2F;cat.txt<br>(压缩时候在绝对路径下压缩，会把&#x2F;home目录也压缩进去，在相对路径下压缩则不会这样）<br>案例2：将&#x2F;home的文件夹压缩成myhome.tar.gz:<br>tar -zcvf myhome.tar.gz &#x2F;home<br>案例3：将pc.tar.gz解压到当前目录<br>tar -zxvf pc.tar.gz<br>案例4：将myhome.tar.gz解压到&#x2F;opt&#x2F;tmp2目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /opt/tmp2</span><br><span class="line">tar -zxvf /home/myhome.tar.gz -C /opt/tmp2</span><br></pre></td></tr></table></figure><p>注意：<br>1.-C 目标目录表示指定目标目录<br>2.任何压缩方法，被压缩文件路径最好使用相对路径，否则会自动压缩绝对路径多创文件夹<br>补充：打包解包是针对.tar文件而言的，.tar文件就是将多个文件合并成一个单文件，解压和压缩是针对.gz文件而言，-c是打包成.tar文件，-x是把.tar包解开，-z会根据带的x还是c来决定解压还是压缩</p><h2 id="Linux实操篇-组管理和权限管理"><a href="#Linux实操篇-组管理和权限管理" class="headerlink" title="Linux实操篇-组管理和权限管理"></a>Linux实操篇-组管理和权限管理</h2><h3 id="Linux组基本介绍"><a href="#Linux组基本介绍" class="headerlink" title="Linux组基本介绍"></a>Linux组基本介绍</h3><p>在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其他组的概念。<br>1.所有者（谁创建谁就是所有者，但是后续可以修改）<br>2.所在组（创建者所属用户组，但后续可以修改）<br>3.其他组<br>4.改变用户所在的组</p><h3 id="文件-目录-所有者"><a href="#文件-目录-所有者" class="headerlink" title="文件&#x2F;目录 所有者"></a>文件&#x2F;目录 所有者</h3><p>一般为文件的创建者，谁创建了该文件，就自然地成为该文件的所有者。</p><h4 id="查看文件的所有者"><a href="#查看文件的所有者" class="headerlink" title="查看文件的所有者"></a>查看文件的所有者</h4><p>指令：ls -ahl<br>应用实例</p><h4 id="修改文件所有者（ch-ange-own-er）"><a href="#修改文件所有者（ch-ange-own-er）" class="headerlink" title="修改文件所有者（ch-ange own-er）"></a>修改文件所有者（ch-ange own-er）</h4><p>指令：chown 用户名 文件名<br>应用案例<br>要求：使用root创建一个文件apple.txt，然后将其所有者修改成tom：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch apple.txt</span><br><span class="line">chown tom apple.txt # tom用户必须存在</span><br></pre></td></tr></table></figure><p>注意：<strong>改变所有者，所在组不会变</strong></p><h3 id="组的创建"><a href="#组的创建" class="headerlink" title="组的创建"></a>组的创建</h3><h4 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h4><p>groupadd 组名</p><h4 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h4><p>创建一个组，monster：groupadd monster<br>创建一个用户fox，并放入monster组中：-useradd -g monster fox</p><h4 id="文件-目录-所在组"><a href="#文件-目录-所在组" class="headerlink" title="文件&#x2F;目录 所在组"></a>文件&#x2F;目录 所在组</h4><p>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组。(默认）</p><h4 id="查看文件-目录所在组"><a href="#查看文件-目录所在组" class="headerlink" title="查看文件&#x2F;目录所在组"></a>查看文件&#x2F;目录所在组</h4><p>基本指令<br>ls -ahl<br>应用实例<br>使用fox创建一个文件，看看该文件属于哪个组？<br>-rw-r–r–. 1 fox monster 0 1月 7 12:50 ok.txt</p><h4 id="修改文件-目录所在的组"><a href="#修改文件-目录所在的组" class="headerlink" title="修改文件&#x2F;目录所在的组"></a>修改文件&#x2F;目录所在的组</h4><p>基本指令<br>chgrp 组名 文件名<br>应用实例<br>使用roo他用户创建文件orange.txt，看看当前这个文件属于哪个组，然后将这个文件所在组，修改到fruit组。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd fruit</span><br><span class="line">touch orange.txt</span><br></pre></td></tr></table></figure><p>看看当前这个文件属于哪个组 -&gt; root组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp fruit orange.txt</span><br></pre></td></tr></table></figure><h3 id="其他组"><a href="#其他组" class="headerlink" title="其他组"></a>其他组</h3><p>除文件的所有者和所在组的用户外，系统的其他用户都是文件的其他组</p><h3 id="改变用户所在组"><a href="#改变用户所在组" class="headerlink" title="改变用户所在组"></a>改变用户所在组</h3><p>在添加用户时，可以指定将该用户添加到哪个组中，同样的，用root的管理权限可以改变某个用户所在的组。</p><h4 id="改变用户所在组-1"><a href="#改变用户所在组-1" class="headerlink" title="改变用户所在组"></a>改变用户所在组</h4><p>1.usermod -g 新组名 用户名<br>2.usermod -d 目录名 用户名 改变该用户登录的初始目录（特别说明：用户需要有进入到新目录的权限）</p><h4 id="应用实例-2"><a href="#应用实例-2" class="headerlink" title="应用实例"></a>应用实例</h4><p>将zwj这个用户从原来所在组，修改到wudang组：usermod -g wudang zwj</p><h3 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h3><p>ls -l中显示的内容如下：</p><p>第一列一共有10位，分别用0-9表示，下面是0-9位的说明：<br>1.第0位确定文件类型（d，-，l，c，b）<br>l是链接，相当于windows的快捷方式<br>d是目录，相当于windows的文件夹<br>-是普通文件<br>c是字符设备文件，鼠标，键盘（cd &#x2F;dev可以看到）<br>b是块设备，比如硬盘（cd &#x2F;dev可以看到）<br>2.第1-3位确定所有者（该文件的所有者）拥有该文件的权限。 —User<br>3.第4-6位确定所在组（同用户组的）拥有该文件的权限。—Group<br>4.第7-9位确定其他用户拥有该文件的权限。—Other</p><h3 id="rwx权限详解-难点）"><a href="#rwx权限详解-难点）" class="headerlink" title="rwx权限详解(难点）"></a>rwx权限详解(难点）</h3><h4 id="rwx作用到文件"><a href="#rwx作用到文件" class="headerlink" title="rwx作用到文件"></a>rwx作用到文件</h4><p>1.[r]代表可读（read）：可以读取，查看<br>2.[w]代表可写（write）：可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件<br>3.[x]代表可执行（execute）：可以被执行</p><h4 id="rwx作用到目录"><a href="#rwx作用到目录" class="headerlink" title="rwx作用到目录"></a>rwx作用到目录</h4><p>1.[r]代表可读（read）：可以读取，ls查看目录内容<br>2.[w]代表可写（write）：可以修改，对目录内创建+删除+重命名目录<br>3.[x]代表可执行（execute）：可以进入该目录</p><h3 id="文件及目录权限实际案例"><a href="#文件及目录权限实际案例" class="headerlink" title="文件及目录权限实际案例"></a>文件及目录权限实际案例</h3><h4 id="ls-l中显示的内容如下："><a href="#ls-l中显示的内容如下：" class="headerlink" title="ls -l中显示的内容如下："></a>ls -l中显示的内容如下：</h4><p>-rwxrw-r– 1 root root 1213 Feb 2 09:39 abc</p><p>10个字符确定不同用户能对文件干什么<br>第一个字符代表文件类型：-代表该文件是普通文件<br>其余字符每3个一组（rwx）读（r）写（w）执行（x）<br>第一组rwx：文件拥有者的权限是读、写和执行<br>第二组rw-：所在组的用户的权限是读、写但不能执行<br>第三组r–： 其他组的用户的权限是读不能写和执行</p><p>可用数字表示：r&#x3D;4，w&#x3D;2，x&#x3D;1，因此rwx&#x3D;4+2+1&#x3D;7，数字可以进行组合<br>其他说明<br>1 文件：该数一定为1 目录：该数对应子目录数<br>root 所有者<br>root 所在组<br>1213 大小（字节），如果是文件夹，显示4096字节<br>Feb 2 09:39 最后修改日期<br>abc 文件名</p><h3 id="修改权限-chmod"><a href="#修改权限-chmod" class="headerlink" title="修改权限-chmod"></a>修改权限-chmod</h3><h4 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h4><p>通过chmod指令，可以修改文件或目录的权限</p><h4 id="第一种方式：-、-、-变更权限"><a href="#第一种方式：-、-、-变更权限" class="headerlink" title="第一种方式：+、-、&#x3D;变更权限"></a>第一种方式：+、-、&#x3D;变更权限</h4><p>u:所有者 g：所有组 o：其他人 a：所有人（u、g、o的总和）<br>1.chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x 文件&#x2F;目录名<br>2.chmod o+w 文件&#x2F;目录名<br>3.chmod a-x 文件&#x2F;目录名<br>案例演示<br>1.给abc文件的所有者读写执行的权限，给所在组读执行权限，给其他组读执行权限：chmod u&#x3D;rwx, g&#x3D;rx,o&#x3D;rx abc<br>2.给abc文件的所有者除去执行的权限，增加组写的权限:chmod u-x g+w abc<br>3.给abc文件的所有用户添加读的权限:chmod a+r abc<br>注意：当文件可执行的时候，它的颜色会变成绿色</p><h4 id="第二种方式：通过数字变更权限"><a href="#第二种方式：通过数字变更权限" class="headerlink" title="第二种方式：通过数字变更权限"></a>第二种方式：通过数字变更权限</h4><p>r&#x3D;4 w&#x3D;2 x&#x3D;1 rwx&#x3D;4+2+1&#x3D;7<br>chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x 文件目录名 相当于chmod 751 文件目录名<br>案例演示<br>要求：将&#x2F;home&#x2F;abc.txt 文件的权限修改成rwxr-xr-x，使用给数字的方式实现：<br>chmod 755 &#x2F;home&#x2F;abc.txt</p><h3 id="修改文件所有者-chown"><a href="#修改文件所有者-chown" class="headerlink" title="修改文件所有者-chown"></a>修改文件所有者-chown</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>chown newowner 文件&#x2F;目录 (功能描述：改变所有者）<br>chown newowner:newgroup 文件&#x2F;目录 （功能描述：改变所有者和所在组）<br>-R 如果是目录，则使其下所有子文件或目录递归生效</p><p>案例演示<br>请将&#x2F;home&#x2F;abc.txt文件的所有者修改成tom：chown tom &#x2F;home&#x2F;abc.txt<br>请将&#x2F;home&#x2F;test目录下所有的文件和目录的所有者都修改成tom：chown -R tom &#x2F;home&#x2F;test</p><h3 id="修改文件-目录所在组-chgrp"><a href="#修改文件-目录所在组-chgrp" class="headerlink" title="修改文件&#x2F;目录所在组-chgrp"></a>修改文件&#x2F;目录所在组-chgrp</h3><p>基本介绍<br>chgrp newgroup 文件&#x2F;目录 改变所在组<br>案例演示<br>请将&#x2F;home&#x2F;abc.txt文件的所在组修改成shaolin(少林)：chgrp shaolin &#x2F;home&#x2F;abc.txt<br>请将&#x2F;home&#x2F;test目录下所有的文件和目录的所在组都修改成shaolin（少林）：chgrp -R shaolin &#x2F;home&#x2F;test</p><h2 id="Linux实操篇-定时任务调度"><a href="#Linux实操篇-定时任务调度" class="headerlink" title="Linux实操篇-定时任务调度"></a>Linux实操篇-定时任务调度</h2><h3 id="crond任务调度"><a href="#crond任务调度" class="headerlink" title="crond任务调度"></a>crond任务调度</h3><p>crontab 进行 定时任务的设置</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>任务调度：是指系统在某个时间执行的特定的命令或程序。<br>任务调度分类：1.系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等<br>个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份<br>示意图：<br><img src="/2024/09/25/linux/59be4203b3384ec5fa76f18dccbeb746.png"></p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>crontab 【选项】</p><h4 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h4><p><img src="/2024/09/25/linux/0929c6e5dc3e4a5c229c1c5e4237fe50.png"></p><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><p>设置任务调度文件：&#x2F;etc&#x2F;crontab<br>设置个人任务调度。执行crontab -e命令<br>接着输入任务到调度文件<br>如：*&#x2F;1 * * * * ls -l &#x2F;etc&#x2F; &gt; &#x2F;tmp&#x2F;to.txt（注意：*之间有空格）<br>意思说每小时的每分钟执行ls -l &#x2F;etc&#x2F; &gt; &#x2F;tmp&#x2F;to.txt命令</p><p>参数细节说明<br>5个占位符的说明<br><img src="/2024/09/25/linux/f618577280ad1f52f007158d8e0a88b9.png"><br>特殊符号的说明<br><img src="/2024/09/25/linux/496eaa8d9c9be06ecb2ebf80e80d868a.png"><br>特定时间执行任务案例<br><img src="/2024/09/25/linux/6d25b988a501df5f62a84609fa341b0f.png"></p><h4 id="应用实例-3"><a href="#应用实例-3" class="headerlink" title="应用实例"></a>应用实例</h4><p>案例1：每隔1分钟，就将当前的日期信息，追加到&#x2F;tmp&#x2F;mydate文件中：</p><ul><li><ul><li><ul><li><ul><li><ul><li>date &gt;&gt; &#x2F;tmp&#x2F;mydate<br>案例2：每隔1分钟，将当前日期和日历都追加到&#x2F;home&#x2F;mycal文件中:</li></ul></li></ul></li></ul></li></ul></li></ul><p>方案1：写两条指令到crontab中<br>方案2：写一个完成两条指令的脚本，然后让crond定时执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /home</span><br><span class="line">vim my.sh (内容为date &gt;&gt; /home/mycal  cal &gt;&gt; /home/mycal)</span><br><span class="line">chmod u+x my.sh # 赋予所有者root执行权限</span><br><span class="line">crontab -e （增加 * * * * * /home/my.sh)</span><br></pre></td></tr></table></figure><p>案例3：每天凌晨2：00将mysql数据库testdb，备份到文件中。提示：指令为mysqldump -u root -p密码 数据库 &gt;&gt; &#x2F;home&#x2F;db.bak</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e </span><br><span class="line">0 2 * * * mysqldump -u root -proot testdb &gt; /home/db.bak # 这里假设密码是root</span><br></pre></td></tr></table></figure><h4 id="crond相关指令"><a href="#crond相关指令" class="headerlink" title="crond相关指令"></a>crond相关指令</h4><p>crontab -r：终止任务调度（其实就是删除）<br>crontab -l：列出当前有哪些任务调度<br>service crond restart 【重启任务调度】</p><h3 id="at定时任务"><a href="#at定时任务" class="headerlink" title="at定时任务"></a>at定时任务</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.at命令是一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来运行。<br>2.默认情况下，atd守护进程每60秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业。<br>3.at命令是一次性定时计划任务，执行完一个任务后不再执行此任务了<br>4.在使用at命令的时候，一定要保证atd进程的启动，可以使用相关指令来查看<br>指令ps -ef（检测当前所有正在运行的进程有哪些）<br>指令ps -ef | grep atd （过滤其中的atd相关指令)&#x2F;&#x2F;可以检测atd是否在运行<br>5.示意图<br><img src="/2024/09/25/linux/4ff4548cdaa30574dd93c64aacd45282.png"></p><h3 id="at命令格式"><a href="#at命令格式" class="headerlink" title="at命令格式"></a>at命令格式</h3><p>at 【选项]】【时间】<br>Crtl + D 结束at命令的输入（按两次)</p><h3 id="at命令选项"><a href="#at命令选项" class="headerlink" title="at命令选项"></a>at命令选项</h3><p><img src="/2024/09/25/linux/d66ca82e17353c91139f7e413a1b3a97.png"></p><h3 id="at时间定义"><a href="#at时间定义" class="headerlink" title="at时间定义"></a>at时间定义</h3><p>at指定时间的方法:<br>1.接受在当天的hh:mm(小时：分钟）式的时间指定。假如该时间已过去，那么就放在第二天执行。例如：04：00<br>2.使用midnight（深夜），noon（中午），teatime（饮茶时间，一般是下午4点）等比较模糊的词语来指定时间。<br>3.采用12小时计时制，即在时间后面加上AM（上午）或PM（下午）来说明是上午还是下午。例如：12pm<br>4.指定命令执行的具体日期，指定格式为month day（月 日）或mm&#x2F;dd&#x2F;yy（月&#x2F;日&#x2F;年）或dd.mm.yy（日.月.年），指定的日期必须跟在指定时间的后面。例如：04：00 2021-03-1<br>5.使用相对计时法。指定格式为：now + count time-units，now就是当前时间，time-units是时间单位，这里能够使minutes（分钟）、hours（小时）、days（天）、weeks（星期）。count是时间的数量，几天，几小时。例如：now + 5 minutes<br>6.直接使用today（今天）、tomorrow（明天）来指定完成命令的时间。</p><h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><p>案例1：2天后的下午5点执行&#x2F;bin&#x2F;ls &#x2F;home</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">at 5pm + 2days</span><br><span class="line"><span class="meta prompt_">at&gt; </span><span class="language-bash">/bin/ls /home <span class="comment"># 然后按两次ctrl+D</span></span></span><br></pre></td></tr></table></figure><p>案例2：atq命令来查看系统中没有执行的工作任务：atq<br>案例3：明天17点钟，输出时间到指定文件内，比如&#x2F;root&#x2F;date100.log</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">at 5pm tomorrow</span><br><span class="line"><span class="meta prompt_">at&gt; </span><span class="language-bash"><span class="built_in">date</span> &gt; /root/date100.<span class="built_in">log</span> <span class="comment"># 然后按两次ctrl+D</span></span></span><br></pre></td></tr></table></figure><p>案例4：2分钟后，输出时间到指定文件内，比如&#x2F;root&#x2F;date200.log</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">at now + 2 minutes</span><br><span class="line"><span class="meta prompt_">at&gt; </span><span class="language-bash"><span class="built_in">date</span> &gt; /root/date200.<span class="built_in">log</span> <span class="comment"># 然后按两次ctrl+D</span></span></span><br></pre></td></tr></table></figure><p>案例5：删除已经设置的任务，atrm 编号（也可以使用at -d 任务编号：来删除设置的任务）</p><p>注意：当出现at&gt;，要输入指令时，退格会失效，要退格，需要使用ctrl+退格</p><h2 id="Linux实操篇-Linux磁盘分区、挂载"><a href="#Linux实操篇-Linux磁盘分区、挂载" class="headerlink" title="Linux实操篇-Linux磁盘分区、挂载"></a>Linux实操篇-Linux磁盘分区、挂载</h2><h3 id="Linux分区"><a href="#Linux分区" class="headerlink" title="Linux分区"></a>Linux分区</h3><h4 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h4><p>1.Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构，Linux中每个分区都是用来组成整个文件系统的一部分。<br>2.Linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。<br>3.示意图<br><img src="/2024/09/25/linux/5fa553133ae74b2f8bbd53840b2dd6e1.png"></p><h4 id="硬盘说明"><a href="#硬盘说明" class="headerlink" title="硬盘说明"></a>硬盘说明</h4><p>1.Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘<br>2.对于IDE硬盘，驱动器标识符为‘hdx<del>’，其中’hd‘表明分区所在设备的类型，这里是指IDE硬盘。’x‘为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘），’ ~’代表分区，前四个分区用数字1-4表示，它们是主分区或扩展分区，从5开始就是逻辑分区。例如，hda3表示为前一个IDE硬盘上的第三个主分区或扩展分区，hdb2表示为第二个IDE硬盘上的第二个主分区或扩展分区。<br>3.对于SCSI硬盘则标识为’sdx</del>‘，SCSI硬盘使用’sd‘来表示分区所在设备的类型的，其余则和IDE硬盘的表示方法一样。<br><img src="/2024/09/25/linux/783b9087a0b57d6d5a26f443190bc349.png"><br>上图中，sda表示第一块SCSI硬盘，sda1表示第一块SCSI硬盘的第一个分区<br>sr0是光驱，不用管他</p><h4 id="查看所有设备挂载情况"><a href="#查看所有设备挂载情况" class="headerlink" title="查看所有设备挂载情况"></a>查看所有设备挂载情况</h4><p>命令：lsblk或者lsblk -f （list block的简称）<br><img src="/2024/09/25/linux/783b9087a0b57d6d5a26f443190bc349.png"><br>lsblk -f可以将分区的情况看的更加清晰<br><img src="/2024/09/25/linux/5596d0272a01d85d8214497f51bdfc62.png"><br>FSTYPE是文件类型，UUID是当你格式化后，会给你的每一个分区分配一个唯一的不重复的40位的字符串（唯一标识符），MOUNTPOINT是挂载点</p><h3 id="挂载的经典案例"><a href="#挂载的经典案例" class="headerlink" title="挂载的经典案例"></a>挂载的经典案例</h3><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><p>下面我们以增加一块硬盘为例来熟悉下磁盘的相关指令和深入理解磁盘分区、挂载、卸载的概念。</p><h4 id="如何增加一块硬盘"><a href="#如何增加一块硬盘" class="headerlink" title="如何增加一块硬盘"></a>如何增加一块硬盘</h4><p>1.虚拟机增加硬盘<br>2.分区<br>3.格式化<br>4.挂载<br>5.设置可以自动挂载</p><p><strong>虚拟机增加硬盘步骤1</strong><br>在【虚拟机】菜单中，选择【设置】，然后设备列表里添加硬盘，然后一路【下一步】，中间只有选择磁盘大小的地方需要修改，直到完成。然后重启系统（才能识别）！</p><p><strong>虚拟机增加硬盘步骤2</strong><br>分区命令 fdisk &#x2F;dev&#x2F;sdb<br>开始对&#x2F;sdb分区<br>m 显示命令列表<br>p 显示磁盘分区 同 fdisk -l<br>n 新增分区<br>d 删除分区<br>w 写入并退出<br>说明：开始分区后输入n，新增分区，然后选择p，分区类型为主分区。两次回车默认剩余全部空间。最后输入w写入分区并退出，若不保存退出输入q。</p><p><strong>虚拟机增加硬盘步骤3</strong><br>格式化磁盘<br>分区命令：mkfs 【选项】【t 分区格式】 分区路径，例如mkfs -t ext4 &#x2F;dev&#x2F;sdb1 （mkfs是make filesystem的简写）（也可以写成mkfs.ext4 &#x2F;dev&#x2F;sdb1)<br>其中ext4是分区类型</p><p><strong>虚拟机增加磁盘步骤4</strong><br>挂载：将一个分区与一个目录关联起来<br>mount 设备名称 挂载目录<br>例如：mount &#x2F;dev&#x2F;sdb1 &#x2F;newdisk（必须先创建&#x2F;newdisk目录）<br>卸载：<br>umount 设备名称 或者 挂载目录<br>例如：umount &#x2F;dev&#x2F;sdb1 或者 umount &#x2F;newdisk<br>注意：用命令行挂载重启后会失效（即这样操作的挂载关系是临时的）</p><p><strong>虚拟机增加硬盘步骤5</strong><br>永久挂载：通过修改&#x2F;etc&#x2F;fstab实现自动挂载（fstab是filesystem table的缩写）<br><img src="/2024/09/25/linux/968e9d5387a7f6ac5663591066f1d0f5.png"><br>补充：最后的两个数字：第一个是挂载点内备份，0表示不做dump备份，第二个表示磁盘检查，0表示不检查磁盘扇区，1表示其他目录文件检查，2表示根目录文件检查<br>添加完成后 执行mount -a即刻生效（或者执行reboot也会自动生效）<br>注意：永久挂载前最好保存快照。防止操作失误导致开不了机</p><h3 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h3><h4 id="查询系统整体磁盘使用情况"><a href="#查询系统整体磁盘使用情况" class="headerlink" title="查询系统整体磁盘使用情况"></a>查询系统整体磁盘使用情况</h4><p>基本语法<br>df -h<br>应用实例<br>查询系统整体磁盘使用情况<br><img src="/2024/09/25/linux/b8f52dad2c4d06511311c7230dfc1a5f.png"><br>注意：如果磁盘使用率达到80%以上，就需要想办法清理空间了。</p><h4 id="查看指定目录的磁盘占用情况"><a href="#查看指定目录的磁盘占用情况" class="headerlink" title="查看指定目录的磁盘占用情况"></a>查看指定目录的磁盘占用情况</h4><p>基本语法<br>du -h &#x2F;目录<br>查询指定目录的磁盘占用情况，不指定则默认查询当前目录<br>-s 指定目录占用大小汇总<br>-h 带计量单位（人类可读）<br>-a 含文件<br>–max-depth&#x3D;1 子目录深度（当前目录的1层子目录也显示）<br>-c 列出明细的同时，增加汇总值</p><p>应用案例<br>查询&#x2F;opt目录的磁盘占用情况，深度为1<br><img src="/2024/09/25/linux/9a81808836136a3f9ac33227309f3c94.png"></p><h3 id="磁盘情况-工作使用指令"><a href="#磁盘情况-工作使用指令" class="headerlink" title="磁盘情况-工作使用指令"></a>磁盘情况-工作使用指令</h3><p>1.统计&#x2F;opt文件夹下文件（以-开头）的个数<br>第一步：列出&#x2F;opt目录下的内容：ls -l &#x2F;opt<br>第二步：通过正则表达式‘^-’过滤（因为-开头的是文件类型）：ls -l &#x2F;opt | grep ‘^-’<br>第三步：利用wc指令和-l选项统计行数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /opt | grep &#x27;^-&#x27; | wc -l</span><br></pre></td></tr></table></figure><p>补充：<br>wc指令(wc就是wordcount的简写)选项：<br>-l：计算行数（line）<br>-c：计算字节数（character）<br>-m：计算字符数（char）<br>-w：计算单词数（word）</p><p>2.统计&#x2F;opt文件夹下目录的个数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /opt | grep &#x27;^d&#x27; | wc -l</span><br></pre></td></tr></table></figure><p>3.统计&#x2F;opt文件夹下文件的个数，包括子文件夹里的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lR /opt | grep &#x27;^-&#x27; | wc -l # 递归查看目录</span><br></pre></td></tr></table></figure><p>4.统计&#x2F;opt文件夹下目录的个数，包括子文件夹里的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lR /opt | grep &#x27;^d&#x27; | wc -l # 递归查看目录</span><br></pre></td></tr></table></figure><p>5.以树状显示目录结构：tree 目录<br>注意：如果没有tree指令，则使用yum install tree，前提网络是畅通的<br><img src="/2024/09/25/linux/4ca276f1c1dff9527b0642678e3fdabc.png"></p><h2 id="Linux实操篇-网络配置"><a href="#Linux实操篇-网络配置" class="headerlink" title="Linux实操篇-网络配置"></a>Linux实操篇-网络配置</h2><h3 id="Linux网络配置原理图"><a href="#Linux网络配置原理图" class="headerlink" title="Linux网络配置原理图"></a>Linux网络配置原理图</h3><h4 id="画出原理图，帮助理解"><a href="#画出原理图，帮助理解" class="headerlink" title="画出原理图，帮助理解"></a>画出原理图，帮助理解</h4><p><img src="/2024/09/25/linux/7d9b208c4c220a9870e6c0ca19f8972a.png"></p><h3 id="查看网络IP和网关"><a href="#查看网络IP和网关" class="headerlink" title="查看网络IP和网关"></a>查看网络IP和网关</h3><h4 id="查看虚拟机网络编辑器和修改IP地址"><a href="#查看虚拟机网络编辑器和修改IP地址" class="headerlink" title="查看虚拟机网络编辑器和修改IP地址"></a>查看虚拟机网络编辑器和修改IP地址</h4><p><img src="/2024/09/25/linux/ebb48e1e88d8fba31be1270e91ea5e4b.png"></p><h4 id="查看网关"><a href="#查看网关" class="headerlink" title="查看网关"></a>查看网关</h4><p><img src="/2024/09/25/linux/41ab797380d58283c962465db74796d5.png"><br><img src="/2024/09/25/linux/840a5c69e23e8995d7e75154b2322298.png"></p><h3 id="查看windows环境中的VMnet8网络配置：ipconfig指令"><a href="#查看windows环境中的VMnet8网络配置：ipconfig指令" class="headerlink" title="查看windows环境中的VMnet8网络配置：ipconfig指令"></a>查看windows环境中的VMnet8网络配置：ipconfig指令</h3><p>也可以在网络和internet&gt;高级网络设置&gt;查看其他属性里查看<br><img src="/2024/09/25/linux/b424c937583977e2fed3368867f29494.png"></p><h3 id="查看linux的网络配置：ifconfig指令"><a href="#查看linux的网络配置：ifconfig指令" class="headerlink" title="查看linux的网络配置：ifconfig指令"></a>查看linux的网络配置：ifconfig指令</h3><p><img src="/2024/09/25/linux/4909cd174fa637f07c11d6def3ded0bf.png"></p><h3 id="ping测试主机之间网络连通性"><a href="#ping测试主机之间网络连通性" class="headerlink" title="ping测试主机之间网络连通性"></a>ping测试主机之间网络连通性</h3><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><p>ping 目的主机 （功能描述：测试当前服务器是否可以连接目的主机）</p><h4 id="应用实例-4"><a href="#应用实例-4" class="headerlink" title="应用实例"></a>应用实例</h4><p>测试当前服务器是否可以连接百度<br>ping <a href="http://www.baidu.com/">www.baidu.com</a></p><h3 id="linux网络环境配置"><a href="#linux网络环境配置" class="headerlink" title="linux网络环境配置"></a>linux网络环境配置</h3><h4 id="第一种方法（自动获取）："><a href="#第一种方法（自动获取）：" class="headerlink" title="第一种方法（自动获取）："></a>第一种方法（自动获取）：</h4><p>说明：登录后，通过界面来设置自动获取ip。<br>优点：linux启动后会自动获取IP，避免冲突<br>缺点：每次自动获取的ip地址可能不一样<br><img src="/2024/09/25/linux/a43dd7bcedd02a582ca3b1b701dbc2a9.png"><br><img src="/2024/09/25/linux/6d15599350e9ad85d4cbfccd88672dfc.png"></p><h4 id="第二种方法（指定ip）："><a href="#第二种方法（指定ip）：" class="headerlink" title="第二种方法（指定ip）："></a>第二种方法（指定ip）：</h4><p>说明<br>直接修改配置文件来指定ip，并可以连接到外网（程序员推荐）<br>编辑： vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33（ens33就是网络设备，更准确地说是网卡）<br>要求：将ip地址配置成静态的：比如：ip地址为192.168.200.130<br><img src="/2024/09/25/linux/1386f7d6bad76288e8ead5b15e137d90.png"><br>ifcfg-ens33 文件说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TYPE=‘Ethernet’                     # 网络类型（通常是Ethenet）</span><br><span class="line">BOOTPROTO=‘dhcp’    # IP的配置方法[none|static|bootp|dhcp]（分别表示引导时不使用协议|静态分配IP|BOOTP协议|DHCP协议）</span><br><span class="line">UUID=926a57ba。。。。。              # 随机id</span><br><span class="line">DEVICE=‘eth0’# 接口名（设备，网卡）</span><br><span class="line">HWADDR=‘00:0C:2x:0x:xx’           # MAC地址（这里没有)</span><br><span class="line">ONBOOT=‘yes’# 系统启动时，网络接口是否有效（yes/no）</span><br></pre></td></tr></table></figure><p>要将ip地址配置成静态的，需要修改ifcfg-ens33文件，具体地需要添加or修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOTPROTO=‘static’   # 表示静态分配IP</span><br><span class="line">IPADDR=192.168.200.130    # 表示要固定的IP地址</span><br><span class="line">GATEWAY=192.168.200.2    # 表示网关</span><br><span class="line">DNS1=192.168.200.2   # 表示域名解析器</span><br></pre></td></tr></table></figure><p>修改后保存，接下来还需要打开虚拟机的虚拟网络编辑器，找到VMnet8，修改其子网IP为192.168.200.0<br><img src="/2024/09/25/linux/4acd487cbc872f38cae74661e3c32b7a.png"><br>接下来打开NAT设置，修改网关IP为192.168.200.2<br><img src="/2024/09/25/linux/d042985c283686fc0b3dae2d77796e46.png"><br>点应用和确定</p><p>重启网络服务或者重启系统生效<br>service network restart # 重启网络服务<br>reboot # 重启系统<br>注意：因为修改了虚拟机的ip，所有要在xshell中登录虚拟机，需要修改对应连接的属性中的ip</p><h3 id="设置主机名和hosts映射"><a href="#设置主机名和hosts映射" class="headerlink" title="设置主机名和hosts映射"></a>设置主机名和hosts映射</h3><h4 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h4><p>1.为了方便记忆，可以给linux系统设置主机名，也可以根据需要修改主机名<br>2.指令hostname：查看主机名<br>3.修改文件在&#x2F;etc&#x2F;hostname指定<br>4.修改后，重启生效</p><h4 id="设置hosts映射"><a href="#设置hosts映射" class="headerlink" title="设置hosts映射"></a>设置hosts映射</h4><p>思考：如何通过主机名能够找到（比如ping）某个linux系统?</p><p>windows<br>在C:\Windows\System32\drivers\etc\hosts文件指定ip地址和主机名的关系即可<br>案例：192.168.200.130 hspedu100<br>linux<br>在&#x2F;etc&#x2F;hosts 文件指定<br>案例：192.168.200.1 ThinkPad-PC（这个名字其实可以随意，但是ping的时候必须也是这个名称）</p><h3 id="主机名解析过程分析（Hosts、DNS）"><a href="#主机名解析过程分析（Hosts、DNS）" class="headerlink" title="主机名解析过程分析（Hosts、DNS）"></a>主机名解析过程分析（Hosts、DNS）</h3><h4 id="Hosts是什么"><a href="#Hosts是什么" class="headerlink" title="Hosts是什么"></a>Hosts是什么</h4><p>一个文本文件，用来记录IP和Hostname（主机名）的映射关系</p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>1.DNS，就是Domain Name System的缩写，翻译过来就是域名系统<br>2.是互联网上作为域名和IP地址相互映射的一个分布式数据库</p><h4 id="应用实例：用户在浏览器输入了www-baidu-com"><a href="#应用实例：用户在浏览器输入了www-baidu-com" class="headerlink" title="应用实例：用户在浏览器输入了www.baidu.com"></a>应用实例：用户在浏览器输入了<a href="http://www.baidu.com/">www.baidu.com</a></h4><p>1.浏览器先检查浏览器缓存中有没有该域名和IP地址的对应关系，有就先调用这个IP完成解析；如果没有找到，就检查操作系统DNS解析器缓存，如果有直接返回IP完成解析。这两个缓存，可以理解为本地解析器缓存。<br>2.一般来说，当电脑第一次成功访问某一网站后，在一定时间内，浏览器或操作系统会缓存他的IP地址（DNS解析记录)。如在cmd窗口中输入<br>ipconfig &#x2F;displaydns &#x2F;&#x2F; 可以看到当前操作系统里面的DNS域名解析缓存<br>ipconfig &#x2F;flushdns &#x2F;&#x2F; 手动清理dns缓存<br>3.如果本地解析器缓存没有找到对应映射，检查系统中的hosts文件中有没有配置对应的域名IP映射，如果有，则完成解析并返回。<br>4.如果本地DNS解析器缓存和hosts文件中均没有找到对应的IP，则到域名服务DNS（公网的DNS，即分布式数据库）进行解析域<br>5.如果还没找到，返回域名不存在的信息<br>注意：<br>1.如果是ping 一个域名，则没有浏览器缓存<br>2.公网的DNS服务器不是一个服务器，而是分级的（这是为了优化而做的）<br>示意图<br><img src="/2024/09/25/linux/9603cf7f702ef30b33abd7f91ba8eca2.png"><br>补充：<br>dns域名劫持：黑客攻击，修改hosts文件，会让域名定向到假网站，（不过现在很多浏览器都有防域名劫持的机制）。</p><h2 id="第14章：Linux实操篇-进程管理（重点）"><a href="#第14章：Linux实操篇-进程管理（重点）" class="headerlink" title="第14章：Linux实操篇-进程管理（重点）"></a>第14章：Linux实操篇-进程管理（重点）</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>1.在Linux中，每个执行的程序都成为一个进程。每一个进程都分配一个ID号(pid，也叫进程号）。<br>下图是windows下通过任务管理器查看进程。</p><p>补充：程序（静态概念）不运行的时候，就是一段代码。当它加载到内存里时，它才是一个进程（动态概念）。<br>2.每个进程都可能以两种方式存在。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行，比如mysql服务。<br>3.一般系统的服务都是以后台进程的方式存在，如mysql，tomcat，而且都会常驻在系统中。直到关机才结束。</p><h3 id="显示系统执行的进程"><a href="#显示系统执行的进程" class="headerlink" title="显示系统执行的进程"></a>显示系统执行的进程</h3><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>ps命令是用来查看目前系统中，有哪些正在执行，以及它们执行的状况。可以不加任何参数。</p><p>一般将-a，-u和-x三个参数同时组合使用。<br><img src="/2024/09/25/linux/624d7985cf91805d0230e025f676be8e.png"><br>USER是指”进程执行用户“<br>PID是指”进程号“<br>%CPU是指”占用CPU的百分比“<br>%MEM是指”占用物理内存百分比“<br>VSZ是指”占用虚拟内存大小“<br>RSS是指”驻留集合大小，即进程所使用的非交换区物理内存大小“<br>TTY是指”终端信息“<br>STAT是指”当前运行状态“，S表示sleep（休眠）、r表示正在运行<br>START是指”执行的开始时间“<br>TIME是指”占用CPU时间“<br>COMMAND是指”进程名，也可以理解为执行该进程的指令“</p><h4 id="ps详解"><a href="#ps详解" class="headerlink" title="ps详解"></a>ps详解</h4><p>1.指令：ps -aux | grep xxx，比如想看看有没有sshd服务<br>2.指令说明</p><p>System V 展示风格<br>USER：用户名称<br>PID：进程号<br>%CPU：进程占用CPU百分比<br>%MEM：进程占用物理内存的百分比<br>VSZ：进程占用的虚拟内存大小（单位 ：KB）<br>RSS：进程占用的物理内存大小（单位：KB）<br>TTY：终端名称，缩写<br>STAT：进程状态，其中S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等<br>STARTED：进程的启动时间<br>TIME：CPU时间，即进程使用CPU的总时间<br>COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</p><h4 id="应用实例-5"><a href="#应用实例-5" class="headerlink" title="应用实例"></a>应用实例</h4><p>要求：以全格式显示当前所有的进程，查看进程的父进程。比如查看sshd的父进程信息：ps -ef | grep sshd<br><img src="/2024/09/25/linux/cc5cf419a39f08a7fda997a400d31179.png"><br>可以看出，sshd的父进程的PID为1，通过指令ps -aux | more可以看到PID为1的进程为<br><img src="/2024/09/25/linux/407644fd822f7bddb77b96484629c2e9.png"><br>补充：<br>1.一个进程可以创建生成多个子进程，所以会有所谓的多进程的概念。<br>2.看上上图可以发现，root身份通过xshell登录的2033进程是1318进程的子进程。</p><p>ps -ef是以全格式显示当前所有的进程<br>-e显示所有进程。-f 全格式<br>ps -ef | grep xxx<br>是BSD风格<br>UID：用户ID<br>PID：进程ID<br>PPID：父进程ID<br>C：CPU用于计算执行优先级的因子。数值越大， 表明进程是CPU密集型运算，执行优先级会降低；数值越小，表明进程是I&#x2F;O密集型运算，执行优先级会提高<br>STIME：进程启动的时间<br>TTY：完整的终端名称<br>TIME：CPU时间<br>CMD：启动进程所用的命令和参数</p><h3 id="终止进程kill和killall"><a href="#终止进程kill和killall" class="headerlink" title="终止进程kill和killall"></a>终止进程kill和killall</h3><h4 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h4><p>若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用kill命令来完成此项任务。</p><h4 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h4><p>kill [选项] 进程号（功能描述：通过进程号终止进程）<br>killall 进程名称 （功能描述：通过进程名称终止进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）<br>补充：<br>1.通过kill只会终止父进程，其子进程会交给1号进程接管。<br>2.通过killall终止进程，会将该进程下面的所有子进程也一并终止。</p><h4 id="常用选项-1"><a href="#常用选项-1" class="headerlink" title="常用选项"></a>常用选项</h4><p>-9：表示强迫进程立即停止（因为在有些情况下，系统处于保护机制，它会忽略kill指令，但是带-9会强制终止进程）</p><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>案例1：踢掉某个非法登录用户：kill 对应进程号，比如kill 11421<br>案例2：终止远程登录服务sshd，在适当时候再次启动sshd服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill sshd对应的进程号</span><br><span class="line">/bin/systemctl start sshd.service # 再次重启sshd服务</span><br></pre></td></tr></table></figure><p><img src="/2024/09/25/linux/f5366a0a6c17addf06cf339a6ac8bfbb.png"><br>案例3：终止多个gedit，演示killall：killall gedit<br>案例4：强制杀掉一个终端<br><img src="/2024/09/25/linux/efcfab00549b4d752e2d189728aa3670.png"><br>kill 5480，没有反应。因为该终端正在工作，认为你可能是误操作。此时要终止必须要强制终止：kill -9 5480</p><h3 id="查看进程树pstree"><a href="#查看进程树pstree" class="headerlink" title="查看进程树pstree"></a>查看进程树pstree</h3><h4 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a>基本语法</h4><p>pstree [选项] [进程号]，可以更加直观的来看进程信息，不写进程号，默认查看进程为1的进程树</p><h4 id="常用选项-2"><a href="#常用选项-2" class="headerlink" title="常用选项"></a>常用选项</h4><p>-p：显示进程的PID<br>-u：显示进程的所属用户</p><h4 id="应用实例："><a href="#应用实例：" class="headerlink" title="应用实例："></a>应用实例：</h4><p>案例1：请以树状的形式显示进程pid：pstree -p （进程号）<br>案例2：请以树状的形式显示进程的用户：pstree -u</p><h3 id="服务（service）管理"><a href="#服务（service）管理" class="headerlink" title="服务（service）管理"></a>服务（service）管理</h3><h4 id="介绍：-1"><a href="#介绍：-1" class="headerlink" title="介绍："></a>介绍：</h4><p>服务（service）本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其他程序的请求，比如（mysqld，sshd，防火墙等），因此我们又称为守护进程，是Linux中非常重要的知识点。下图为原理图。<br>    <img src="/2024/09/25/linux/49f2ac10f2a0077ad20207cf25787ff8.png"><br>补充：<br>1.SSHD，就是远程登陆服务，是通过SSH来登陆的。最后的一个符号D其实是daemon的简写，表示后台程序&#x2F;守护进程&#x2F;服务</p><h4 id="service管理指令"><a href="#service管理指令" class="headerlink" title="service管理指令"></a>service管理指令</h4><p>1.service 服务名 [start | stop | restart | reload | status]<br>2.在CentOS7.0后，很多服务不再使用service，而是systemctl（后面专门讲）<br>3.在CentOS7.0后，被service指令管理的服务在&#x2F;etc&#x2F;init.d&#x2F;查看（注意，必须最后带&#x2F;）<br><img src="/2024/09/25/linux/f58f51652b9c9d39c990a675f5586c7d.png"></p><h4 id="service管理指令案例"><a href="#service管理指令案例" class="headerlink" title="service管理指令案例"></a>service管理指令案例</h4><p>请使用service指令，查看，关闭，启动network(注意：在虚拟系统演示，因为网络连接会关闭，进程不再监听端口，xshell就无法连接上sshd)</p><h4 id="查看服务名："><a href="#查看服务名：" class="headerlink" title="查看服务名："></a>查看服务名：</h4><p>方式1：使用setup -&gt; 系统服务 就可以看到全部：setup<br>下图中打星号的表示会随着linux的启动，自动启动。没有带星号的则需要手动启动。<br>将光标移动到某一个服务上，按空格，可以将自动启动的服务改为需要手动启动，即可以去掉星号。<br>按tab可以切换选择框。<br><img src="/2024/09/25/linux/0450a924588d6accd1bd9d4e6e5a7061.png"><br>方式2：&#x2F;etc&#x2F;init.d 看到service指令管理的服务：ls -l &#x2F;etc&#x2F;init.d</p><h4 id="服务的运行级别（runlevel）："><a href="#服务的运行级别（runlevel）：" class="headerlink" title="服务的运行级别（runlevel）："></a>服务的运行级别（runlevel）：</h4><p>Linux系统中有7种运行级别（runlevel）：常用的是级别3和5<br>运行级别0：系统停机状态（一旦启动马上关机），系统默认运行级别不能设为0，否则不能正常启动<br>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登录<br>运行级别2：多用户状态（没有NFS），不支持网络<br>运行级别3：完全的多用户状态（有NFS），无界面，登录后进入控制台命令行模式<br>运行级别4：系统未使用，保留<br>运行级别5：X11控制台，登录后进入图形GUI模式<br>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动<br>开机的流程说明：</p><p>开机-&gt;BIOS-&gt;&#x2F;boot-&gt;systemd进程1-&gt;运行级别-&gt;运行级对应的服务</p><h4 id="CentOS7后运行级别说明"><a href="#CentOS7后运行级别说明" class="headerlink" title="CentOS7后运行级别说明"></a>CentOS7后运行级别说明</h4><p>在&#x2F;etc&#x2F;inittab中进行了简化，如下：<br>multi-user.target: analogous to runlevel 3<br>graphical.target: analogous to runlevel 5</p><h5 id="To-view-current-default-target-run"><a href="#To-view-current-default-target-run" class="headerlink" title="To view current default target, run:"></a>To view current default target, run:</h5><p>systemctl get-default</p><h5 id="To-set-a-default-target-run"><a href="#To-set-a-default-target-run" class="headerlink" title="To set a default target, run:"></a>To set a default target, run:</h5><p>systemctl set-default TARGET.target</p><h4 id="chkconfig指令"><a href="#chkconfig指令" class="headerlink" title="chkconfig指令"></a>chkconfig指令</h4><p>介绍<br>1.通过chkconfig命令可以给服务的各个运行级别设置自启动&#x2F;关闭<br>2.chkconfig指令管理的服务在&#x2F;etc&#x2F;init.d查看<br>3.注意：Centos7.0后，很多服务使用systemctl管理（后面马上讲）<br>chkconfig基本语法</p><p>查看服务chkconfig –list [|grep xxx] (–list可加可不加）<br><img src="/2024/09/25/linux/00b1e3a38e38af810ee8a06703bcaaf1.png"><br>注意：sysv和systemd都是管理进程启动或关闭的程序，sysv启动服务慢，systemd启动服务快<br>chkconfig 服务名 –list<br><img src="/2024/09/25/linux/b40f64cf7a50a5c8c1ca9d5baa5377f7.png"><br>chkconfig –level 5 服务名 on&#x2F;off：用这条指令可以设置某一个服务在某一个运行级别是自启动或者关闭自启动<br>案例演示：对network 服务 进行各种操作，把network在3这个级别关闭自启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --level 3 network off</span><br><span class="line">chkconfig --level 3 network on</span><br></pre></td></tr></table></figure><p>使用细节<br>chkconfig重新设置服务后自启动或关闭，需要重启机器reboot生效。</p><h4 id="systemctl管理指令"><a href="#systemctl管理指令" class="headerlink" title="systemctl管理指令"></a>systemctl管理指令</h4><p>1.基本语法：systemctl [start | stop | restart | status] 服务名<br>2.systemctl指令管理的服务在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system查看<br><img src="/2024/09/25/linux/b6d1d5ad4d27472f57a325cb4d81712f.png"></p><h4 id="systemctl设置服务的自启动状态"><a href="#systemctl设置服务的自启动状态" class="headerlink" title="systemctl设置服务的自启动状态"></a>systemctl设置服务的自启动状态</h4><p>1.systemctl list-unit-files [| grep 服务名] （查看服务开机启动状态，grep可以进行过滤）<br>2.systemctl enable 服务名（设置服务开机启动）<br>3.systemctl disable 服务名（关闭服务开机启动）<br>4.systemctl is-enabled 服务名（查询某个服务是否是自启动的）</p><h4 id="应用案例："><a href="#应用案例：" class="headerlink" title="应用案例："></a>应用案例：</h4><p>查看当前防火墙的状况，关闭防火墙和重启防火墙。&#x3D;&gt; firewalld.service<br>查看防火墙服务开机启动状态：systemctl list-unit-files | grep firewalld（.service可带可不带）</p><p>查看防火墙的状态：systemctl status firewalld<br><img src="/2024/09/25/linux/c9a1cb08d88423941f6ddbc4853b32b8.png"><br>关闭防火墙：systemctl stop firewalld<br>重启防火墙：systemctl start firewalld<br><img src="/2024/09/25/linux/4891edaee8c4d73c267f6a635d92472e.png"><br>注意：<br>1.防火墙的服务名可以通过过滤查看&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system文件来获得<br><img src="/2024/09/25/linux/bc1b499a282047461f10b31bceee710f.png"><br>2.static状态表示该服务与其他服务相关联，不能单独设置该服务的启动状态<br>3.与前面的chkconfig –level x 服务名 on&#x2F;off不同的是，systemctl enable&#x2F;disable 服务名的指令不需要带level，这是因为centos7.0以后，通过systemctl开启和关闭服务，默认是对级别3和5做操作，都生效。</p><h4 id="细节讨论："><a href="#细节讨论：" class="headerlink" title="细节讨论："></a>细节讨论：</h4><p>1.关闭或者启用防火墙后，立即生效。[telnet测试 某个端口即可]<br>可以通过netstat -anp | more指令查看网络状态<br>测试：telnet 192.168.200.130 111<br><img src="/2024/09/25/linux/8d6ba3964c30db0f5a7e1e5b0f8585cd.png"><br>无法连接，说明防火墙是启动的，并且没有把111端口打开。<br>当关闭防火墙后，再测试连接端口，则可以通过。</p><p>补充：<br>（1）：防火墙基本原理：可以认为系统在监听端口前面加了一个防火墙，当一个请求来的时候，如果相应端口是放开的，则请求可以通过，否则不通过。防火墙可以理解为筛子，通过预先设置的大小，来过滤掉不符合尺寸的服务。<br><img src="/2024/09/25/linux/fdcaea12db87ce4a0015462491d1c76c.png"><br>（2）：开启telnet命令需要：依次点击‘开始’-&gt;“控制面板”-&gt;“程序”-&gt;“在程序和功能”找到并点击“启用或关闭windows功能”进入windows系统功能设置对话框。找到并勾选“Telnet客户端”和“Telnet服务器”<br><img src="/2024/09/25/linux/74d92e50401436b303964da1d06200e2.png"><br>2.这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置。<br>3.如果希望设置某个服务自启动或关闭永久生效，要使用systemctl [enable|disable] 服务名。</p><h4 id="打开或者关闭指定端口"><a href="#打开或者关闭指定端口" class="headerlink" title="打开或者关闭指定端口"></a>打开或者关闭指定端口</h4><p>在真正的生产环境，往往需要将防火墙打开，但问题来了，如果我们把防火墙打开，那么外部请求数据包就不能跟服务器监听端口通讯。这时，需要打开指定的端口。比如80、22、8080等，这个又怎么做呢？[示意图]</p><h4 id="firewall指令"><a href="#firewall指令" class="headerlink" title="firewall指令"></a>firewall指令</h4><p>打开端口：firewall-cmd –permanent –add-port&#x3D;端口号&#x2F;协议<br>关闭端口：firewall-cmd –permanent –remove-port&#x3D;端口号&#x2F;协议<br>重新载入，才能生效：firewall-cmd –reload<br>查询端口是否开放：firewall-cmd –query-port&#x3D;端口&#x2F;协议</p><p>补充：要知道对应端口的协议是什么，可以使用netstat -anp指令查看</p><h4 id="应用案例：-1"><a href="#应用案例：-1" class="headerlink" title="应用案例："></a>应用案例：</h4><p>1.启用防火墙，测试111端口是否能telnet，答案是不行：通过firewall-cmd –query-port&#x3D;111&#x2F;tcp可以发现111端口是未开放的</p><p>2.开放111端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=111/tcp</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">firewall-cmd --query-port=111/tcp</span><br></pre></td></tr></table></figure><p>3.再次关闭111端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --remove-port=111/tcp</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">firewall-cmd --query-port=111/tcp</span><br></pre></td></tr></table></figure><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>解压 tar -zxvf xx.tar.gz</p><ul><li><code>-x</code>: 解压缩</li><li><code>-v</code>: 显示详细过程</li><li><code>-f</code>: 指定文件名</li><li><code>-z</code>: 支持 gzip 格式</li><li><code>-j</code>: 支持 bzip2 格式</li></ul><p>在命令行中删除文件的常用命令取决于你使用的操作系统。以下是一些主要操作系统中的删除文件命令：</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>使用 <code>rm</code> 命令：</p><ul><li><p>删除单个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> filename.txt</span><br></pre></td></tr></table></figure></li><li><p>删除多个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> file1.txt file2.txt file3.txt</span><br></pre></td></tr></table></figure></li><li><p>强制删除文件（不提示确认）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f filename.txt</span><br></pre></td></tr></table></figure></li><li><p>删除目录及其内容（递归）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -r <span class="built_in">dirname</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>注意事项</strong></p><ul><li><p>使用删除命令时要谨慎，删除的文件通常无法恢复。</p></li><li><p>可以使用 <code>-i</code> 选项在 Linux 中启用交互模式，以便在删除每个文件之前进行确认：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -i filename.txt</span><br></pre></td></tr></table></figure></li></ul><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>显示当前用户所在的目录</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 韩顺平 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何基于crtl c+v快速排版QFluentWidgets中已有模块</title>
      <link href="/2024/05/29/How-to-quickly-typeset-existing-modules-in-QFluentWidgets-based-on-crtl_c+v/"/>
      <url>/2024/05/29/How-to-quickly-typeset-existing-modules-in-QFluentWidgets-based-on-crtl_c+v/</url>
      
        <content type="html"><![CDATA[<h1 id="如何基于crtl-c-v快速排版QFluentWidgets中已有模块？"><a href="#如何基于crtl-c-v快速排版QFluentWidgets中已有模块？" class="headerlink" title="如何基于crtl c+v快速排版QFluentWidgets中已有模块？"></a>如何基于crtl c+v快速排版QFluentWidgets中已有模块？</h1><h3 id="1、什么是QFluentWidgets"><a href="#1、什么是QFluentWidgets" class="headerlink" title="1、什么是QFluentWidgets"></a>1、什么是QFluentWidgets</h3><p>​         在QFluentWidgets的官网上有这样的介绍——<a href="https://github.com/zhiyiYo/PyQt-Fluent-Widgets"><strong>QFluentWidgets</strong>open in new window</a> 是一个基于 C++ Qt&#x2F;PyQt&#x2F;PySide 的 Fluent Design 风格组件库，包含数以百计的流畅设计组件，为简化开发、提高效率而生，其github提供的示例首页如下图所示。</p><p><img src="/2024/05/29/How-to-quickly-typeset-existing-modules-in-QFluentWidgets-based-on-crtl_c+v/1.png"></p><h3 id="2、基于QFluentWidgets提供的组件源代码快速构建页面"><a href="#2、基于QFluentWidgets提供的组件源代码快速构建页面" class="headerlink" title="2、基于QFluentWidgets提供的组件源代码快速构建页面"></a>2、基于QFluentWidgets提供的组件源代码快速构建页面</h3><p><strong>2.1 简要介绍</strong></p><p>首先要说明一点：使用QFluentWidgets依据官网<a href="https://qfluentwidgets.com/zh/pages/about">简介 | QFluentWidgets</a>有多种方式。</p><ul><li><p>第一种是使用购买Fluent Client；</p></li><li><p>第二种是在Qt Desinger中使用“提升为”的方式调用qfluentwidgets中的组件，然后用<code>pyuic6 -x &lt;inputname&gt;.ui -o &lt;output&gt;_ui.py</code>将ui转py。以<code>Editline</code>为例，结尾会出现<code>from qfluentwidgets import LineEdit</code>；</p></li><li><p>第三中方式就是<strong>直接通过QFluentWidgets提供的组件源代码</strong>进行排版</p></li></ul><p><strong>举个例子：</strong>接下来我直接将以下两个模块水平排版。</p><p><img src="/2024/05/29/How-to-quickly-typeset-existing-modules-in-QFluentWidgets-based-on-crtl_c+v/2.png"></p><p><img src="/2024/05/29/How-to-quickly-typeset-existing-modules-in-QFluentWidgets-based-on-crtl_c+v/3.png"></p><p>进行排版主要要掌握以下几个函数：</p><p><strong>2.2 创建布局</strong></p><p>在这个例子中，我需要创建一个水平布局<code>QHBoxLayout</code>，这个布局在最外侧（以自适应窗口大小），布局中的左侧放搜索栏，右侧放表格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 整体布局</span></span><br><span class="line">        self.layOutForAll = QHBoxLayout(self)</span><br><span class="line">        self.widgetForRight = QWidget(self)</span><br><span class="line">        self.widgetForLeft = QWidget(self)</span><br></pre></td></tr></table></figure><p>第一行代码很好理解，就是创建整体布局并用layOutForAll接受。<strong>那后面两句又是什么意思呢?</strong></p><p>对于一个复杂的页面，我们肯定涉及到<strong>布局中嵌套布局</strong>。比如在这个例子中，左侧嵌套搜索栏的布局；右侧嵌套表格布局；这两个布局是需要通过<code>addWidget</code>函数才能添加，而<code>addWidget</code>函数不支持布局作为参数，因此先要在Widget中用<code>setLayout</code>函数承载小布局，再将Widget放入大布局。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 左侧布局</span></span><br><span class="line">      self.hBoxLayoutForLeft = QHBoxLayout(self)</span><br><span class="line">      self.lineEdit = SearchLineEdit(self)</span><br><span class="line">      self.button = PushButton(<span class="string">&#x27;Search&#x27;</span>, self)</span><br><span class="line">      <span class="comment">#-----其它代码-----</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 右侧布局</span></span><br><span class="line">       self.hBoxLayoutForRight = QHBoxLayout(self)</span><br><span class="line">       self.tableView = TableWidget(self)</span><br><span class="line">       <span class="comment">#-----其他代码-----</span></span><br></pre></td></tr></table></figure><p>然后这里在说明一下：</p><ul><li><code>self.widgetForRight.setLayout(self.hBoxLayoutForRight)</code>指的是将<code>widgetForRight</code>的布局设置为<code>hBoxLayoutForRight</code>。</li><li><code>self.layOutForAll.addWidget(self.widgetForLeft)</code>指的是在布局<code>layOutForAll</code>中添加<code>Widget</code>模块<code>widgetForLeft</code>。</li></ul><p><strong>总结：widget用setLayout设置布局；layout用addWidget添加模块</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加整体布局</span></span><br><span class="line">       self.widgetForRight.setLayout(self.hBoxLayoutForRight)</span><br><span class="line">       self.widgetForLeft.setLayout(self.hBoxLayoutForLeft)</span><br><span class="line">       self.layOutForAll.addWidget(self.widgetForLeft)</span><br><span class="line">       self.layOutForAll.addWidget(self.widgetForRight)</span><br></pre></td></tr></table></figure><h3 id="3、源代码"><a href="#3、源代码" class="headerlink" title="3、源代码"></a>3、源代码</h3><p><strong>3.1 搜索栏源代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line">import sys</span><br><span class="line">from PyQt6.QtCore import Qt</span><br><span class="line">from PyQt6.QtWidgets import QApplication, QWidget, QHBoxLayout, QCompleter</span><br><span class="line"></span><br><span class="line">from qfluentwidgets import LineEdit, PushButton, SearchLineEdit, setTheme, Theme</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Demo(QWidget):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        # self.setStyleSheet(&quot;Demo &#123;background: rgb(32, 32, 32)&#125;&quot;)</span><br><span class="line">        # setTheme(Theme.DARK)</span><br><span class="line"></span><br><span class="line">        self.hBoxLayout = QHBoxLayout(self)</span><br><span class="line">        self.lineEdit = SearchLineEdit(self)</span><br><span class="line">        self.button = PushButton(&#x27;Search&#x27;, self)</span><br><span class="line"></span><br><span class="line">        # add completer</span><br><span class="line">        stands = [</span><br><span class="line">            &quot;Star Platinum&quot;, &quot;Hierophant Green&quot;,</span><br><span class="line">            &quot;Made in Haven&quot;, &quot;King Crimson&quot;,</span><br><span class="line">            &quot;Silver Chariot&quot;, &quot;Crazy diamond&quot;,</span><br><span class="line">            &quot;Metallica&quot;, &quot;Another One Bites The Dust&quot;,</span><br><span class="line">            &quot;Heaven&#x27;s Door&quot;, &quot;Killer Queen&quot;,</span><br><span class="line">            &quot;The Grateful Dead&quot;, &quot;Stone Free&quot;,</span><br><span class="line">            &quot;The World&quot;, &quot;Sticky Fingers&quot;,</span><br><span class="line">            &quot;Ozone Baby&quot;, &quot;Love Love Deluxe&quot;,</span><br><span class="line">            &quot;Hermit Purple&quot;, &quot;Gold Experience&quot;,</span><br><span class="line">            &quot;King Nothing&quot;, &quot;Paper Moon King&quot;,</span><br><span class="line">            &quot;Scary Monster&quot;, &quot;Mandom&quot;,</span><br><span class="line">            &quot;20th Century Boy&quot;, &quot;Tusk Act 4&quot;,</span><br><span class="line">            &quot;Ball Breaker&quot;, &quot;Sex Pistols&quot;,</span><br><span class="line">            &quot;D4C • Love Train&quot;, &quot;Born This Way&quot;,</span><br><span class="line">            &quot;SOFT &amp; WET&quot;, &quot;Paisley Park&quot;,</span><br><span class="line">            &quot;Wonder of U&quot;, &quot;Walking Heart&quot;,</span><br><span class="line">            &quot;Cream Starter&quot;, &quot;November Rain&quot;,</span><br><span class="line">            &quot;Smooth Operators&quot;, &quot;The Matte Kudasai&quot;</span><br><span class="line">        ]</span><br><span class="line">        self.completer = QCompleter(stands, self.lineEdit)</span><br><span class="line">        self.completer.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)</span><br><span class="line">        self.completer.setMaxVisibleItems(10)</span><br><span class="line">        self.lineEdit.setCompleter(self.completer)</span><br><span class="line"></span><br><span class="line">        self.resize(400, 400)</span><br><span class="line">        self.hBoxLayout.setAlignment(Qt.AlignmentFlag.AlignCenter)</span><br><span class="line">        self.hBoxLayout.addWidget(self.lineEdit, 0, Qt.AlignmentFlag.AlignCenter)</span><br><span class="line">        self.hBoxLayout.addWidget(self.button, 0, Qt.AlignmentFlag.AlignCenter)</span><br><span class="line"></span><br><span class="line">        self.lineEdit.setFixedSize(200, 33)</span><br><span class="line">        self.lineEdit.setClearButtonEnabled(True)</span><br><span class="line">        self.lineEdit.setPlaceholderText(&#x27;Search stand&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    w = Demo()</span><br><span class="line">    w.show()</span><br><span class="line">    app.exec()</span><br></pre></td></tr></table></figure><p><strong>3.2 表格源代码</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PyQt6.QtCore <span class="keyword">import</span> QModelIndex, Qt</span><br><span class="line"><span class="keyword">from</span> PyQt6.QtGui <span class="keyword">import</span> QPalette</span><br><span class="line"><span class="keyword">from</span> PyQt6.QtWidgets <span class="keyword">import</span> (</span><br><span class="line">    QApplication,</span><br><span class="line">    QStyleOptionViewItem,</span><br><span class="line">    QTableWidgetItem,</span><br><span class="line">    QWidget,</span><br><span class="line">    QHBoxLayout,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> qfluentwidgets <span class="keyword">import</span> (</span><br><span class="line">    TableWidget,</span><br><span class="line">    isDarkTheme,</span><br><span class="line">    setTheme,</span><br><span class="line">    Theme,</span><br><span class="line">    TableView,</span><br><span class="line">    TableItemDelegate,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomTableItemDelegate</span>(<span class="title class_ inherited__">TableItemDelegate</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Custom table item delegate&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">initStyleOption</span>(<span class="params">self, option: QStyleOptionViewItem, index: QModelIndex</span>):</span><br><span class="line">        <span class="built_in">super</span>().initStyleOption(option, index)</span><br><span class="line">        <span class="keyword">if</span> index.column() != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isDarkTheme():</span><br><span class="line">            option.palette.setColor(QPalette.ColorRole.Text, Qt.GlobalColor.white)</span><br><span class="line">            option.palette.setColor(</span><br><span class="line">                QPalette.ColorRole.HighlightedText, Qt.GlobalColor.white</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            option.palette.setColor(QPalette.ColorRole.Text, Qt.GlobalColor.red)</span><br><span class="line">            option.palette.setColor(</span><br><span class="line">                QPalette.ColorRole.HighlightedText, Qt.GlobalColor.red</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>(<span class="title class_ inherited__">QWidget</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="comment"># setTheme(Theme.DARK)</span></span><br><span class="line"></span><br><span class="line">        self.hBoxLayout = QHBoxLayout(self)</span><br><span class="line">        self.tableView = TableWidget(self)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># <span class="doctag">NOTE:</span> use custom item delegate</span></span><br><span class="line">        <span class="comment"># self.tableView.setItemDelegate(CustomTableItemDelegate(self.tableView))</span></span><br><span class="line"></span><br><span class="line">        self.tableView.setWordWrap(<span class="literal">False</span>)</span><br><span class="line">        self.tableView.setRowCount(<span class="number">60</span>)</span><br><span class="line">        self.tableView.setColumnCount(<span class="number">5</span>)</span><br><span class="line">        songInfos = [</span><br><span class="line">            [<span class="string">&quot;かばん&quot;</span>, <span class="string">&quot;aiko&quot;</span>, <span class="string">&quot;かばん&quot;</span>, <span class="string">&quot;2004&quot;</span>, <span class="string">&quot;5:04&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;爱你&quot;</span>, <span class="string">&quot;王心凌&quot;</span>, <span class="string">&quot;爱你&quot;</span>, <span class="string">&quot;2004&quot;</span>, <span class="string">&quot;3:39&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;星のない世界&quot;</span>, <span class="string">&quot;aiko&quot;</span>, <span class="string">&quot;星のない世界/横顔&quot;</span>, <span class="string">&quot;2007&quot;</span>, <span class="string">&quot;5:30&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;横顔&quot;</span>, <span class="string">&quot;aiko&quot;</span>, <span class="string">&quot;星のない世界/横顔&quot;</span>, <span class="string">&quot;2007&quot;</span>, <span class="string">&quot;5:06&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;秘密&quot;</span>, <span class="string">&quot;aiko&quot;</span>, <span class="string">&quot;秘密&quot;</span>, <span class="string">&quot;2008&quot;</span>, <span class="string">&quot;6:27&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;シアワセ&quot;</span>, <span class="string">&quot;aiko&quot;</span>, <span class="string">&quot;秘密&quot;</span>, <span class="string">&quot;2008&quot;</span>, <span class="string">&quot;5:25&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;二人&quot;</span>, <span class="string">&quot;aiko&quot;</span>, <span class="string">&quot;二人&quot;</span>, <span class="string">&quot;2008&quot;</span>, <span class="string">&quot;5:00&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;スパークル&quot;</span>, <span class="string">&quot;RADWIMPS&quot;</span>, <span class="string">&quot;君の名は。&quot;</span>, <span class="string">&quot;2016&quot;</span>, <span class="string">&quot;8:54&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;なんでもないや&quot;</span>, <span class="string">&quot;RADWIMPS&quot;</span>, <span class="string">&quot;君の名は。&quot;</span>, <span class="string">&quot;2016&quot;</span>, <span class="string">&quot;3:16&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;前前前世&quot;</span>, <span class="string">&quot;RADWIMPS&quot;</span>, <span class="string">&quot;人間開花&quot;</span>, <span class="string">&quot;2016&quot;</span>, <span class="string">&quot;4:35&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;恋をしたのは&quot;</span>, <span class="string">&quot;aiko&quot;</span>, <span class="string">&quot;恋をしたのは&quot;</span>, <span class="string">&quot;2016&quot;</span>, <span class="string">&quot;6:02&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;夏バテ&quot;</span>, <span class="string">&quot;aiko&quot;</span>, <span class="string">&quot;恋をしたのは&quot;</span>, <span class="string">&quot;2016&quot;</span>, <span class="string">&quot;4:41&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;もっと&quot;</span>, <span class="string">&quot;aiko&quot;</span>, <span class="string">&quot;もっと&quot;</span>, <span class="string">&quot;2016&quot;</span>, <span class="string">&quot;4:50&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;問題集&quot;</span>, <span class="string">&quot;aiko&quot;</span>, <span class="string">&quot;もっと&quot;</span>, <span class="string">&quot;2016&quot;</span>, <span class="string">&quot;4:18&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;半袖&quot;</span>, <span class="string">&quot;aiko&quot;</span>, <span class="string">&quot;もっと&quot;</span>, <span class="string">&quot;2016&quot;</span>, <span class="string">&quot;5:50&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;ひねくれ&quot;</span>, <span class="string">&quot;鎖那&quot;</span>, <span class="string">&quot;Hush a by little girl&quot;</span>, <span class="string">&quot;2017&quot;</span>, <span class="string">&quot;3:54&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;シュテルン&quot;</span>, <span class="string">&quot;鎖那&quot;</span>, <span class="string">&quot;Hush a by little girl&quot;</span>, <span class="string">&quot;2017&quot;</span>, <span class="string">&quot;3:16&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;愛は勝手&quot;</span>, <span class="string">&quot;aiko&quot;</span>, <span class="string">&quot;湿った夏の始まり&quot;</span>, <span class="string">&quot;2018&quot;</span>, <span class="string">&quot;5:31&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;ドライブモード&quot;</span>, <span class="string">&quot;aiko&quot;</span>, <span class="string">&quot;湿った夏の始まり&quot;</span>, <span class="string">&quot;2018&quot;</span>, <span class="string">&quot;3:37&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;うん。&quot;</span>, <span class="string">&quot;aiko&quot;</span>, <span class="string">&quot;湿った夏の始まり&quot;</span>, <span class="string">&quot;2018&quot;</span>, <span class="string">&quot;5:48&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;キラキラ&quot;</span>, <span class="string">&quot;aikoの詩。&quot;</span>, <span class="string">&quot;2019&quot;</span>, <span class="string">&quot;5:08&quot;</span>, <span class="string">&quot;aiko&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;恋のスーパーボール&quot;</span>, <span class="string">&quot;aiko&quot;</span>, <span class="string">&quot;aikoの詩。&quot;</span>, <span class="string">&quot;2019&quot;</span>, <span class="string">&quot;4:31&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;磁石&quot;</span>, <span class="string">&quot;aiko&quot;</span>, <span class="string">&quot;どうしたって伝えられないから&quot;</span>, <span class="string">&quot;2021&quot;</span>, <span class="string">&quot;4:24&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;食べた愛&quot;</span>, <span class="string">&quot;aiko&quot;</span>, <span class="string">&quot;食べた愛/あたしたち&quot;</span>, <span class="string">&quot;2021&quot;</span>, <span class="string">&quot;5:17&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;列車&quot;</span>, <span class="string">&quot;aiko&quot;</span>, <span class="string">&quot;食べた愛/あたしたち&quot;</span>, <span class="string">&quot;2021&quot;</span>, <span class="string">&quot;4:18&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;花の塔&quot;</span>, <span class="string">&quot;さユり&quot;</span>, <span class="string">&quot;花の塔&quot;</span>, <span class="string">&quot;2022&quot;</span>, <span class="string">&quot;4:35&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;夏恋のライフ&quot;</span>, <span class="string">&quot;aiko&quot;</span>, <span class="string">&quot;夏恋のライフ&quot;</span>, <span class="string">&quot;2022&quot;</span>, <span class="string">&quot;5:03&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;あかときリロード&quot;</span>, <span class="string">&quot;aiko&quot;</span>, <span class="string">&quot;あかときリロード&quot;</span>, <span class="string">&quot;2023&quot;</span>, <span class="string">&quot;4:04&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;荒れた唇は恋を失くす&quot;</span>, <span class="string">&quot;aiko&quot;</span>, <span class="string">&quot;今の二人をお互いが見てる&quot;</span>, <span class="string">&quot;2023&quot;</span>, <span class="string">&quot;4:07&quot;</span>],</span><br><span class="line">            [<span class="string">&quot;ワンツースリー&quot;</span>, <span class="string">&quot;aiko&quot;</span>, <span class="string">&quot;今の二人をお互いが見てる&quot;</span>, <span class="string">&quot;2023&quot;</span>, <span class="string">&quot;4:47&quot;</span>],</span><br><span class="line">        ]</span><br><span class="line">        songInfos += songInfos</span><br><span class="line">        <span class="keyword">for</span> i, songInfo <span class="keyword">in</span> <span class="built_in">enumerate</span>(songInfos):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">                self.tableView.setItem(i, j, QTableWidgetItem(songInfo[j]))</span><br><span class="line"></span><br><span class="line">        self.tableView.verticalHeader().hide()</span><br><span class="line">        self.tableView.resizeColumnsToContents()</span><br><span class="line">        self.tableView.setHorizontalHeaderLabels(</span><br><span class="line">            [<span class="string">&quot;Title&quot;</span>, <span class="string">&quot;Artist&quot;</span>, <span class="string">&quot;Album&quot;</span>, <span class="string">&quot;Year&quot;</span>, <span class="string">&quot;Duration&quot;</span>]</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># self.tableView.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)</span></span><br><span class="line">        <span class="comment"># self.tableView.setSortingEnabled(True)</span></span><br><span class="line"></span><br><span class="line">        self.setStyleSheet(<span class="string">&quot;Demo&#123;background: rgb(249, 249, 249)&#125; &quot;</span>)</span><br><span class="line">        self.hBoxLayout.setContentsMargins(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        self.hBoxLayout.addWidget(self.tableView)</span><br><span class="line">        self.resize(<span class="number">635</span>, <span class="number">700</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    w = Demo()</span><br><span class="line">    w.show()</span><br><span class="line">    app.<span class="built_in">exec</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3.3总体源代码</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PyQt6.QtCore <span class="keyword">import</span> QModelIndex, Qt</span><br><span class="line"><span class="keyword">from</span> PyQt6.QtGui <span class="keyword">import</span> QPalette</span><br><span class="line"><span class="keyword">from</span> PyQt6.QtWidgets <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> qfluentwidgets <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomTableItemDelegate</span>(<span class="title class_ inherited__">TableItemDelegate</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Custom table item delegate &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">initStyleOption</span>(<span class="params">self, option: QStyleOptionViewItem, index: QModelIndex</span>):</span><br><span class="line">        <span class="built_in">super</span>().initStyleOption(option, index)</span><br><span class="line">        <span class="keyword">if</span> index.column() != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isDarkTheme():</span><br><span class="line">            option.palette.setColor(QPalette.ColorRole.Text, Qt.GlobalColor.white)</span><br><span class="line">            option.palette.setColor(QPalette.ColorRole.HighlightedText, Qt.GlobalColor.white)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            option.palette.setColor(QPalette.ColorRole.Text, Qt.GlobalColor.red)</span><br><span class="line">            option.palette.setColor(QPalette.ColorRole.HighlightedText, Qt.GlobalColor.red)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>(<span class="title class_ inherited__">QWidget</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="comment"># setTheme(Theme.DARK)</span></span><br><span class="line">        <span class="comment"># 整体布局</span></span><br><span class="line">        self.layOutForAll = QHBoxLayout(self)</span><br><span class="line">        self.widgetForRight = QWidget(self)</span><br><span class="line">        self.widgetForLeft = QWidget(self)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 右侧布局</span></span><br><span class="line">        self.hBoxLayoutForRight = QHBoxLayout(self)</span><br><span class="line">        self.tableView = TableWidget(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># <span class="doctag">NOTE:</span> use custom item delegate</span></span><br><span class="line">        <span class="comment"># self.tableView.setItemDelegate(CustomTableItemDelegate(self.tableView))</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># select row on right-click</span></span><br><span class="line">        <span class="comment"># self.tableView.setSelectRightClickedRow(True)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># enable border</span></span><br><span class="line">        self.tableView.setBorderVisible(<span class="literal">True</span>)</span><br><span class="line">        self.tableView.setBorderRadius(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">        self.tableView.setWordWrap(<span class="literal">False</span>)</span><br><span class="line">        self.tableView.setRowCount(<span class="number">60</span>)</span><br><span class="line">        self.tableView.setColumnCount(<span class="number">5</span>)</span><br><span class="line">        songInfos = [</span><br><span class="line">            [<span class="string">&#x27;かばん&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>, <span class="string">&#x27;かばん&#x27;</span>, <span class="string">&#x27;2004&#x27;</span>, <span class="string">&#x27;5:04&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;爱你&#x27;</span>, <span class="string">&#x27;王心凌&#x27;</span>, <span class="string">&#x27;爱你&#x27;</span>, <span class="string">&#x27;2004&#x27;</span>, <span class="string">&#x27;3:39&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;星のない世界&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>, <span class="string">&#x27;星のない世界/横顔&#x27;</span>, <span class="string">&#x27;2007&#x27;</span>, <span class="string">&#x27;5:30&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;横顔&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>, <span class="string">&#x27;星のない世界/横顔&#x27;</span>, <span class="string">&#x27;2007&#x27;</span>, <span class="string">&#x27;5:06&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;秘密&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>, <span class="string">&#x27;秘密&#x27;</span>, <span class="string">&#x27;2008&#x27;</span>, <span class="string">&#x27;6:27&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;シアワセ&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>, <span class="string">&#x27;秘密&#x27;</span>, <span class="string">&#x27;2008&#x27;</span>, <span class="string">&#x27;5:25&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;二人&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>, <span class="string">&#x27;二人&#x27;</span>, <span class="string">&#x27;2008&#x27;</span>, <span class="string">&#x27;5:00&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;スパークル&#x27;</span>, <span class="string">&#x27;RADWIMPS&#x27;</span>, <span class="string">&#x27;君の名は。&#x27;</span>, <span class="string">&#x27;2016&#x27;</span>, <span class="string">&#x27;8:54&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;なんでもないや&#x27;</span>, <span class="string">&#x27;RADWIMPS&#x27;</span>, <span class="string">&#x27;君の名は。&#x27;</span>, <span class="string">&#x27;2016&#x27;</span>, <span class="string">&#x27;3:16&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;前前前世&#x27;</span>, <span class="string">&#x27;RADWIMPS&#x27;</span>, <span class="string">&#x27;人間開花&#x27;</span>, <span class="string">&#x27;2016&#x27;</span>, <span class="string">&#x27;4:35&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;恋をしたのは&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>, <span class="string">&#x27;恋をしたのは&#x27;</span>, <span class="string">&#x27;2016&#x27;</span>, <span class="string">&#x27;6:02&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;夏バテ&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>, <span class="string">&#x27;恋をしたのは&#x27;</span>, <span class="string">&#x27;2016&#x27;</span>, <span class="string">&#x27;4:41&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;もっと&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>, <span class="string">&#x27;もっと&#x27;</span>, <span class="string">&#x27;2016&#x27;</span>, <span class="string">&#x27;4:50&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;問題集&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>, <span class="string">&#x27;もっと&#x27;</span>, <span class="string">&#x27;2016&#x27;</span>, <span class="string">&#x27;4:18&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;半袖&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>, <span class="string">&#x27;もっと&#x27;</span>, <span class="string">&#x27;2016&#x27;</span>, <span class="string">&#x27;5:50&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;ひねくれ&#x27;</span>, <span class="string">&#x27;鎖那&#x27;</span>, <span class="string">&#x27;Hush a by little girl&#x27;</span>, <span class="string">&#x27;2017&#x27;</span>, <span class="string">&#x27;3:54&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;シュテルン&#x27;</span>, <span class="string">&#x27;鎖那&#x27;</span>, <span class="string">&#x27;Hush a by little girl&#x27;</span>, <span class="string">&#x27;2017&#x27;</span>, <span class="string">&#x27;3:16&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;愛は勝手&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>, <span class="string">&#x27;湿った夏の始まり&#x27;</span>, <span class="string">&#x27;2018&#x27;</span>, <span class="string">&#x27;5:31&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;ドライブモード&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>, <span class="string">&#x27;湿った夏の始まり&#x27;</span>, <span class="string">&#x27;2018&#x27;</span>, <span class="string">&#x27;3:37&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;うん。&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>, <span class="string">&#x27;湿った夏の始まり&#x27;</span>, <span class="string">&#x27;2018&#x27;</span>, <span class="string">&#x27;5:48&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;キラキラ&#x27;</span>, <span class="string">&#x27;aikoの詩。&#x27;</span>, <span class="string">&#x27;2019&#x27;</span>, <span class="string">&#x27;5:08&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;恋のスーパーボール&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>, <span class="string">&#x27;aikoの詩。&#x27;</span>, <span class="string">&#x27;2019&#x27;</span>, <span class="string">&#x27;4:31&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;磁石&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>, <span class="string">&#x27;どうしたって伝えられないから&#x27;</span>, <span class="string">&#x27;2021&#x27;</span>, <span class="string">&#x27;4:24&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;食べた愛&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>, <span class="string">&#x27;食べた愛/あたしたち&#x27;</span>, <span class="string">&#x27;2021&#x27;</span>, <span class="string">&#x27;5:17&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;列車&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>, <span class="string">&#x27;食べた愛/あたしたち&#x27;</span>, <span class="string">&#x27;2021&#x27;</span>, <span class="string">&#x27;4:18&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;花の塔&#x27;</span>, <span class="string">&#x27;さユり&#x27;</span>, <span class="string">&#x27;花の塔&#x27;</span>, <span class="string">&#x27;2022&#x27;</span>, <span class="string">&#x27;4:35&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;夏恋のライフ&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>, <span class="string">&#x27;夏恋のライフ&#x27;</span>, <span class="string">&#x27;2022&#x27;</span>, <span class="string">&#x27;5:03&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;あかときリロード&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>, <span class="string">&#x27;あかときリロード&#x27;</span>, <span class="string">&#x27;2023&#x27;</span>, <span class="string">&#x27;4:04&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;荒れた唇は恋を失くす&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>, <span class="string">&#x27;今の二人をお互いが見てる&#x27;</span>, <span class="string">&#x27;2023&#x27;</span>, <span class="string">&#x27;4:07&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;ワンツースリー&#x27;</span>, <span class="string">&#x27;aiko&#x27;</span>, <span class="string">&#x27;今の二人をお互いが見てる&#x27;</span>, <span class="string">&#x27;2023&#x27;</span>, <span class="string">&#x27;4:47&#x27;</span>],</span><br><span class="line">        ]</span><br><span class="line">        songInfos += songInfos</span><br><span class="line">        <span class="keyword">for</span> i, songInfo <span class="keyword">in</span> <span class="built_in">enumerate</span>(songInfos):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">                self.tableView.setItem(i, j, QTableWidgetItem(songInfo[j]))</span><br><span class="line"></span><br><span class="line">        self.tableView.verticalHeader().hide()</span><br><span class="line">        self.tableView.resizeColumnsToContents()</span><br><span class="line">        self.tableView.setHorizontalHeaderLabels([<span class="string">&#x27;Title&#x27;</span>, <span class="string">&#x27;Artist&#x27;</span>, <span class="string">&#x27;Album&#x27;</span>, <span class="string">&#x27;Year&#x27;</span>, <span class="string">&#x27;Duration&#x27;</span>])</span><br><span class="line">        <span class="comment"># self.tableView.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)</span></span><br><span class="line">        <span class="comment"># self.tableView.setSortingEnabled(True)</span></span><br><span class="line"></span><br><span class="line">        self.setStyleSheet(<span class="string">&quot;Demo&#123;background: rgb(255, 255, 255)&#125; &quot;</span>)</span><br><span class="line">        self.hBoxLayoutForRight.setContentsMargins(<span class="number">50</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">30</span>)</span><br><span class="line">        self.hBoxLayoutForRight.addWidget(self.tableView)</span><br><span class="line">        self.resize(<span class="number">735</span>, <span class="number">760</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 左侧布局</span></span><br><span class="line">        self.hBoxLayoutForLeft = QHBoxLayout(self)</span><br><span class="line">        self.lineEdit = SearchLineEdit(self)</span><br><span class="line">        self.button = PushButton(<span class="string">&#x27;Search&#x27;</span>, self)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># add completer</span></span><br><span class="line">        stands = [</span><br><span class="line">            <span class="string">&quot;Star Platinum&quot;</span>, <span class="string">&quot;Hierophant Green&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Made in Haven&quot;</span>, <span class="string">&quot;King Crimson&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Silver Chariot&quot;</span>, <span class="string">&quot;Crazy diamond&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Metallica&quot;</span>, <span class="string">&quot;Another One Bites The Dust&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Heaven&#x27;s Door&quot;</span>, <span class="string">&quot;Killer Queen&quot;</span>,</span><br><span class="line">            <span class="string">&quot;The Grateful Dead&quot;</span>, <span class="string">&quot;Stone Free&quot;</span>,</span><br><span class="line">            <span class="string">&quot;The World&quot;</span>, <span class="string">&quot;Sticky Fingers&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Ozone Baby&quot;</span>, <span class="string">&quot;Love Love Deluxe&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Hermit Purple&quot;</span>, <span class="string">&quot;Gold Experience&quot;</span>,</span><br><span class="line">            <span class="string">&quot;King Nothing&quot;</span>, <span class="string">&quot;Paper Moon King&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Scary Monster&quot;</span>, <span class="string">&quot;Mandom&quot;</span>,</span><br><span class="line">            <span class="string">&quot;20th Century Boy&quot;</span>, <span class="string">&quot;Tusk Act 4&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Ball Breaker&quot;</span>, <span class="string">&quot;Sex Pistols&quot;</span>,</span><br><span class="line">            <span class="string">&quot;D4C • Love Train&quot;</span>, <span class="string">&quot;Born This Way&quot;</span>,</span><br><span class="line">            <span class="string">&quot;SOFT &amp; WET&quot;</span>, <span class="string">&quot;Paisley Park&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Wonder of U&quot;</span>, <span class="string">&quot;Walking Heart&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Cream Starter&quot;</span>, <span class="string">&quot;November Rain&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Smooth Operators&quot;</span>, <span class="string">&quot;The Matte Kudasai&quot;</span></span><br><span class="line">        ]</span><br><span class="line">        self.completer = QCompleter(stands, self.lineEdit)</span><br><span class="line">        self.completer.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)</span><br><span class="line">        self.completer.setMaxVisibleItems(<span class="number">10</span>)</span><br><span class="line">        self.lineEdit.setCompleter(self.completer)</span><br><span class="line"></span><br><span class="line">        self.resize(<span class="number">400</span>, <span class="number">400</span>)</span><br><span class="line">        self.hBoxLayoutForLeft.setAlignment(Qt.AlignmentFlag.AlignCenter)</span><br><span class="line">        self.hBoxLayoutForLeft.addWidget(self.lineEdit, <span class="number">0</span>, Qt.AlignmentFlag.AlignCenter)</span><br><span class="line">        self.hBoxLayoutForLeft.addWidget(self.button, <span class="number">0</span>, Qt.AlignmentFlag.AlignCenter)</span><br><span class="line"></span><br><span class="line">        self.lineEdit.setFixedSize(<span class="number">200</span>, <span class="number">33</span>)</span><br><span class="line">        self.lineEdit.setClearButtonEnabled(<span class="literal">True</span>)</span><br><span class="line">        self.lineEdit.setPlaceholderText(<span class="string">&#x27;Search stand&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 添加整体布局</span></span><br><span class="line">        self.widgetForRight.setLayout(self.hBoxLayoutForRight)</span><br><span class="line">        self.widgetForLeft.setLayout(self.hBoxLayoutForLeft)</span><br><span class="line">        self.layOutForAll.addWidget(self.widgetForLeft)</span><br><span class="line">        self.layOutForAll.addWidget(self.widgetForRight)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    w = Demo()</span><br><span class="line">    w.show()</span><br><span class="line">    app.<span class="built_in">exec</span>()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pyqt6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea常用快捷键</title>
      <link href="/2024/04/02/idea%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2024/04/02/idea%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="idea-快捷键"><a href="#idea-快捷键" class="headerlink" title="idea 快捷键"></a><strong>idea 快捷键</strong></h1><p>连续按两下shift是可以进行搜索，包括类和文件等</p><p>ctrl+alt+t 插入模板快捷键，比如可以插入try-catch,if-else等。</p><p>.for循环补全</p><p>alt 8调出services</p><p>ctrl n搜索类</p><p>ctrl p可以添加的参数类型</p><p>ctrl f12 找类中方法</p><p>alt insert快捷插入</p><p>ctrl alt v自动生成左侧变量</p><p>ctrl alt h 查看当前方法被谁用了</p><p>ctrl h 查看谁实现了该接口</p><p>选中单词 ctrl shift u改为大写</p><p>ctrl d复制黏贴一行</p><p>点击红色波浪线，alt 回车选择解决方案</p><p>右键方法，点击implemention跳转到实现类中的方法，而不是接口。</p><p>ctrl alt v 自动生成左边</p><p>ctrl alt b 展现继承Show implementations</p><p>Ctrl+j显示所有快捷键的方式</p><p>f7 单步执行 alt shift f7进入源码debug</p><p>ctrl+o查看父类所有的方法，点击override</p>]]></content>
      
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
